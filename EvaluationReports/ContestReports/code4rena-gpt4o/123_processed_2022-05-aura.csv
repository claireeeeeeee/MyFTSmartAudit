nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
ExtraRewardsDistributor.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";

/**
 * @title   ExtraRewardsDistributor
 * @author  adapted from ConvexFinance
 * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.
 */
contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    // token -> epoch -> amount
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    // token -> epochList
    mapping(address => uint256[]) public rewardEpochs;
    // token -> account -> last claimed epoch index
    mapping(address => mapping(address => uint256)) public userClaims;

    /* ========== EVENTS ========== */

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    /**
     * @dev Simple constructoor
     * @param _auraLocker Aura Locker address
     */
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    /* ========== ADD REWARDS ========== */

    /**
     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokenπ
     */
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    /**
     * @notice Add reward token to a specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens to add
     * @param _epoch    Which epoch to add to (must be less than the previous epoch)
     */
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    /**
     * @notice  Transfer reward tokens from sender to contract for vlCVX holders
     * @dev     Add reward token for specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens
     * @param _epoch    Epoch to add tokens to
     */
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        // Pull before reward accrual
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        //convert to reward per token
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        //add epoch to list
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        //event
        emit RewardAdded(_token, _epoch, _amount);
    }

    /* ========== GET REWARDS ========== */

    /**
     * @notice Claim rewards for a specific token since the first epoch.
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account      Address of vlCVX holder
     * @param _token        Reward token address
     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from
     */
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        //get claimable tokens
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            //set claim checkpoint
            userClaims[_token][_account] = index;

            //send
            IERC20(_token).safeTransfer(_account, claimableTokens);

            //event
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    /**
     * @notice  Allow a user to set their claimed index forward without claiming rewards
     *          Because claims cycle through all periods that a specific reward was given
     *          there becomes a situation where, for example, a new user could lock
     *          2 years from now and try to claim a token that was given out every week prior.
     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)
     * @param _token  Reward token to forfeit
     * @param _index  Epoch index to forfeit from
     */
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        //set claim checkpoint. next claim starts from index+1
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    /* ========== VIEW REWARDS ========== */

    /**
     * @notice Get claimable rewards (rewardToken) for vlCVX holder
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    /**
     * @notice  Get all claimable rewards by looping through each epoch starting with the latest
     *          saved epoch the user last claimed from
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        // e.g. tokenEpochs = 31, 21
        uint256 tokenEpochs = rewardEpochs[_token].length;

        // e.g. epochIndex = 0
        uint256 epochIndex = userClaims[_token][_account];
        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            //only claimable after rewards are ""locked in""
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                //return index user claims should be set to
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        //get balance and calc share
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    /**
     * @notice Simply gets the current epoch count for a given reward token
     * @param _token    Reward token address
     * @return _epochs  Number of epochs
     */
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",2365.0,268.0,"[H-01] User can forfeit other user rewards
User can forfeit other user rewards by giving a higher `_startIndex` in `getReward` function.

[M-05] Users can grief reward distribution
Users can grief reward distributions by spending dust.
If a reward is targeted for an epoch in the past, a user can front-run the txn in the mempool and call addRewardToEpoch() with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert

[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.

[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens
If rewards are given in fee-on-transfer tokens, users may get no rewards, breaking functionality.",4.0,"pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";


contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    
    mapping(address => uint256[]) public rewardEpochs;
    
    mapping(address => mapping(address => uint256)) public userClaims;

    

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    

    
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        
        emit RewardAdded(_token, _epoch, _amount);
    }

    

    
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            
            userClaims[_token][_account] = index;

            
            IERC20(_token).safeTransfer(_account, claimableTokens);

            
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    

    
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        
        uint256 tokenEpochs = rewardEpochs[_token].length;

        
        uint256 epochIndex = userClaims[_token][_account];
        
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",1352.0,1,3,"The provided smart contract has several components and functionalities that require careful review for potential vulnerabilities. Below is a list of potential vulnerabilities and risks in this Solidity smart contract:

---

### 1. **Reentrancy Risk**
Even though the contract uses `ReentrancyGuard` for some key functions (e.g., `_addReward`), there are other external calls in the contract that do not leverage `nonReentrant`, including:
- In `_getReward`, the contract calls `safeTransfer` to transfer tokens, which can potentially invoke external code (from malicious tokens/contracts).
- If malicious tokens are used in `IERC20.safeTransfer`, `_getReward` could be indirectly reentered before `userClaims` is updated.

To mitigate this, ensure `ReentrancyGuard` is applied consistently to all functions performing external transfers or state-dependent logic.

---

### 2. **Arithmetic Edge Cases**
- In `_addReward`, the contract performs the calculation:  
  ```solidity
  uint256 rPerT = (_amount * 1e20) / supply;
  ```
  If `supply` (the total supply from `auraLocker.totalSupplyAtEpoch`) is zero, this will revert due to division by zero. Ensure `supply` cannot be zero when rewards are added.

---

### 3. **Lack of Permission Controls on Adding Rewards**
Both `addReward` and `addRewardToEpoch` can be called by anyone (they are `external` functions). This enables malicious actors or arbitrary users to add rewards for tokens, potentially creating unintended outcomes:
- They could add ""junk"" tokens as rewards.
- They might manipulate reward distribution or exhaust gas for other users.
- There's no control restricting reward addition to contracts/owners that are authorized.

Adding an access control mechanism (e.g., `onlyOwner` or role-based validation) could prevent abuse.

---

### 4. **Dependence on External Contract's Behavior**
The contract heavily relies on the external `IAuraLocker` contract for operations such as:
- Total supply during a specific epoch (`totalSupplyAtEpoch`).
- User balances during specific epochs (`balanceAtEpochOf`).
- Epoch count (`epochCount`).

Any changes, bugs, or vulnerabilities in the `IAuraLocker` contract directly affect the security and functionality of this implementation.

---

### 5. **Lack of Explicit `SafeERC20` Checks for Return Values**
Although `SafeERC20` is used for transferring and transferring tokens from users, it assumes tokens conform to the ERC20 standard. If a token does not behave as intended (e.g., does not return `true` on `transfer`/`transferFrom` success), incorrect behavior can go unnoticed. Consider adding explicit checks for token behavior if dealing with untrusted ERC20 tokens.

---

### 6. **Epoch Manipulation Risks**
There are checks like:
```solidity
require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");
```
These checks prevent ""backdating"" rewards to unexpected epochs **only when `_epoch` is older than `rewardEpochs[_token][len - 1]`. However:
- A malicious actor controlling multiple epochs (or having deep insight into epoch behavior) might still manipulate reward timing using gas optimizations or front-running.

To address this, consider validating epochs against stricter rules or requiring more stringent validation logic.

---

### 7. **Reward Forfeiture Front-running**
Function `forfeitRewards` allows a user to forfeit rewards for a specific epoch:
```solidity
require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
require(_index >= userClaims[_token][msg.sender], ""already claimed"");
```
This can be front-run in some scenarios. For example:
- If `forfeitRewards` is called during times when epochs or rewards are updated, it could affect reward calculations for users.
- Malicious actors might invalidate or ""skip over"" valid reward claims for themselves or others.

Measures should be taken to prevent malicious front-running (e.g., against Claimed Reward indices).

---

### 8. **Lack of Gas Optimization**
The function `_allClaimableRewards` uses a `for` loop:
```solidity
for (uint256 i = epochIndex; i < tokenEpochs; i++) {
    ...
}
```
If the `rewardEpochs[_token]` array grows excessively large, the loop may run out of gas, making it infeasible to calculate or claim rewards. This can lead to DOS (Denial of Service) attacks for accounts with many epochs.

Consider breaking such loops into smaller, claimable chunks or imposing bounds on the size of `rewardEpochs`.

---

### 9. **Duplicate Function Signatures in `getReward`**
There are two overloaded functions with the signature `getReward`:
```solidity
function getReward(address _account, address _token) public;
function getReward(address _account, address _token, uint256 _startIndex) public;
```
Overloading can be confusing because the compiler generates identical ABI encodings that can introduce errors when interfacing with external tools/dapps. Consider giving them distinct names for clarity.

---

### 10. **Global State Exposure**
Key mappings such as `rewardData`, `rewardEpochs`, and `userClaims` are `public`. While this provides transparency, making all internal reward mechanisms directly visible could inadvertently expose sensitive logic/data for attacks. Validation or rate-limiting mechanisms could help mitigate brute-force attempts to query/manipulate data.

---

### 11. **Potential Cross-Contract Claim Manipulation**
The contract uses:
```solidity
userClaims[_token][_account] = index;
```
to track the last claimed reward index. However, since this is tied specifically to `_token` and `_account`, multiple overlapping claims from separate contracts (or with shared inputs) could interfere with or invalidate correct rewards. Secondary validation logic (or tighter index control) may reduce risks.

---

**Summary of Vulnerabilities:**
1. Reentrancy risk.
2. Division by zero in `_addReward`.
3. Lack of access control on adding rewards.
4. Reliance on external contract (`IAuraLocker`) behavior.
5. ERC20 token safety assumptions.
6. Epoch manipulation risks.
7. Front-running risks in forfeiting rewards.
8. Gas inefficiency with loops in `_allClaimableRewards`.
9. Confusion caused by overloaded `getReward` function.
10. Overexposed state variables.
11. Cross-contract reward claim interference risks.

---

**Remediation Recommendations:**
- Implement access control (e.g., `onlyOwner`) for sensitive functions.
- Add checks for non-zero supply and other edge cases.
- Use `nonReentrant` consistently for external-call-heavy functions.
- Validate external contract (`IAuraLocker`) behavior explicitly.
- Restructure loops for high gas-efficiency.
- Ensure functions have clear naming conventions to avoid ambiguity.
- Protect state updates such as `userClaims` from cross-contract interference.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[H-01] User can forfeit other user rewards**

**Report Description**:  
The `getReward` function allows a user to forfeit other users' rewards by providing a higher `_startIndex`. This could lead to a situation where rewards intended for one user are claimed or invalidated by another, resulting in a loss of rewards for the rightful recipient.

**Match in Response List**:  
Partially matches with **""Reward Forfeiture Front-running""** in the response list.

**Validation**:  
**Partially Correct**.  
The response identifies a related issue with the `forfeitRewards` function, where malicious actors could front-run and invalidate reward claims. However, it does not explicitly address the vulnerability in the `getReward` function, where a user can manipulate `_startIndex` to forfeit another user's rewards. The response should have explicitly mentioned the need to validate `_startIndex` against the user's actual claimable range to prevent this issue.

**Suggestions**:  
- Add validation logic in the `getReward` function to ensure that `_startIndex` is within the bounds of the user's claimable rewards.
- Consider implementing stricter access control or user-specific reward tracking to prevent manipulation.

---

#### **[M-05] Users can grief reward distribution**

**Report Description**:  
Users can grief reward distribution by spending dust amounts. Specifically, if a reward is targeted for an epoch in the past, a user can front-run the transaction in the mempool and call `addRewardToEpoch()` with a dust amount at a later epoch. This causes the original transaction to revert, disrupting the reward distribution process.

**Match in Response List**:  
Partially matches with **""Lack of Permission Controls on Adding Rewards""** and **""Epoch Manipulation Risks""**.

**Validation**:  
**Partially Correct**.  
The response highlights the lack of access control on `addRewardToEpoch`, which allows arbitrary users to add rewards and potentially manipulate reward distribution. It also mentions risks related to epoch manipulation. However, it does not explicitly address the specific griefing scenario where a user can front-run with a dust amount to disrupt reward distribution. The response should have included a recommendation to validate reward amounts and restrict access to `addRewardToEpoch` to authorized users only.

**Suggestions**:  
- Implement access control (e.g., `onlyOwner` or role-based permissions) for `addRewardToEpoch`.
- Add a minimum reward amount check to prevent griefing with dust amounts.
- Consider using a locking mechanism to prevent front-running during reward distribution.

---

#### **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**

**Report Description**:  
If a user does not claim their rewards for an extended period, the rewards may become locked due to the accumulation of too many epochs. This could force the platform to reimburse the user, leading to significant economic losses.

**Match in Response List**:  
Partially matches with **""Gas Inefficiency with Loops in `_allClaimableRewards`""**.

**Validation**:  
**Partially Correct**.  
The response identifies a related issue with gas inefficiency in the `_allClaimableRewards` function, where a large number of epochs could make the loop infeasible to execute. However, it does not explicitly address the scenario where unclaimed rewards become permanently locked due to excessive epochs. The response should have included a recommendation to implement a mechanism for handling unclaimed rewards over long periods.

**Suggestions**:  
- Introduce a mechanism to batch or consolidate rewards for older epochs to prevent them from becoming unclaimable.
- Consider implementing a time limit for claiming rewards, after which unclaimed rewards are returned to the platform or redistributed.

---

#### **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

**Report Description**:  
If rewards are distributed in fee-on-transfer tokens, users may receive reduced or no rewards due to the token's transfer fee mechanism. This could break the reward distribution functionality and lead to user losses.

**Match in Response List**:  
Partially matches with **""Lack of Explicit `SafeERC20` Checks for Return Values""**.

**Validation**:  
**Partially Correct**.  
The response mentions the risks of assuming ERC20 token behavior and recommends adding explicit checks for token behavior. However, it does not specifically address the issue of fee-on-transfer tokens, which require additional handling to account for transfer fees. The response should have included a recommendation to calculate and adjust rewards based on the actual amount received after the transfer fee.

**Suggestions**:  
- Add logic to handle fee-on-transfer tokens by calculating the net amount received after the transfer fee.
- Consider using a whitelist to restrict rewards to tokens with standard ERC20 behavior.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Reentrancy Risk in `_getReward`**

**Response Description**:  
The response highlights a potential reentrancy risk in the `_getReward` function due to external calls to `safeTransfer`. It recommends applying `ReentrancyGuard` consistently to all functions performing external transfers or state-dependent logic.

**Assessment**:  
**Valid Concern**.  
While this issue was not explicitly mentioned in the original `issue` report, it is a valid concern. External calls in `_getReward` could indeed introduce reentrancy risks, especially if malicious tokens are used. Applying `ReentrancyGuard` is a recognized best practice to mitigate such risks.

---

#### **[R-02] Division by Zero in `_addReward`**

**Response Description**:  
The response identifies a potential division-by-zero error in `_addReward` if the `supply` is zero. It recommends adding a check to ensure `supply` is non-zero before performing the division.

**Assessment**:  
**Valid Concern**.  
This issue was not mentioned in the original `issue` report but is a valid concern. Division by zero is a critical vulnerability that could cause the contract to revert unexpectedly. Adding a check for non-zero `supply` is essential to prevent this issue.

---

### **Summary of Matches and Gaps**

#### **Correct Matches**:
- None.

#### **Partially Correct Matches**:
1. **[H-01] User can forfeit other user rewards**: Partially addressed under ""Reward Forfeiture Front-running.""
2. **[M-05] Users can grief reward distribution**: Partially addressed under ""Lack of Permission Controls on Adding Rewards"" and ""Epoch Manipulation Risks.""
3. **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**: Partially addressed under ""Gas Inefficiency with Loops in `_allClaimableRewards`.""
4. **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**: Partially addressed under ""Lack of Explicit `SafeERC20` Checks for Return Values.""

#### **Missed Issues from Issue Report**:
- None explicitly missed, but responses were incomplete for all issues.

#### **GPT-Generated Potential Issues (May Be Incorrect)**:
1. **Reentrancy Risk in `_getReward`**: Valid concern.
2. **Division by Zero in `_addReward`**: Valid concern.

---",0,4,0,11,"```
None.
```",0.0
AuraLocker.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}

/**
 * @title   AuraLocker
 * @author  ConvexFinance
 * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available
 *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes
 *          to depositors.
 * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.
 */
contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ==========     STRUCTS     ========== */

    struct RewardData {
        /// Timestamp for current period finish
        uint32 periodFinish;
        /// Last time any user took action
        uint32 lastUpdateTime;
        /// RewardRate for the rest of the period
        uint96 rewardRate;
        /// Ever increasing rewardPerToken rate, based on % of total supply
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; //epoch start date
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    /* ========== STATE VARIABLES ========== */

    // Rewards
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    //     Core reward data
    mapping(address => RewardData) public rewardData;
    //     Reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    //     User -> reward token -> amount
    mapping(address => mapping(address => UserData)) public userData;
    //     Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    //     Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // Balances
    //     Supplies and historic supply
    uint256 public lockedSupply;
    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply
    Epoch[] public epochs;
    //     Mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    // Voting
    //     Stored delegations
    mapping(address => address) private _delegates;
    //     Checkpointed votes
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    //     Delegatee balances (user -> unlock timestamp -> amount)
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    // Config
    //     Tokens
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    //     Denom for calcs
    uint256 public constant denominator = 10000;
    //     Staking cvxCrv
    address public immutable cvxcrvStaking;
    //     Incentives
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    //     Shutdown
    bool public isShutdown = false;

    // Basic token data
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== EVENTS ========== */

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    /***************************************
                    CONSTRUCTOR
    ****************************************/

    /**
     * @param _nameArg          Token name, simples
     * @param _symbolArg        Token symbol
     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)
     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)
     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)
     */
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    /***************************************
                    MODIFIER
    ****************************************/

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    /***************************************
                    ADMIN
    ****************************************/

    // Add a new reward token to be distributed to stakers
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); //max 5% per epoch
        require(_delay >= 2, ""min delay""); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    // Set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    /***************************************
                    ACTIONS
    ****************************************/

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount);
    }

    //lock tokens
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //add user balances
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(_amount);

        //add user lock records or add to current
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps until the next epoch date.
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        // e.g. now = 16
        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)
        // e.g. 17 <= (16 + 1)
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > expiryTime) break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        //checkpoint the delegatee
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        //relock or return to user
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    /***************************************
            DELEGATION & VOTE BALANCE
    ****************************************/

    /**
     * @dev Delegate votes from the sender to `newDelegatee`.
     */
    function delegate(address newDelegatee) external virtual nonReentrant {
        // Step 1: Get lock data
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        // Step 2: Update delegatee storage
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        // Step 3: Move balances around
        //         Delegate for the upcoming epoch
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        // Step 3.1: Add future unlocks and sum balances
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        // Step 3.2: Checkpoint old delegatee
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        // Step 3.3: Checkpoint new delegatee
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        // This would only skip on first checkpointing
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired
                // e.g. week 1 + 17 <= 18
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    // Should be maximum 18 iterations
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    /**
     * @dev Get the address `account` is currently delegating to.
     */
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    /**
     * @dev Gets the current votes balance for `account`
     */
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    /**
     * @dev Get the `pos`-th checkpoint for `account`.
     */
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    /**
     * @dev Get number of checkpoints for `account`.
     */
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    /**
     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.
     */
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    /**
     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.
     * It is but NOT the sum of all the delegated votes!
     */
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     *      Copied from oz/ERC20Votes.sol
     */
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    /***************************************
                VIEWS - BALANCES
    ****************************************/

    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    // Balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    // Supply of all properly locked balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    // Supply of all properly locked balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    // Get an epoch index based on timestamp
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    /***************************************
                VIEWS - GENERAL
    ****************************************/

    // Number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /***************************************
                VIEWS - REWARDS
    ****************************************/

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    /***************************************
                REWARD FUNDING
    ****************************************/

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",7734.0,876.0,"[M-03] Improperly Skewed Governance Mechanism
The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances. As a result, governance percentage thresholds will be significantly affected and potentially unmet.

[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance
The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired.In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch.

[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848
Rewards distribution can be delayed/never distributed on the function `_rewardPerToken()`

[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.

[M-08] Locking up AURA Token does not increase voting power of individual
Per the documentation, AURA tokens can be locked in the AuraLocker to recieve vlAURA. vlAURA is voting power in the AURA ecosystem.
It is also possible for the users to delegate their voting power to a specific address by calling the `AuraLocker.delegate(address account)` function.
However, after users locked up their AURA tokens in exchange for vlAURA tokens, their voting power did not increase.

[M-10] Increase voting power by tokenizing the address that locks the token
Without restriction on the type of address that lock the token in function `_lock`, a bad actor could lock the token through the smart contract.

[M-14] Integer overflow will lock all rewards in AuraLocker
There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.",7.0,"pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}


contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    

    struct RewardData {
        
        uint32 periodFinish;
        
        uint32 lastUpdateTime;
        
        uint96 rewardRate;
        
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; 
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    

    
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    
    mapping(address => RewardData) public rewardData;
    
    mapping(address => mapping(address => bool)) public rewardDistributors;
    
    mapping(address => mapping(address => UserData)) public userData;
    
    uint256 public constant rewardsDuration = 86400 * 7;
    
    uint256 public constant lockDuration = rewardsDuration * 17;

    
    
    uint256 public lockedSupply;
    
    Epoch[] public epochs;
    
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    
    
    mapping(address => address) private _delegates;
    
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    
    
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    
    uint256 public constant denominator = 10000;
    
    address public immutable cvxcrvStaking;
    
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    
    bool public isShutdown = false;

    
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    

    
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    

    
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); 
        require(_delay >= 2, ""min delay""); 
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    

    
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        
        _lock(_account, _amount);
    }

    
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        
        _checkpointEpoch();

        
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        
        lockedSupply = lockedSupply.add(_amount);

        
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    
    function getReward(address _account) external {
        getReward(_account, false);
    }

    
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        
        
        if (epochs[epochindex - 1].date < currentEpoch) {
            
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        
        
        
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            
            locked = userBalance.locked;

            
            userBalance.nextUnlockIndex = length.to32();

            
            
            
            
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            
            
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                
                if (locks[i].unlockTime > expiryTime) break;

                
                locked = locked.add(locks[i].amount);

                
                
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                
                nextUnlockIndex++;
            }
            
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        
        if (reward > 0) {
            
            locked = locked.sub(reward.to112());

            
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    

    
    function delegate(address newDelegatee) external virtual nonReentrant {
        
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        
        
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                
                
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    

    
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        
        
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            
            
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    
                    break;
                }
            }
        }

        return amount;
    }

    
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    

    
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    

    
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        
        
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",6073.0,0,7,"### Vulnerabilities in the `AuraLocker` Smart Contract

1. **Delegate Balance Manipulation**  
    - Function: `delegate`  
    - If a user delegates their locked tokens too frequently or selects different delegatees repeatedly, it can cause unexpected changes in the delegate's voting power. This could be exploited for governance manipulation.

2. **Reentrancy Risks in Token Transfers**  
   - Contracts like `getReward`, `_processExpiredLocks`, `queueNewRewards`, and `notifyRewardAmount` involve token transfer calls with external contracts. Although `nonReentrant` protects against reentrancy, developers should ensure token contracts don't include unexpected hooks or callbacks that could bypass the reentrancy guard.

3. **Lack of Rate Limiting for Reward Changes**  
   - Function: `setKickIncentive`  
   - The `setKickIncentive` function allows the contract owner to change the kick incentive rate arbitrarily (provided it stays under the max limit). Rapid or continuous changes to rewards might be used to favor specific users or harm others.

4. **Reward Rate Underflow/Overflow**  
   - Functions: `_notifyReward` and `queueNewRewards`  
   - Calculation errors in `rewardRate` with `uint96` typecasting (especially when rewards are very high or timing mismatches occur) can create rounded or unexpected implications, leading to rewards not being distributed fairly.

5. **Expensive Iteration in Loops**  
   - Functions:  
        - `_processExpiredLocks`  
        - `balanceAtEpochOf`  
        - `lockedBalances`  
   - These functions use user-specific storage arrays (e.g., `userLocks`) or iterate across epochs. This can lead to gas exhaustion in scenarios where users have a large number of locks or extended epochs.

6. **Improper Shutdown Handling**  
   - Function: `emergencyWithdraw`  
   - The `emergencyWithdraw` call clears user balances but does not interact with the reward-related mappings (`userData`, `delegateeUnlocks`), potentially leaving rewards untidy or unclaimable.

7. **Orphaned Rewards and Excess Queuing**  
   - Functions: `_notifyReward`, `queueNewRewards`  
   - Rewards can be 'orphaned' if `queuedCvxCrvRewards` continues to grow indefinitely due to inefficient reward notifications. Further, conditions for ""queuedRatio"" and reward notifications might lead to stale or lagging rewards over time.

8. **No Control Over Locked Tokens' Lifecycle After Emergency Withdraw**  
   - Function: `emergencyWithdraw`  
   - After the withdraw, users can take their tokens entirely, disrupting contractual terms for the lock period. This undermines the locking philosophy and may affect the reward distributions.

9. **Owner Privileges Without Multisig Enforcement**  
   - Critical administrative functions, such as `addReward`, `shutdown`, and `recoverERC20`, lack multisig or timelock protection, giving the contract owner substantial direct control. This creates centralized risks.

10. **Delegation Epoch Handling**  
    - Function: `_checkpointDelegate`  
    - If a delegate has many pending unlocks or locks, the `delegateeUnlocks` updates could be costly due to repetitive epoch lookups, making the system vulnerable to gas inefficiency.

11. **Potential for Overwritten Reward Distributors**  
    - Function: `approveRewardDistributor`  
    - A previously approved reward distributor can later be changed or revoked by the owner, potentially affecting reward flows mid-operation.

12. **Potential Misuse of `recoverERC20`**  
    - A malicious or compromised owner could exploit the `recoverERC20` function to transfer non-staking and non-reward tokens from the contract arbitrarily, possibly stealing user funds sent by mistake to the contract.

13. **No Failsafe for Failed Token Transfers**  
   - Token transfers (e.g., through `safeTransfer` and `safeTransferFrom`) depend on the behavior of ERC-20 tokens. If a non-standard token doesn't properly return success or reverts, this could lead to unexpected failures or stuck states.

14. **Immutable Variables Not Fully Enforced**  
   - Variables such as `cvxCrv` and `cvxcrvStaking` are labeled `immutable`. However, their functionality dictates interaction with external systems, which might be upgraded or replaced, leading to unpredictable consequences.

15. **Math Vulnerabilities on Epoch Calculations**  
   - Function: `_checkpointsLookup`, `balanceAtEpochOf`, etc.  
   - Arithmetic calculations involving `rewardsDuration`, `lockDuration`, and timestamps might silently introduce off-by-one errors unless carefully checked. This could produce inconsistencies in accounting calculations or user balances.

16. **General Gas Inefficiency**  
   - Several functions (e.g., on delegation, epochs processing, and lock rewards) present significant gas costs because of their looped or iterative logic, which increases complexity.

-------

### Suggestions:
- Add safeguards and validation mechanisms for reward and locking operations.
- Limit iterations in loops to prevent reaching gas limits.
- Implement timelocks and introduce owner privileges with multisig controls.
- Ensure proper handling of orphaned or untidy data (e.g., leftover rewards during shutdown).
- Audit all math-related calculations to ensure consistent results, especially with large inputs.
- Use consistent gas-saving techniques (e.g., local variable caching in loops).","---

### **Analysis of Issues and Responses**

---

#### **[M-03] Improperly Skewed Governance Mechanism**

**Report Description**:  
The governance mechanism is flawed because the total supply of votes is tracked as the sum of all locked balances, but individual voting power only tracks delegated balances. This discrepancy can lead to governance percentage thresholds being unmet, potentially undermining the governance process.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The governance mechanism's improper balance tracking is a critical flaw that could lead to governance manipulation or failure to meet quorum requirements. This issue should be explicitly addressed by ensuring that the total voting power and individual voting power are consistently tracked and aligned.

**Suggestions**:  
- Implement a mechanism to ensure that the total voting power is accurately calculated, including both locked and delegated balances.
- Add tests to verify that governance thresholds are met under various scenarios.

---

#### **[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**

**Report Description**:  
The `_processExpiredLocks` function calculates the kick reward based only on the last locked amount, ignoring the user's entire balance. This could result in unfair or incorrect rewards for users.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. The calculation of kick rewards is a critical part of the contract's functionality, and failing to consider the entire balance could lead to user dissatisfaction and economic inefficiencies.

**Suggestions**:  
- Update the `_processExpiredLocks` function to calculate rewards based on the user's entire balance rather than just the last locked amount.
- Add unit tests to ensure the reward calculation is accurate for various scenarios.

---

#### **[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**

**Report Description**:  
The `_rewardPerToken()` function can cause delays or prevent rewards from being distributed due to potential logic or state issues.

**Match in Response List**:  
Matches with **""Orphaned Rewards and Excess Queuing""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of orphaned rewards and inefficiencies in reward notifications but does not explicitly address the specific problem in `_rewardPerToken()`. The response should include a detailed explanation of how to prevent delays or ensure timely reward distribution.

**Suggestions**:  
- Investigate the logic in `_rewardPerToken()` to identify and fix any conditions that could delay or block reward distribution.
- Add monitoring and alerting mechanisms to detect and resolve reward distribution delays.

---

#### **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**

**Report Description**:  
If a user does not claim their rewards for an extended period, the rewards may become locked due to the accumulation of epochs, forcing the platform to reimburse the user and causing economic losses.

**Match in Response List**:  
Matches with **""Expensive Iteration in Loops""**.

**Validation**:  
**Partially Correct**. The response mentions gas inefficiencies in loops but does not directly address the issue of rewards being locked due to unclaimed rewards over many epochs. The response should propose a solution to handle long-term unclaimed rewards.

**Suggestions**:  
- Implement a mechanism to consolidate or batch epochs for users with long-term unclaimed rewards to prevent locking.
- Introduce a fallback mechanism to allow users to claim rewards even after extended periods.

---

#### **[M-08] Locking up AURA Token does not increase voting power of individual**

**Report Description**:  
Users who lock AURA tokens in exchange for vlAURA tokens do not see an increase in their voting power, contrary to the expected behavior described in the documentation.

**Match in Response List**:  
Matches with **""Delegate Balance Manipulation""**.

**Validation**:  
**Partially Correct**. The response discusses potential manipulation of delegate balances but does not address the core issue of locked tokens not increasing voting power. This is a significant deviation from the expected functionality and should be explicitly resolved.

**Suggestions**:  
- Ensure that locking AURA tokens correctly increases the user's voting power as intended.
- Add tests to verify that voting power is updated accurately when tokens are locked.

---

#### **[M-10] Increase voting power by tokenizing the address that locks the token**

**Report Description**:  
Without restrictions on the type of address that can lock tokens, a malicious actor could lock tokens through a smart contract, potentially manipulating voting power.

**Match in Response List**:  
No match found.

**Validation**:  
**Missed Issue**. The response list does not address this issue. Allowing unrestricted addresses to lock tokens introduces a significant risk of governance manipulation.

**Suggestions**:  
- Restrict the types of addresses that can lock tokens to prevent abuse.
- Implement checks to ensure that only valid addresses (e.g., EOA or whitelisted contracts) can lock tokens.

---

#### **[M-14] Integer overflow will lock all rewards in AuraLocker**

**Report Description**:  
A potential overflow in the rewards calculations could cause the `updateReward()` function to always revert, effectively locking all rewards.

**Match in Response List**:  
Matches with **""Reward Rate Underflow/Overflow""**.

**Validation**:  
**Correct**. The response identifies the risk of overflow/underflow in reward calculations and suggests using proper typecasting and validation to prevent such issues. This aligns with Solidity best practices.

**Suggestions**:  
No additional suggestions. The response appropriately addresses the issue.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

1. **[R-01] Lack of Rate Limiting for Reward Changes**  
   - **Assessment**: Valid Concern. Arbitrary changes to the kick incentive rate could lead to unfair rewards or manipulation. Adding rate-limiting mechanisms would enhance fairness and security.

2. **[R-02] Owner Privileges Without Multisig Enforcement**  
   - **Assessment**: Valid Concern. Critical administrative functions should be protected by multisig or timelock mechanisms to reduce centralized risks.

3. **[R-03] No Failsafe for Failed Token Transfers**  
   - **Assessment**: Valid Concern. Ensuring proper handling of failed token transfers is essential to prevent stuck funds or unexpected failures.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-14] Integer overflow will lock all rewards in AuraLocker**

**Partially Correct Matches**:  
- **[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**  
- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**  
- **[M-08] Locking up AURA Token does not increase voting power of individual**

**Missed Issues from Issue Report**:  
- **[M-03] Improperly Skewed Governance Mechanism**  
- **[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**  
- **[M-10] Increase voting power by tokenizing the address that locks the token**

---",1,3,3,16,"```
1. Reward Rate Underflow/Overflow
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Reward Rate Underflow/Overflow"".
   - In the ranked list of predictions, ""Reward Rate Underflow/Overflow"" appears at rank **4**.

2. **Calculate the precision at rank 4 (\( P@4 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Up to rank 4, there is **1** true positive.
   - \( P@4 = \frac{1}{4} = 0.25 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.25 \).

**Output**:
```
0.25
```"
ConvexMasterChef.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";

/**
 * @title   ConvexMasterChef
 * @author  ConvexFinance
 * @notice  Masterchef can distribute rewards to n pools over x time
 * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,
 *          and thus it can over complicate the distribution of these rewards.
 *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed
 *          pro-rata based on the allocation points in each pool vs the total alloc.
 */
contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of CVXs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.
        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.
        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    //cvx
    IERC20 public immutable cvx;
    // CVX tokens created per block.
    uint256 public immutable rewardPerBlock;
    // Bonus muliplier for early cvx makers.
    uint256 public constant BONUS_MULTIPLIER = 2;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when CVX mining starts.
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    // Events
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    // Update the given pool's CVX allocation point. Can only be called by the owner.
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    // View function to see pending CVXs on frontend.
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        //cvx.mint(address(this), cvxReward);
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for CVX allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2667.0,308.0,"[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect
In the ConvexMasterChef contract, a new staking pool can be added using the `add()` function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the `_lpToken` is the same as the reward token (cvx) or not.

[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds
All calculations are rounded down, since a lack of tokens in the contracts cannot be rounding errors' fault. So the function is redundant.On the other hand, if the contract is undersupplied with cvx tokens, this will cause depositors to be sent less tokens than needed (or none). This is especially unsafe because the tokens that were lacking are not resembled in accountings at all. Thus a depositor may invoke the safeRewardTransfer and not receive tokens they were supposed to.

[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control
Reward token accounting update in `deposit()` and `withdraw()` happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.

[M-20] massUpdatePools() is susceptible to DoS with block gas limit
`massUpdatePools()` is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo.If poolInfo.length is big enough, block gas limit may be hit.

[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools

[M-22] Duplicate LP token could lead to incorrect reward distribution
It was observed that add function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with reward distribution",6.0,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";


contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    
    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    
    struct PoolInfo {
        IERC20 lpToken; 
        uint256 allocPoint; 
        uint256 lastRewardBlock; 
        uint256 accCvxPerShare; 
        IRewarder rewarder;
    }

    
    IERC20 public immutable cvx;
    
    uint256 public immutable rewardPerBlock;
    
    uint256 public constant BONUS_MULTIPLIER = 2;

    
    PoolInfo[] public poolInfo;
    
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    
    uint256 public totalAllocPoint = 0;
    
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    
    
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2047.0,0,6,"Below is a list of vulnerabilities and issues found in the given Solidity smart contract `ConvexMasterChef`. For clarity, these issues are categorized into security risks, potential optimization issues, and design flaws.

---

### **1. Security Risks**

#### **1.1. Integer Overflow/Underflow**
- While the contract uses `SafeMath` for arithmetic operations to prevent integer overflow or underflow in Solidity 0.6, it's worth noting that such protection is redundant starting with Solidity 0.8 because this feature is built-in to the compiler. However, this implementation might rely on `SafeMath` due to the 0.6.12 version, making this less critical but still redundant for future improvement.

#### **1.2. Reentrancy Risk**
- Functions like `deposit`, `withdraw`, `claim`, and `emergencyWithdraw` involve external contract calls (e.g., the `safeTransferFrom`, `safeTransfer`, and calls to the `rewarder` contract). External calls may introduce potential **reentrancy attacks**.
    For example:
    - The attacker might exploit reentrancy by calling `onReward` from the linked `IRewarder` contract.
- **Fix:** Wrap state changes (like updating `user.amount`, `user.rewardDebt`, etc.) before any external call or use the `ReentrancyGuard` from OpenZeppelin.

---

#### **1.3. Lack of Access Control on `claim`**
- The `claim` function allows any user to trigger a claim on behalf of `_account` by calling the function. This could allow someone to manipulate third-party reward delegation mechanisms, especially if `IRewarder.onReward` has significant behavioral effects.
- **Fix:** Require that only `_account` or an approved user be permitted to execute claims.

---

#### **1.4. Hardcoded `BONUS_MULTIPLIER`
- The `BONUS_MULTIPLIER` constant is set, but it's unused in the computation of rewards. This could cause confusion and lead developers/users to mistakenly assume it plays a part in block rewards.
- **Fix:** Either remove it if not intended for use or apply it judiciously in reward calculations.

---

#### **1.5. Centralization Risk**
- The owner of the contract has excess control, such as:
  - Adding or removing pools (`add` function).
  - Arbitrarily changing `allocPoint`, `rewarder`, and other parameters of existing pools (`set` function).
- This centralization could lead to abuse (e.g., redirecting rewards to the owner's preferred pools).
- **Fix:** Consider transferring ownership to a governance/DAO mechanism or restricting these permissions after deployment.

---

#### **1.6. No Cooldown Mechanism for Emergency Withdraw**
- The `emergencyWithdraw` function allows users to withdraw their LP tokens and reset their reward data immediately. Without any cooldown or penalty, this could be exploited to game the reward system:
  - A user could repeatedly deposit, earn rewards, and withdraw LP tokens in rapid cycles, particularly in flash loan attacks.
- **Fix:** Add a cooldown or time-lock mechanism. Alternatively, consider reverting calculated rewards for users who trigger an `emergencyWithdraw`.

---

### **2. Potential Optimization Issues**

#### **2.1. Inefficient `massUpdatePools` Implementation**
- The `massUpdatePools` function iterates through all pool indices (`poolInfo[]`) and updates rewards for each pool. This could cause significant gas costs in scenarios with a large number of pools.
- **Fix:** Reduce the need to call `massUpdatePools` frequently (e.g., optimize event-driven logic or avoid unnecessary calls in functions like `add`, `set`).

---

#### **2.2. Redundant .add() and .sub() Operations**
- Certain operations such as:
  ```solidity
  totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);
  ```
  First subtract and then add values back to `totalAllocPoint`. This might lead to slight gas inefficiency due to the extra operation.
- **Fix:** Combine these operations when possible for optimization, e.g.,:
  ```solidity
  totalAllocPoint = totalAllocPoint + _allocPoint - poolInfo[_pid].allocPoint;
  ```

---

#### **2.3. No Block Overflow Prevention**
- The `getMultiplier` function clamps `_from` and `_to` values by comparing with `endBlock`. However, it does not restrict `_to` or `_from` from being arbitrarily set by the caller, causing unnecessary gas usage in scenarios where `_from` and `_to` are misaligned.
- **Fix:** Validate `_to` and `_from` inputs (e.g., `_to > _from && _from >= startBlock`).

---

### **3. Design Flaws**

#### **3.1. Lack of Reward Redistribution**
- Rewards for unclaimed or zero-supply pools are effectively lost because no redistribution mechanism exists for unused CVX rewards, particularly in the absence of participants or usage.
- **Fix:** Consider redistributing unused rewards to active pools or retaining them for future purposes.

---

#### **3.2. No Pool Deletion Mechanism**
- The contract allows adding new pools but does not allow the removal of existing pools (`poolInfo` cannot be deleted). This might lead to orphan/unused pools accumulating over time.
- **Fix:** Implement a mechanism to ""retire"" or mark pools as inactive.

---

#### **3.3. Fixed Start and End Block Parameters**
- The `startBlock` and `endBlock` are immutable, leaving no room for adjustments if deployment or user activity does not align with estimated block times.
- **Fix:** Consider adding an emergency mechanism for updating `startBlock` or `endBlock`.

---

#### **3.4. Missing Reward Accounting for `safeRewardTransfer`**
- The `safeRewardTransfer` function sends rewards based on available CVX tokens in the current contract balance, which can lead to discrepancies if reward accounting is incomplete or misaligned.
- **Fix:** Record `cvx` allocations explicitly for each user and ensure accurate tracking of reward debts.

---

#### **3.5. Assumptions About Rewarder Interface**
- The contract makes assumptions about the external behavior of linked `rewarder` contracts (through `onReward`). If these contracts are insecure or behave unexpectedly, users could face financial loss or manipulation.
- **Fix:** Validate the integrity of external rewarders or enforce constraints (e.g., require the `rewarder` contract to implement `IRewarder` securely).

---

### Summary of Findings
1. **High Risk (Security) Issues**:
   - Reentrancy Risks.
   - Centralization of privileges.
   - Vulnerable `claim` implementation.
   - Emergency withdraw exploitability.
2. **Medium Risk (Optimization)**:
   - Inefficiencies in batch operations like `massUpdatePools`.
   - Unchecked `getMultiplier` inputs.
3. **Low Risk (Design Flaws)**:
   - Lack of reward redistribution, pool deletion, or flexibilities. 
   - Problematic reward mechanisms (`safeRewardTransfer`).

By addressing these issues, the contract can be made safer, more performant, and more developer- and user-friendly.","---

### **Analysis of Alignment Between `issue` and `response_list`**

---

#### **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**

**Report Description**:  
The `add()` function in the `ConvexMasterChef` contract allows adding a new staking pool with `_lpToken` as the staking token. However, there is no check to ensure `_lpToken` is not the same as the reward token (`cvx`). This could lead to incorrect reward calculations and potential logical errors in the contract.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The `response_list` does not address this issue. There is no mention of validating `_lpToken` to ensure it is not the same as the reward token (`cvx`). This is a critical logical error that could lead to incorrect reward distribution and should be explicitly addressed.

**Suggestions**:  
- Add a validation check in the `add()` function to ensure `_lpToken` is not equal to the reward token (`cvx`).
- Include a test case to verify that the contract reverts when attempting to add a pool with `_lpToken` set to `cvx`.

---

#### **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**

**Report Description**:  
The `safeRewardTransfer` function may cause depositors to receive fewer tokens than expected (or none) if the contract is undersupplied with `cvx` tokens. This is unsafe because the missing tokens are not accounted for, leading to discrepancies in reward distribution.

**Match in Response List**:  
Matches with **3.4. Missing Reward Accounting for `safeRewardTransfer`**.

**Validation**:  
**Correct.** The response identifies the issue with `safeRewardTransfer` and highlights the lack of proper reward accounting. It suggests explicitly recording `cvx` allocations for each user and ensuring accurate tracking of reward debts, which aligns with best practices.

**Suggestions**:  
- Implement a mechanism to track reward debts and ensure that any shortfall in `cvx` tokens is accounted for and resolved in future reward distributions.

---

#### **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**

**Report Description**:  
The `deposit()` and `withdraw()` functions update reward token accounting after transferring rewards. If the reward token allows transfer flow control (e.g., via hooks like `_beforeTokenTransfer` or `_afterTokenTransfer`), this could enable a reentrancy attack to drain all reward funds.

**Match in Response List**:  
Matches with **1.2. Reentrancy Risk**.

**Validation**:  
**Partially Correct.** The response identifies the general risk of reentrancy in functions like `deposit` and `withdraw` and suggests using `ReentrancyGuard` or updating state before external calls. However, it does not explicitly address the specific scenario of reward tokens with transfer flow control mechanisms (e.g., ERC777 hooks).

**Suggestions**:  
- Explicitly mention the risk of using reward tokens with hooks like `_beforeTokenTransfer` or `_afterTokenTransfer`.
- Add a recommendation to validate the behavior of reward tokens or restrict the use of tokens with such hooks.

---

#### **[M-20] `massUpdatePools()` is susceptible to DoS with block gas limit**

**Report Description**:  
The `massUpdatePools()` function iterates over all pools in `poolInfo[]` and updates their rewards. If the number of pools is large, the function could exceed the block gas limit, making it unusable.

**Match in Response List**:  
Matches with **2.1. Inefficient `massUpdatePools` Implementation**.

**Validation**:  
**Correct.** The response identifies the inefficiency of `massUpdatePools()` and suggests reducing the frequency of its calls or optimizing its logic. This aligns with best practices for gas optimization.

**Suggestions**:  
- Consider implementing a mechanism to update pools incrementally or in batches to avoid exceeding the block gas limit.

---

#### **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**

**Report Description**:  
The `add()` and `set()` functions do not call `massUpdatePools()` to update all pools. This could lead to outdated reward calculations and inconsistencies in the contract's state.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The `response_list` does not address this issue. Failing to call `massUpdatePools()` in `add()` and `set()` can lead to incorrect reward distributions and should be explicitly fixed.

**Suggestions**:  
- Modify the `add()` and `set()` functions to call `massUpdatePools()` before making changes to the pool configuration.

---

#### **[M-22] Duplicate LP token could lead to incorrect reward distribution**

**Report Description**:  
The `add()` function does not check for duplicate LP tokens, allowing multiple pools to use the same LP token. This could cause issues with reward distribution and accounting.

**Match in Response List**:  
**No match found.**

**Validation**:  
**Missed Issue.** The `response_list` does not address this issue. Allowing duplicate LP tokens is a significant design flaw that could lead to incorrect reward calculations and should be explicitly addressed.

**Suggestions**:  
- Add a check in the `add()` function to ensure that the LP token is not already used in another pool.
- Include a test case to verify that the contract reverts when attempting to add a pool with a duplicate LP token.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Lack of Reward Redistribution**
**Response Description**:  
The response highlights that unused rewards for inactive or zero-supply pools are effectively lost, as there is no mechanism to redistribute them to active pools.

**Assessment**:  
**Valid Concern.** While this issue was not mentioned in the original `issue` report, it is a valid design flaw. Redistributing unused rewards to active pools or retaining them for future use would improve the contract's efficiency and fairness.

---

#### **[R-02] No Pool Deletion Mechanism**
**Response Description**:  
The response notes that the contract does not allow the removal of pools, which could lead to the accumulation of orphan/unused pools over time.

**Assessment**:  
**Valid Concern.** While this issue was not mentioned in the original `issue` report, it is a valid design flaw. Implementing a mechanism to retire or deactivate pools would improve the contract's maintainability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-15] `safeRewardTransfer` can cause loss of funds**  
- **[M-20] `massUpdatePools()` is susceptible to DoS with block gas limit**

**Partially Correct Matches**:  
- **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**

**Missed Issues from Issue Report**:  
- **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**  
- **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**  
- **[M-22] Duplicate LP token could lead to incorrect reward distribution**

**GPT-Generated Potential Issues (May Be Incorrect)**:  
- **[R-01] Lack of Reward Redistribution**  
- **[R-02] No Pool Deletion Mechanism**

---",2,1,3,14,"```
1. 3.4. Missing Reward Accounting for `safeRewardTransfer`
2. 2.1. Inefficient `massUpdatePools` Implementation
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **True Positive 1**: ""3.4. Missing Reward Accounting for `safeRewardTransfer`"" appears at rank **14**.
   - **True Positive 2**: ""2.1. Inefficient `massUpdatePools` Implementation"" appears at rank **7**.

2. **Calculate the precision at each rank where a true positive appears**:
   - **Precision at rank 7 (P@7)**: Number of true positives up to rank 7 is **1** (only ""2.1. Inefficient `massUpdatePools` Implementation"").
     \[
     P@7 = \frac{1}{7} \approx 0.1429
     \]
   - **Precision at rank 14 (P@14)**: Number of true positives up to rank 14 is **2** (both ""2.1. Inefficient `massUpdatePools` Implementation"" and ""3.4. Missing Reward Accounting for `safeRewardTransfer`"").
     \[
     P@14 = \frac{2}{14} \approx 0.1429
     \]

3. **Compute the Average Precision (AP)**:
   \[
   AP = \frac{P@7 + P@14}{2} = \frac{0.1429 + 0.1429}{2} = 0.1429
   \]

**Output**:
\[
0.1429
\]"
,,,,,,,,1,16,,,3,8,6,41,,
