nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
AxelarGateway.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';
import { IERC20 } from './interfaces/IERC20.sol';
import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { AdminMultisigBase } from './AdminMultisigBase.sol';
import { TokenDeployer } from './TokenDeployer.sol';

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    error NotSelf();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAmount();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error TokenIsFrozen(string symbol);

    enum Role {
        Admin,
        Owner,
        Operator
    }

    enum TokenType {
        InternalBurnable,
        InternalBurnableFrom,
        External
    }

    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    // AUDIT: slot names should be prefixed with some standard string
    // AUDIT: constants should be literal and their derivation should be in comments
    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;

    constructor(address tokenDeployerImplementation) {
        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;
    }

    modifier onlySelf() {
        if (msg.sender != address(this)) revert NotSelf();

        _;
    }

    /******************\
    |* Public Methods *|
    \******************/

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);
    }

    function callContract(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }

    function callContractWithToken(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit ContractCallWithToken(
            msg.sender,
            destinationChain,
            destinationContractAddress,
            keccak256(payload),
            payload,
            symbol,
            amount
        );
    }

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        return
            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view override returns (bool) {
        return
            getBool(
                _getIsContractCallApprovedWithMintKey(
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = getBool(key);
        if (valid) _setBool(key, false);
    }

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedWithMintKey(
            commandId,
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            symbol,
            amount
        );
        valid = getBool(key);
        if (valid) {
            _setBool(key, false);
            _mintToken(symbol, msg.sender, amount);
        }
    }

    /***********\
    |* Getters *|
    \***********/

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    /// @dev Returns the current `adminEpoch`.
    function adminEpoch() external view override returns (uint256) {
        return _adminEpoch();
    }

    /// @dev Returns the admin threshold for a given `adminEpoch`.
    function adminThreshold(uint256 epoch) external view override returns (uint256) {
        return _getAdminThreshold(epoch);
    }

    /// @dev Returns the array of admins within a given `adminEpoch`.
    function admins(uint256 epoch) external view override returns (address[] memory results) {
        uint256 adminCount = _getAdminCount(epoch);
        results = new address[](adminCount);

        for (uint256 i; i < adminCount; i++) {
            results[i] = _getAdmin(epoch, i);
        }
    }

    /*******************\
    |* Admin Functions *|
    \*******************/

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external override onlyAdmin {
        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();

        emit Upgraded(newImplementation);

        // AUDIT: If `newImplementation.setup` performs `selfdestruct`, it will result in the loss of _this_ implementation (thereby losing the gateway)
        //        if `upgrade` is entered within the context of _this_ implementation itself.
        if (setupParams.length > 0) {
            (bool success, ) = newImplementation.delegatecall(
                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
            );

            if (!success) revert SetupFailed();
        }

        _setImplementation(newImplementation);
    }

    /**********************\
    |* Internal Functions *|
    \**********************/

    function _burnTokenFrom(
        address sender,
        string memory symbol,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);
        if (amount == 0) revert InvalidAmount();

        TokenType tokenType = _getTokenType(symbol);
        bool burnSuccess;

        if (tokenType == TokenType.External) {
            _checkTokenStatus(symbol);

            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        if (tokenType == TokenType.InternalBurnableFrom) {
            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        burnSuccess = _callERC20Token(
            tokenAddress,
            abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                sender,
                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),
                amount
            )
        );

        if (!burnSuccess) revert BurnFailed(symbol);

        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));
    }

    function _deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        address tokenAddress
    ) internal {
        // Ensure that this symbol has not been taken.
        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);

        if (tokenAddress == address(0)) {
            // If token address is no specified, it indicates a request to deploy one.
            bytes32 salt = keccak256(abi.encodePacked(symbol));

            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(
                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)
            );

            if (!success) revert TokenDeployFailed(symbol);

            tokenAddress = abi.decode(data, (address));

            _setTokenType(symbol, TokenType.InternalBurnableFrom);
        } else {
            // If token address is specified, ensure that there is a contact at the specified addressed.
            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);

            // Mark that this symbol is an external token, which is needed to differentiate between operations on mint and burn.
            _setTokenType(symbol, TokenType.External);
        }

        _setTokenAddress(symbol, tokenAddress);

        emit TokenDeployed(symbol, tokenAddress);
    }

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            bool success = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)
            );

            if (!success) revert MintFailed(symbol);
        } else {
            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);
        }
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            DepositHandler depositHandler = new DepositHandler{ salt: salt }();

            (bool success, bytes memory returnData) = depositHandler.execute(
                tokenAddress,
                abi.encodeWithSelector(
                    IERC20.transfer.selector,
                    address(this),
                    IERC20(tokenAddress).balanceOf(address(depositHandler))
                )
            );

            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))
                revert BurnFailed(symbol);

            depositHandler.destroy(address(this));
        } else {
            BurnableMintableCappedERC20(tokenAddress).burn(salt);
        }
    }

    function _approveContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        emit ContractCallApproved(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function _approveContractCallWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount
        );
        emit ContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    /********************\
    |* Pure Key Getters *|
    \********************/

    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));
    }

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    function _getIsContractCallApprovedKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash
                )
            );
    }

    function _getIsContractCallApprovedWithMintKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    /********************\
    |* Internal Methods *|
    \********************/

    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {
        (bool success, bytes memory returnData) = tokenAddress.call(callData);
        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));
    }

    /********************\
    |* Internal Getters *|
    \********************/

    function _getTokenType(string memory symbol) internal view returns (TokenType) {
        return TokenType(getUint(_getTokenTypeKey(symbol)));
    }

    function _checkTokenStatus(string memory symbol) internal view {
        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);
    }

    /********************\
    |* Internal Setters *|
    \********************/

    function _setTokenType(string memory symbol, TokenType tokenType) internal {
        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));
    }

    function _setTokenAddress(string memory symbol, address tokenAddress) internal {
        _setAddress(_getTokenAddressKey(symbol), tokenAddress);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    function _setContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal {
        _setBool(
            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),
            true
        );
    }

    function _setContractCallApprovedWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal {
        _setBool(
            _getIsContractCallApprovedWithMintKey(
                commandId,
                sourceChain,
                sourceAddress,
                contractAddress,
                payloadHash,
                symbol,
                amount
            ),
            true
        );
    }

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}",4083,617,"[H-01] Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded
Smart contract calls often revert. In such cases any ether sent along with the transaction is returned and sometimes the remaining gas
For contracts involving ERC20 tokens it is also expected that, should a contract call fail, one's tokens are not lost/transferred elsewhere.
The `callContractWithToken` function does not appear to take contract call failure on the destination chain into account, even though this could be quite a common occurrence.
  [M-01] Low level call returns true if the address doesn't exist
As written in the solidity documentation, the low-level functions `call`, `delegatecall` and `staticcall` return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.
  [M-02] User's funds can get lost when transferring to other chain
When transferring tokens to other chain, the tokens in the source chain are burned - if they are external they will be transferred to the AxelarGateway, otherwise they will be burned. In the target chain the same amount of tokens will be minted for the user - if it is external it will be transferred to him from the AxelarGateway, otherwise it will be minted to him. But there is a problem - if the AxelarGateway doesn't have the needed amount of token for some reason, the `_callERC20Token` with the `transfer` function selector will fail and return false, which will make the `_mintToken` function revert. Because it reverted, the user won't get his funds on the destination chain, although he payed the needed amount in the source chain.
  [M-04] Unsupported fee-on-transfer tokens
When tokenAddress is fee-on-transfer tokens, in the `_burnTokenFrom` function, the actual amount of tokens received by the contract will be less than the amount.",4,"pragma solidity 0.8.9;

import { IAxelarGateway } from './interfaces/IAxelarGateway.sol';
import { IERC20 } from './interfaces/IERC20.sol';
import { IERC20BurnFrom } from './interfaces/IERC20BurnFrom.sol';

import { BurnableMintableCappedERC20 } from './BurnableMintableCappedERC20.sol';
import { DepositHandler } from './DepositHandler.sol';
import { AdminMultisigBase } from './AdminMultisigBase.sol';
import { TokenDeployer } from './TokenDeployer.sol';

abstract contract AxelarGateway is IAxelarGateway, AdminMultisigBase {
    error NotSelf();
    error InvalidCodeHash();
    error SetupFailed();
    error InvalidAmount();
    error TokenDoesNotExist(string symbol);
    error TokenAlreadyExists(string symbol);
    error TokenDeployFailed(string symbol);
    error TokenContractDoesNotExist(address token);
    error BurnFailed(string symbol);
    error MintFailed(string symbol);
    error TokenIsFrozen(string symbol);

    enum Role {
        Admin,
        Owner,
        Operator
    }

    enum TokenType {
        InternalBurnable,
        InternalBurnableFrom,
        External
    }

    
    bytes32 internal constant KEY_IMPLEMENTATION =
        bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);

    
    
    bytes32 internal constant KEY_ALL_TOKENS_FROZEN = keccak256('all-tokens-frozen');

    bytes32 internal constant PREFIX_COMMAND_EXECUTED = keccak256('command-executed');
    bytes32 internal constant PREFIX_TOKEN_ADDRESS = keccak256('token-address');
    bytes32 internal constant PREFIX_TOKEN_TYPE = keccak256('token-type');
    bytes32 internal constant PREFIX_TOKEN_FROZEN = keccak256('token-frozen');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED = keccak256('contract-call-approved');
    bytes32 internal constant PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT = keccak256('contract-call-approved-with-mint');

    bytes32 internal constant SELECTOR_BURN_TOKEN = keccak256('burnToken');
    bytes32 internal constant SELECTOR_DEPLOY_TOKEN = keccak256('deployToken');
    bytes32 internal constant SELECTOR_MINT_TOKEN = keccak256('mintToken');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL = keccak256('approveContractCall');
    bytes32 internal constant SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT = keccak256('approveContractCallWithMint');
    bytes32 internal constant SELECTOR_TRANSFER_OPERATORSHIP = keccak256('transferOperatorship');
    bytes32 internal constant SELECTOR_TRANSFER_OWNERSHIP = keccak256('transferOwnership');

    uint8 internal constant OLD_KEY_RETENTION = 16;

    address internal immutable TOKEN_DEPLOYER_IMPLEMENTATION;

    constructor(address tokenDeployerImplementation) {
        TOKEN_DEPLOYER_IMPLEMENTATION = tokenDeployerImplementation;
    }

    modifier onlySelf() {
        if (msg.sender != address(this)) revert NotSelf();

        _;
    }

    

    function sendToken(
        string memory destinationChain,
        string memory destinationAddress,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit TokenSent(msg.sender, destinationChain, destinationAddress, symbol, amount);
    }

    function callContract(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload
    ) external {
        emit ContractCall(msg.sender, destinationChain, destinationContractAddress, keccak256(payload), payload);
    }

    function callContractWithToken(
        string memory destinationChain,
        string memory destinationContractAddress,
        bytes memory payload,
        string memory symbol,
        uint256 amount
    ) external {
        _burnTokenFrom(msg.sender, symbol, amount);
        emit ContractCallWithToken(
            msg.sender,
            destinationChain,
            destinationContractAddress,
            keccak256(payload),
            payload,
            symbol,
            amount
        );
    }

    function isContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) external view override returns (bool) {
        return
            getBool(_getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash));
    }

    function isContractCallAndMintApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external view override returns (bool) {
        return
            getBool(
                _getIsContractCallApprovedWithMintKey(
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    function validateContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, msg.sender, payloadHash);
        valid = getBool(key);
        if (valid) _setBool(key, false);
    }

    function validateContractCallAndMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) external override returns (bool valid) {
        bytes32 key = _getIsContractCallApprovedWithMintKey(
            commandId,
            sourceChain,
            sourceAddress,
            msg.sender,
            payloadHash,
            symbol,
            amount
        );
        valid = getBool(key);
        if (valid) {
            _setBool(key, false);
            _mintToken(symbol, msg.sender, amount);
        }
    }

    

    function allTokensFrozen() public view override returns (bool) {
        return getBool(KEY_ALL_TOKENS_FROZEN);
    }

    function implementation() public view override returns (address) {
        return getAddress(KEY_IMPLEMENTATION);
    }

    function tokenAddresses(string memory symbol) public view override returns (address) {
        return getAddress(_getTokenAddressKey(symbol));
    }

    function tokenFrozen(string memory symbol) public view override returns (bool) {
        return getBool(_getFreezeTokenKey(symbol));
    }

    function isCommandExecuted(bytes32 commandId) public view override returns (bool) {
        return getBool(_getIsCommandExecutedKey(commandId));
    }

    
    function adminEpoch() external view override returns (uint256) {
        return _adminEpoch();
    }

    
    function adminThreshold(uint256 epoch) external view override returns (uint256) {
        return _getAdminThreshold(epoch);
    }

    
    function admins(uint256 epoch) external view override returns (address[] memory results) {
        uint256 adminCount = _getAdminCount(epoch);
        results = new address[](adminCount);

        for (uint256 i; i < adminCount; i++) {
            results[i] = _getAdmin(epoch, i);
        }
    }

    

    function freezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), true);

        emit TokenFrozen(symbol);
    }

    function unfreezeToken(string memory symbol) external override onlyAdmin {
        _setBool(_getFreezeTokenKey(symbol), false);

        emit TokenUnfrozen(symbol);
    }

    function freezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, true);

        emit AllTokensFrozen();
    }

    function unfreezeAllTokens() external override onlyAdmin {
        _setBool(KEY_ALL_TOKENS_FROZEN, false);

        emit AllTokensUnfrozen();
    }

    function upgrade(
        address newImplementation,
        bytes32 newImplementationCodeHash,
        bytes calldata setupParams
    ) external override onlyAdmin {
        if (newImplementationCodeHash != newImplementation.codehash) revert InvalidCodeHash();

        emit Upgraded(newImplementation);

        
        
        if (setupParams.length > 0) {
            (bool success, ) = newImplementation.delegatecall(
                abi.encodeWithSelector(IAxelarGateway.setup.selector, setupParams)
            );

            if (!success) revert SetupFailed();
        }

        _setImplementation(newImplementation);
    }

    

    function _burnTokenFrom(
        address sender,
        string memory symbol,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);
        if (amount == 0) revert InvalidAmount();

        TokenType tokenType = _getTokenType(symbol);
        bool burnSuccess;

        if (tokenType == TokenType.External) {
            _checkTokenStatus(symbol);

            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transferFrom.selector, sender, address(this), amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        if (tokenType == TokenType.InternalBurnableFrom) {
            burnSuccess = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20BurnFrom.burnFrom.selector, sender, amount)
            );

            if (!burnSuccess) revert BurnFailed(symbol);

            return;
        }

        burnSuccess = _callERC20Token(
            tokenAddress,
            abi.encodeWithSelector(
                IERC20.transferFrom.selector,
                sender,
                BurnableMintableCappedERC20(tokenAddress).depositAddress(bytes32(0)),
                amount
            )
        );

        if (!burnSuccess) revert BurnFailed(symbol);

        BurnableMintableCappedERC20(tokenAddress).burn(bytes32(0));
    }

    function _deployToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 cap,
        address tokenAddress
    ) internal {
        
        if (tokenAddresses(symbol) != address(0)) revert TokenAlreadyExists(symbol);

        if (tokenAddress == address(0)) {
            
            bytes32 salt = keccak256(abi.encodePacked(symbol));

            (bool success, bytes memory data) = TOKEN_DEPLOYER_IMPLEMENTATION.delegatecall(
                abi.encodeWithSelector(TokenDeployer.deployToken.selector, name, symbol, decimals, cap, salt)
            );

            if (!success) revert TokenDeployFailed(symbol);

            tokenAddress = abi.decode(data, (address));

            _setTokenType(symbol, TokenType.InternalBurnableFrom);
        } else {
            
            if (tokenAddress.code.length == uint256(0)) revert TokenContractDoesNotExist(tokenAddress);

            
            _setTokenType(symbol, TokenType.External);
        }

        _setTokenAddress(symbol, tokenAddress);

        emit TokenDeployed(symbol, tokenAddress);
    }

    function _mintToken(
        string memory symbol,
        address account,
        uint256 amount
    ) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            bool success = _callERC20Token(
                tokenAddress,
                abi.encodeWithSelector(IERC20.transfer.selector, account, amount)
            );

            if (!success) revert MintFailed(symbol);
        } else {
            BurnableMintableCappedERC20(tokenAddress).mint(account, amount);
        }
    }

    function _burnToken(string memory symbol, bytes32 salt) internal {
        address tokenAddress = tokenAddresses(symbol);

        if (tokenAddress == address(0)) revert TokenDoesNotExist(symbol);

        if (_getTokenType(symbol) == TokenType.External) {
            _checkTokenStatus(symbol);

            DepositHandler depositHandler = new DepositHandler{ salt: salt }();

            (bool success, bytes memory returnData) = depositHandler.execute(
                tokenAddress,
                abi.encodeWithSelector(
                    IERC20.transfer.selector,
                    address(this),
                    IERC20(tokenAddress).balanceOf(address(depositHandler))
                )
            );

            if (!success || (returnData.length != uint256(0) && !abi.decode(returnData, (bool))))
                revert BurnFailed(symbol);

            depositHandler.destroy(address(this));
        } else {
            BurnableMintableCappedERC20(tokenAddress).burn(salt);
        }
    }

    function _approveContractCall(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApproved(commandId, sourceChain, sourceAddress, contractAddress, payloadHash);
        emit ContractCallApproved(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            sourceTxHash,
            sourceEventIndex
        );
    }

    function _approveContractCallWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount,
        bytes32 sourceTxHash,
        uint256 sourceEventIndex
    ) internal {
        _setContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount
        );
        emit ContractCallApprovedWithMint(
            commandId,
            sourceChain,
            sourceAddress,
            contractAddress,
            payloadHash,
            symbol,
            amount,
            sourceTxHash,
            sourceEventIndex
        );
    }

    

    function _getTokenTypeKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_TYPE, symbol));
    }

    function _getFreezeTokenKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_FROZEN, symbol));
    }

    function _getTokenAddressKey(string memory symbol) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_TOKEN_ADDRESS, symbol));
    }

    function _getIsCommandExecutedKey(bytes32 commandId) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(PREFIX_COMMAND_EXECUTED, commandId));
    }

    function _getIsContractCallApprovedKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash
                )
            );
    }

    function _getIsContractCallApprovedWithMintKey(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    PREFIX_CONTRACT_CALL_APPROVED_WITH_MINT,
                    commandId,
                    sourceChain,
                    sourceAddress,
                    contractAddress,
                    payloadHash,
                    symbol,
                    amount
                )
            );
    }

    

    function _callERC20Token(address tokenAddress, bytes memory callData) internal returns (bool) {
        (bool success, bytes memory returnData) = tokenAddress.call(callData);
        return success && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));
    }

    

    function _getTokenType(string memory symbol) internal view returns (TokenType) {
        return TokenType(getUint(_getTokenTypeKey(symbol)));
    }

    function _checkTokenStatus(string memory symbol) internal view {
        if (getBool(_getFreezeTokenKey(symbol)) || getBool(KEY_ALL_TOKENS_FROZEN)) revert TokenIsFrozen(symbol);
    }

    

    function _setTokenType(string memory symbol, TokenType tokenType) internal {
        _setUint(_getTokenTypeKey(symbol), uint256(tokenType));
    }

    function _setTokenAddress(string memory symbol, address tokenAddress) internal {
        _setAddress(_getTokenAddressKey(symbol), tokenAddress);
    }

    function _setCommandExecuted(bytes32 commandId, bool executed) internal {
        _setBool(_getIsCommandExecutedKey(commandId), executed);
    }

    function _setContractCallApproved(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash
    ) internal {
        _setBool(
            _getIsContractCallApprovedKey(commandId, sourceChain, sourceAddress, contractAddress, payloadHash),
            true
        );
    }

    function _setContractCallApprovedWithMint(
        bytes32 commandId,
        string memory sourceChain,
        string memory sourceAddress,
        address contractAddress,
        bytes32 payloadHash,
        string memory symbol,
        uint256 amount
    ) internal {
        _setBool(
            _getIsContractCallApprovedWithMintKey(
                commandId,
                sourceChain,
                sourceAddress,
                contractAddress,
                payloadHash,
                symbol,
                amount
            ),
            true
        );
    }

    function _setImplementation(address newImplementation) internal {
        _setAddress(KEY_IMPLEMENTATION, newImplementation);
    }
}",3738,1,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unsafe Delegatecall in Token Deployment**  
   The `_deployToken` function uses `delegatecall` to the `TOKEN_DEPLOYER_IMPLEMENTATION` contract. This allows the token deployer to modify the AxelarGateway's storage, risking storage corruption or unintended state changes if the deployer's code writes to storage slots used by the gateway.

2. **Incorrect Handling of Non-Compliant ERC20 Tokens**  
   The `_callERC20Token` function improperly handles tokens that do not return boolean values (e.g., legacy ERC20s). Calls to non-compliant tokens may incorrectly revert with `BurnFailed`/`MintFailed` errors even if the operation succeeds, leading to denial of service for valid transactions.

3. **Reentrancy Risk During External Token Interactions**  
   External token transfers (e.g., `transferFrom` in `_burnTokenFrom`) are performed before state updates. If a malicious token re-enters the gateway during these calls, it could exploit inconsistent states, though mitigations exist in some functions.

4. **DepositHandler Salt Predictability**  
   The `_burnToken` function creates a `DepositHandler` contract using a user-provided `salt`. Predictable salts could allow attackers to front-run or interfere with burn operations, though impact depends on salt derivation.

5. **Token Type Configuration Risks**  
   Admins can misconfigure token types (e.g., labeling an incompatible token as `External`). This may cause failures in functions expecting specific interfaces, leading to operational failures.

6. **Lack of ERC20 Compliance Checks**  
   Adding external tokens does not verify compliance with expected ERC20 standards. Non-standard behaviors (e.g., missing return values) can cause unexpected reverts or failures in token operations.

7. **Upgrade Function Trusts Admin-Controlled Inputs**  
   While the `upgrade` function checks the code hash, it delegates a `setupParams` call to the new implementation. A malicious admin could exploit this to execute arbitrary code during upgrades.","### **Output**

---

#### **[H-01] Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded**

**Report Description**:  
The `callContractWithToken` function does not account for contract call failures on the destination chain. If a call fails, the tokens burned on the source chain are not refunded, leading to potential loss of user funds. This is particularly problematic for cross-chain operations where failures are common.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unrefunded tokens in cross-chain operations. This is a critical oversight, as it directly impacts user funds and cross-chain functionality.

---

#### **[M-01] Low level call returns true if the address doesn't exist**

**Report Description**:  
Low-level calls (`call`, `delegatecall`, `staticcall`) return `true` even if the target address does not exist, as per the EVM design. This behavior can lead to misleading results if account existence is not checked prior to making the call.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of low-level calls returning `true` for non-existent addresses. This is a known Solidity behavior that should be explicitly handled to avoid unintended consequences.

---

#### **[M-02] User's funds can get lost when transferring to other chain**

**Report Description**:  
When transferring tokens to another chain, tokens are burned on the source chain and minted on the destination chain. However, if the `AxelarGateway` lacks the required tokens, the `_callERC20Token` function fails, causing the `_mintToken` function to revert. This results in the user losing funds on the destination chain despite paying on the source chain.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of lost funds due to insufficient tokens in the `AxelarGateway`. This is a significant risk for cross-chain token transfers.

---

#### **[M-04] Unsupported fee-on-transfer tokens**

**Report Description**:  
The `_burnTokenFrom` function does not account for fee-on-transfer tokens, where the actual amount received by the contract is less than the specified amount. This discrepancy can lead to incorrect token balances and operational failures.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens. This is a common problem in ERC20 token interactions and should be explicitly handled.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Cross-chain smart contract calls can revert but source chain tokens remain burnt and are not refunded**  
- **[M-01] Low level call returns true if the address doesn't exist**  
- **[M-02] User's funds can get lost when transferring to other chain**  
- **[M-04] Unsupported fee-on-transfer tokens**

---

### **Conclusion**  
The `response_list` does not adequately address the issues identified in the `issue` report. Critical vulnerabilities related to cross-chain token transfers, low-level calls, and fee-on-transfer tokens are entirely missed. The responses focus on other areas (e.g., `delegatecall` risks, ERC20 compliance) but fail to cover the specific risks and impacts outlined in the `issue` report. This highlights significant gaps in the response list's coverage and accuracy.",0,0,4,7,"Okay, let me try to figure out the vulnerabilities in this smart contract. I'm a bit new to this, so I'll start by reading through the code carefully and looking for common issues.

First, the contract is an AxelarGateway, which seems to handle cross-chain operations, token deployments, burns, mints, etc. Let me check for reentrancy issues. The functions use call to interact with ERC20 tokens. Wait, in the _callERC20Token function, they make a call to an external token contract. Since they're using .call() without a gas limit, but since this is Solidity 0.8.9, maybe that's okay. But if the token is malicious, could a reentrancy attack happen here? Let's see. For example, when burning tokens via transferFrom, if the token's transferFrom function calls back into the AxelarGateway, could that cause a reentrancy? The functions that call _callERC20Token are _burnTokenFrom and _mintToken. Let's see what state changes happen after the call. In _burnTokenFrom, after the call, there's a return. So if the token reenters, maybe some state isn't updated yet. But since this is a burn operation, maybe it's possible. But I'm not sure. Maybe this is a potential reentrancy vulnerability?

Next, access control. The contract uses a modifier onlyAdmin. So functions like freezeToken, unfreezeToken, upgrade, etc., are only callable by admins. But are there any functions that should have more restrictions? For example, the sendToken and callContract functions are external and can be called by anyone. That's intended, I think, since users can send tokens. But maybe if there's a way to bypass certain checks? Let me check.

Another thing is the use of delegatecall in the upgrade function. They delegatecall to the newImplementation's setup function. Since delegatecall runs the code in the context of the current contract, if the setupParams can be manipulated, maybe an admin could execute arbitrary code. But since it's onlyAdmin, maybe that's a privilege escalation if a compromised admin upgrades to a malicious contract. But that's more of an admin trust issue, not a code vulnerability.

Looking at token deployment. In _deployToken, if an external token is added (tokenAddress != 0), they check if the code exists. But what if the token is a contract that doesn't implement the required interface? Like, if someone adds a malicious token that doesn't have transferFrom or burn functions, then calls to burn or mint might fail. For example, when burning an external token, they call transferFrom to move tokens to the gateway, but if the token doesn't return a boolean, the call could fail. Wait, the _callERC20Token function checks if the call returns success and if the return data is either empty or true. But if the token doesn't return a value (like old ERC20s), then abi.decode might fail. For example, if a token uses an older version without returning a bool, the abi.decode(returnData, (bool)) would revert, causing the whole transaction to revert. But in Solidity 0.8.9, when you call a function that doesn't return anything but you try to decode it as a bool, that would cause an error. So if an external token is not compliant with the expected ERC20 (like missing return values), then the _callERC20Token would return false, leading to BurnFailed or MintFailed errors. But since the contract allows admins to add external tokens, this could be a vulnerability if admins add non-compliant tokens. However, that's more of an admin mistake than a code flaw. But maybe the contract should ensure that the external token is compliant. But the code currently only checks if the token address has code.

Another thing: when deploying a new token, they use delegatecall to TOKEN_DEPLOYER_IMPLEMENTATION. The TokenDeployer's deployToken function is called via delegatecall. Since delegatecall uses the storage of the caller (AxelarGateway), this might mess up the storage variables if the TokenDeployer modifies any. Wait, but the TokenDeployer is a separate contract. Let me see. The AxelarGateway's constructor sets TOKEN_DEPLOYER_IMPLEMENTATION as immutable. Then, in _deployToken, when tokenAddress is 0, they do a delegatecall to TOKEN_DEPLOYER_IMPLEMENTATION's deployToken function. The deployToken function in TokenDeployer would create a new BurnableMintableCappedERC20 token. But since this is done via delegatecall, the code execution happens in the context of AxelarGateway, which could potentially modify its storage. However, the TokenDeployer's deployToken function is supposed to deploy a new token contract. Let me check the code of BurnableMintableCappedERC20 and TokenDeployer. If the TokenDeployer's deployToken function uses CREATE2 or something, maybe the delegatecall is intended. Wait, using delegatecall here would mean that the deployToken function is executed in the context of AxelarGateway, which might not be correct. Wait, no: when you do a delegatecall, the code at TOKEN_DEPLOYER_IMPLEMENTATION is executed but the storage is AxelarGateway's. So if the deployToken function writes to storage, it would modify AxelarGateway's storage variables, which is not intended. But looking at the code, the TokenDeployer's deployToken function is supposed to deploy a new token contract, which is done via new BurnableMintableCappedERC20(...). The new keyword deploys a new contract, so that part should be okay. However, using delegatecall here might be risky. Wait, when you do a delegatecall, the new contract creation (new BurnableMintableCappedERC20) would deploy the token contract using AxelarGateway's storage? No, the new keyword in the context of delegatecall would create a contract using the TokenDeployer's code, but in the context of AxelarGateway's address? Or does the new keyword deploy the contract as per the code of TokenDeployer? I'm a bit confused here. Wait, no: when you make a delegatecall to TokenDeployer's deployToken, the code from TokenDeployer is executed in the context of AxelarGateway. So the new BurnableMintableCappedERC20 would be deployed by AxelarGateway's address as the deployer. But the code for BurnableMintableCappedERC20 would be its own code. So maybe this is okay, but using delegatecall for a function that deploys a contract might not be the standard approach. Maybe there's a vulnerability here if the TokenDeployer's code has any side effects on AxelarGateway's storage. Since AxelarGateway's _deployToken function uses delegatecall to TokenDeployer, any state changes in TokenDeployer's deployToken would affect AxelarGateway's storage. If the TokenDeployer's deployToken function modifies any storage variables, they would be written to AxelarGateway's storage. That's a problem. So if TokenDeployer has any state variables, their deployToken function could overwrite AxelarGateway's variables. Since TokenDeployer is a separate contract, maybe it's supposed to be stateless. But this is a potential vulnerability if the TokenDeployer's code isn't properly reviewed. However, since TOKEN_DEPLOYER_IMPLEMENTATION is set in the constructor and is immutable, maybe it's a trusted contract. But if an attacker can somehow change the TokenDeployer implementation, that could be an issue. But since it's immutable, once set in the constructor, it can't be changed. So maybe this is safe, but it's a risky pattern.

Another area is the use of arbitrary external calls. For example, when minting external tokens, the gateway calls transfer on the token. If the token is malicious, it could do something unexpected. But since admins are trusted to add correct tokens, maybe that's not a vulnerability. But if an admin is compromised, this could be a problem. However, the question is about vulnerabilities in the code, not about admin privileges.

Check for integer overflows. The contract uses Solidity 0.8.9, which has built-in overflow checks, so that's probably not an issue.

In the _burnToken function, when dealing with external tokens, they create a DepositHandler contract via new DepositHandler{salt: salt}(). Then they call execute on it, which transfers tokens from the DepositHandler to the gateway. However, the DepositHandler's execute function is called with tokenAddress and the transfer selector. But if the DepositHandler's execute function is not properly secured, maybe there's a way to exploit it. But looking at DepositHandler's code (assuming it's a simple contract that executes a call and then allows destruction), maybe it's okay. But if the DepositHandler has any vulnerabilities, like allowing arbitrary calls, but in this case, the execute function is called with specific parameters. It might be safe.

Another thing: when burning internal tokens (like BurnableMintableCappedERC20), they call burn(bytes32(0)). What if the salt is not properly managed? Not sure. Maybe that's intended.

Check for event emissions after external calls. In functions like _burnTokenFrom, they emit TokenSent after burning. Since the burn is done first, and then the event is emitted, that's okay. Reentrancy after the event is not possible because the function has already completed.

In the validateContractCallAndMint function, after validating, they call _mintToken. If the _mintToken function for an external token calls back into the contract, could that cause issues? But since the approval is set to false before minting (because valid is checked and then _setBool(key, false)), maybe reentrancy here is mitigated. Wait, in validateContractCallAndMint, they check if valid (which is getBool(key)), then set the key to false, then call _mintToken. So even if the mintToken reenters, the key is already set to false, so it can't be reused. So reentrancy here is not possible.

Another potential issue is front-running. For example, when approving contract calls, if someone can front-run the approval, but that's more of a design consideration.

What about the way commandIds are handled? The _setCommandExecuted function sets a commandId as executed. If there's a way to reuse a commandId, that could be a problem. But the function is only called internally, and the commandId should be unique per command. It's up to the external validators to ensure that commandIds are unique.

The contract uses a lot of storage pointers with keccak hashes. For example, the way token addresses are stored. If there's a collision in the key hashes, that could cause issues, but the way the keys are constructed (with prefixes and parameters) makes collisions unlikely.

In the _deployToken function, when deploying a new token, the _setTokenType is called with TokenType.InternalBurnableFrom. But when deploying an external token, it's set to TokenType.External. However, if a token is deployed as external, but then someone tries to interact with it as an internal token, that could cause issues. But the code checks the token type before operations, so that's handled.

Check for proper validation of inputs. For example, in sendToken, they check if the amount is zero. That's good. Also, in _deployToken, they check if the token already exists. So input validation seems okay.

Looking back at the initial functions, like sendToken and callContractWithToken, they burn tokens from the sender. These functions are external, so any user can call them. But if the token is frozen, the _checkTokenStatus would revert. But if the token is not frozen, then burning is allowed. That's intended behavior.

Possible vulnerabilities I can think of:

1. **Delegatecall to TokenDeployer**: Using delegatecall in _deployToken to TOKEN_DEPLOYER_IMPLEMENTATION's deployToken function. If the TokenDeployer contract has functions that modify the AxelarGateway's storage, it could lead to unintended state changes. For example, if the deployToken function writes to storage slots used by AxelarGateway, it could overwrite critical data like admin addresses or token addresses. Since delegatecall uses the caller's storage, any state changes in TokenDeployer's functions would affect AxelarGateway. This is a critical vulnerability if the TokenDeployer is not fully trusted or if its code is upgradable.

2. **External Token Compliance**: When adding an external token, the contract doesn't verify that the token complies with the expected interface (e.g., returns a boolean on transfer/transferFrom). If an external token doesn't return a boolean (like old ERC20 implementations), calls to _callERC20Token could incorrectly return false, leading to BurnFailed or MintFailed errors even if the transfer succeeded. This could cause the gateway to malfunction when interacting with such tokens. For example, transferring tokens from a non-compliant ERC20 would result in the transaction reverting, which could be exploited by an attacker to block certain operations.

3. **Reentrancy in External Token Interactions**: Although the code sets state variables after external calls in some cases (like burning before emitting an event), there might be cases where state is updated after the call. For example, in _burnTokenFrom, when burning an external token, the code does transferFrom to this contract, and then returns. If the external token's transferFrom function calls back into the AxelarGateway, the gateway's state might not have been updated yet, allowing reentrancy attacks. However, in this case, since the state (like token balances) isn't tracked in the gateway's storage, maybe reentrancy isn't an issue here. But if there are any state changes that happen after the external call, they could be vulnerable.

4. **DepositHandler Reuse or Manipulation**: In _burnToken for external tokens, a DepositHandler contract is created with a specific salt. The code transfers tokens from the DepositHandler to the gateway. If the salt is predictable or can be manipulated, an attacker might front-run the creation of the DepositHandler to interfere with the burn process. However, the salt is derived from the function's parameters, which might include a user-provided salt. If the salt isn't properly randomized or controlled, it could be exploited.

5. **Insufficient Event Emission for Critical Operations**: Functions like _setTokenAddress and _setTokenType emit events (e.g., TokenDeployed), but if any critical state changes don't emit events, it could lead to off-chain tracking issues. However, the code seems to emit events where necessary.

6. **Missing Access Control on Administrative Functions**: The onlyAdmin modifier is used correctly on functions that require it. But if there's a way to bypass the onlyAdmin check, that's a problem. For example, if the AdminMultisigBase contract has a flaw in its admin checks. But without seeing the implementation of AdminMultisigBase, it's hard to tell. However, assuming that AdminMultisigBase is correctly implemented, this might not be an issue.

7. **Uninitialized Contracts**: The AxelarGateway is abstract, so maybe some functions are meant to be implemented in derived contracts. But in the provided code, the abstract functions (like getBool, _setBool, etc.) are not defined here, which could lead to deployment issues if not properly implemented in a child contract. However, this is more of a compilation issue rather than a runtime vulnerability.

8. **Upgradeability Risks**: The upgrade function allows changing the implementation address. If an attacker can compromise the admin account, they can upgrade to a malicious contract. But this is a trust issue with the admin. However, the code checks that the new implementation's codehash matches the provided one, which prevents some attacks, but if the setupParams are malicious, they could perform a delegatecall to arbitrary functions during setup. But again, this requires admin privileges.

So the main vulnerabilities I can spot are:

- **Unsafe delegatecall in Token Deployment** (critical): Using delegatecall to TokenDeployer's deployToken function could allow the TokenDeployer to modify the AxelarGateway's storage if it has any state variables or functions that write to storage. This could lead to arbitrary code execution or storage corruption.

- **External Token Non-Compliance** (high): If external tokens don't adhere to ERC20's return values, calls to burn or mint may fail incorrectly, leading to denial-of-service or failed transactions.

- **Reentrancy in External Token Interactions** (medium): If external tokens allow reentrancy during transferFrom or transfer, the AxelarGateway might be vulnerable if state changes are made after the external call. However, in the current code, most state changes (like setting command executed flags) happen before the external call, but in functions like validateContractCallAndMint, the _mintToken is called after setting the bool to false, which is safe.

Wait, looking at validateContractCallAndMint: after checking valid, it sets the key to false, then calls _mintToken. So during the minting, if the external token's transfer function calls back into the gateway, the key is already marked as used, so reentrancy here would not allow reusing the same commandId. That seems safe.

Another possible vulnerability:

- **Improper Handling of ERC20 Return Values**: The _callERC20Token function assumes that a successful call with non-empty return data can be decoded as a bool. For tokens that return other data types or no data, this could lead to incorrect success/failure determinations. For example, some tokens might return nothing on success (older ERC20s), which would cause the abi.decode to fail, leading to returning false even if the transfer succeeded. This would cause the contract to revert with BurnFailed or MintFailed, even though the transfer worked. This is a problem because it could lock funds or prevent legitimate operations.

Yes, this is a real issue. Let me check the code:

In _callERC20Token:
( bool success, bytes memory returnData ) = tokenAddress.call(callData);
return success && ( returnData.length == uint256(0) || abi.decode(returnData, (bool)) );

So if the token returns nothing (returnData.length == 0), it's considered a success (since the first condition is success, and then returnData.length is 0). So that's okay. But if the token returns data that isn't a bool, then abi.decode(returnData, (bool)) will revert, causing the entire call to revert. But in Solidity, when you call an external function and it returns data that doesn't match the expected type, the call would revert. Wait, no. The external call is done via .call(), which doesn't check the return data's validity. Only when you try to decode it, it would revert. So for example, if the token's transfer function returns (uint256 1) instead of (bool true), then returnData is the encoded uint256 1. When you abi.decode that as a bool, it would fail, causing the function to return false, which would lead to BurnFailed error. But in reality, the transfer succeeded. So this is a problem for non-compliant tokens. However, AxelarGateway allows admins to add such tokens as external tokens. If an admin adds a non-compliant token, then burning or minting would fail even if the transfer worked. This is a potential vulnerability in the interaction with non-standard tokens.

So summarizing the vulnerabilities:

1. **Unsafe Delegatecall in Token Deployment**: The use of delegatecall to TokenDeployer's deployToken function can lead to storage corruption if the TokenDeployer's code writes to storage variables. Critical severity.

2. **Incorrect Handling of Non-Compliant ERC20 Tokens**: When interacting with external tokens that do not return a boolean on transfer/transferFrom, or return malformed data, the gateway may incorrectly revert transactions, leading to failed operations. High severity.

3. **Potential Reentrancy in External Token Interactions**: If an external token's transferFrom or transfer function allows reentrancy, certain functions in AxelarGateway could be vulnerable. However, since state changes (like setting approvals to false) happen before the external call, the risk is mitigated. Medium severity.

4. **DepositHandler Front-Running or Salt Collision**: The use of a user-provided salt in DepositHandler's deployment might allow an attacker to predict or interfere with the deployment. However, the salt is derived from the function parameters. If the salt is properly controlled, this may not be an issue. Low severity.

5. **Token Type Confusion**: If a token is added as an external token but actually implements the internal interface, or vice versa, it could lead to unexpected behavior. However, admins are trusted to correctly configure tokens. Medium severity.

Other notes:

- The contract uses a multisig admin (AdminMultisigBase), which may have its own vulnerabilities if not implemented correctly, but without seeing its code, it's hard to assess.

- The contract is abstract and depends on several other contracts (like BurnableMintableCappedERC20, DepositHandler), which may have their own vulnerabilities. But the question is about this specific contract.

So the main vulnerabilities to list are points 1, 2, and possibly 3.","```
None.
```",0.0
