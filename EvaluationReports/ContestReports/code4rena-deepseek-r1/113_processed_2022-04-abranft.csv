nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
NFTPairWithOracle.sol,"// SPDX-License-Identifier: UNLICENSED

// Private Pool (NFT collateral)

//    (                (   (
//    )\      )    (   )\  )\ )  (
//  (((_)  ( /(   ))\ ((_)(()/(  )(    (    (
//  )\___  )(_)) /((_) _   ((_))(()\   )\   )\ )
// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(
//  | (__ / _` || || || |/ _` | | '_|/ _ \| ' \))
//   \___|\__,_| \_,_||_|\__,_| |_|  \___/|_||_|

// Copyright (c) 2021 BoringCrypto - All rights reserved
// Twitter: @Boring_Crypto

// Special thanks to:
// @0xKeno - for all his invaluable contributions
// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations

pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; // How much will you get? OK to owe until expiration.
    uint64 duration; // Length of loan in seconds
    uint16 annualInterestBPS; // Variable cost of taking out the loan
    uint16 ltvBPS; // Required to avoid liquidation
    INFTOracle oracle; // oracle used
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    // Per token settings.
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}

/// @title NFTPairWithOracle
/// @dev This contract allows contract calls to any contract (except BentoBox)
/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.
contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    // This automatically clears the associated loan, if any
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    // Details are in the loan request
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    // Immutables (for MasterContract and all clones)
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    // MasterContract variables
    address public feeTo;

    // Per clone variables
    // Clone init settings
    IERC721 public collateral;
    IERC20 public asset;

    // A note on terminology:
    // ""Shares"" are BentoBox shares.

    // Track assets we own. Used to allow skimming the excesss.
    uint256 public feesEarnedShare;

    // Per token settings.
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    // Do not go over 100% on either of these..
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    // Highest order term in the Maclaurin series for exp used by
    // `calculateIntest`.
    // Intuitive interpretation: interest continuously accrues on the principal.
    // That interest, in turn, earns ""second-order"" interest-on-interest, which
    // itself earns ""third-order"" interest, etc. This constant determines how
    // far we take this until we stop counting.
    //
    // The error, in terms of the interest rate, is at least
    //
    //            ----- n                        ----- Infinity
    //             \           x^k                \              x^k
    //      e^x -   )          ---   , which is    )             --- ,
    //             /            k!                /               k!
    //            ----- k = 1       k            ----- k = n + 1
    //
    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of
    // interest that is owed at rate r over time t. It makes no difference if
    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation
    // is the same. Why ""at least""? There are also rounding errors. See
    // `calculateInterest` for more detail.
    // The factorial in the denominator ""wins""; for all reasonable (and quite
    // a few unreasonable) interest rates, the lower-order terms contribute the
    // most to the total. The following table lists some of the calculated
    // approximations for different values of n, along with the ""true"" result:
    //
    // Total:         10%    20%    50%    100%    200%      500%       1000%
    // -----------------------------------------------------------------------
    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%
    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%
    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%
    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%
    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%
    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%
    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%
    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%
    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%
    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%
    //
    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%
    //
    // For instance, calculating the compounding effects of 200% in ""total""
    // interest to the sixth order results in 635.6%, whereas the true result
    // is 638.9%.
    // At 500% that difference is a little more dramatic, but it is still in
    // the same ballpark -- and of little practical consequence unless the
    // collateral can be expected to go up more than 112 times in value.
    // Still, for volatile tokens, or an asset that is somehow known to be very
    // inflationary, use a different number.
    // Zero (no interest at all) is ignored and treated as one (linear only).
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    // For signed lend / borrow requests:
    mapping(address => uint256) public nonces;

    /// @notice The constructor is only used for the initial master contract.
    /// @notice Subsequent clones are initialised via `init`.
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    /// @notice De facto constructor for clone contracts
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            // The lender can change terms so long as the changes are strictly
            // the same or better for the borrower:
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            // The borrower has already deposited the collateral and can
            // change whatever they like
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            // The loan has not been taken out yet; the borrower needs to
            // provide collateral.
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        // Edge case: valuation can be zero. That effectively gifts the NFT and
        // is therefore a bad idea, but does not break the contract.
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    /// @notice Deposit an NFT as collateral and request a loan against it
    /// @param tokenId ID of the NFT
    /// @param to Address to receive the loan, or option to withdraw collateral
    /// @param params Loan conditions on offer
    /// @param skim True if the token has already been transfered
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    /// @notice Removes `tokenId` as collateral and transfers it to `to`.
    /// @notice This destroys the loan.
    /// @param tokenId The token
    /// @param to The receiver of the token.
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            // We are withdrawing collateral that is not in use:
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            // We are seizing collateral towards the lender. The loan has to be
            // expired and not paid off, or underwater and not paid off:
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                // No underflow: loan.startTime is only ever set to a block timestamp
                // Cast is safe: if this overflows, then all loans have expired anyway
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        // If there somehow is collateral but no accompanying loan, then anyone
        // can claim it by first requesting a loan with `skim` set to true, and
        // then withdrawing. So we might as well allow it here..
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    // Assumes the lender has agreed to the loan.
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        // Valuation has to be an exact match, everything else must be at least
        // as good for the lender as `accepted`.
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        // No overflow: at most 128 + 16 bits (fits in BentoBox)
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        // No underflow: follows from OPEN_FEE_BPS <= BPS
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        // No overflow: addends (and result) must fit in BentoBox
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    /// @notice Lends with the parameters specified by the borrower.
    /// @param tokenId ID of the token that will function as collateral
    /// @param accepted Loan parameters as the lender saw them, for security
    /// @param skim True if the funds have been transfered to the contract
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // NOTE on signature hashes: the domain separator only guarantees that the
    // chain ID and master contract are a match, so we explicitly include the
    // clone address (and the asset/collateral addresses):

    // keccak256(""Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    // keccak256(""Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)"")
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    /// @notice Request and immediately borrow from a pre-committed lender

    /// @notice Caller provides collateral; loan can go to a different address.
    /// @param tokenId ID of the token that will function as collateral
    /// @param lender Lender, whose BentoBox balance the funds will come from
    /// @param recipient Address to receive the loan.
    /// @param params Loan parameters requested, and signed by the lender
    /// @param skimCollateral True if the collateral has already been transfered
    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    /// @notice Take collateral from a pre-commited borrower and lend against it
    /// @notice Collateral must come from the borrower, not a third party.
    /// @param tokenId ID of the token that will function as collateral
    /// @param borrower Address that provides collateral and receives the loan
    /// @param params Loan terms offered, and signed by the borrower
    /// @param skimFunds True if the funds have been transfered to the contract
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    /// Approximates continuous compounding. Uses Horner's method to evaluate
    /// the truncated Maclaurin series for exp - 1, accumulating rounding
    /// errors along the way. The following is always guaranteed:
    ///
    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),
    ///
    /// where time = t/YEAR, up to at most the rounding error obtained in
    /// calculating linear interest.
    ///
    /// If the theoretical result that we are approximating (the rightmost part
    /// of the above inquality) fits in 128 bits, then the function is
    /// guaranteed not to revert (unless n > 250, which is way too high).
    /// If even the linear interest (leftmost part of the inequality) does not
    /// the function will revert.
    /// Otherwise, the function may revert, return a reasonable result, or
    /// return a very inaccurate result. Even then the above inequality is
    /// respected.
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)
        //
        // We calculate
        //
        //  ----- n                                       ----- n
        //   \           principal * (t * aprBPS)^k        \
        //    )          --------------------------   =:    )          term_k
        //   /                k! * YEAR_BPS^k              /
        //  ----- k = 1                                   ----- k = 1
        //
        // which approaches, but never exceeds the ""theoretical"" result,
        //
        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1
        //
        // as n goes to infinity. We use the fact that
        //
        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)
        //      term_k = ---------------------------------------------
        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS
        //
        //                             t * aprBPS
        //             = term_{k-1} * ------------                          (*)
        //                            k * YEAR_BPS
        //
        // to calculate the terms one by one. The principal affords us the
        // precision to carry out the division without resorting to fixed-point
        // math. Any rounding error is downward, which we consider acceptable.
        //
        // Since all numbers involved are positive, each term is certainly
        // bounded above by M. From (*) we see that any intermediate results
        // are at most
        //
        //                      denom_k := k * YEAR_BPS.
        //
        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,
        // which proves that all calculations will certainly not overflow if M
        // fits in 128 bits.
        //
        // If M does not fit, then the intermediate results for some term may
        // eventually overflow, but this cannot happen at the first term, and
        // neither can the total overflow because it uses checked math.
        //
        // This constitutes a guarantee of specified behavior when M >= 2^128.
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); // <- Only overflow check we need
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            // Addition is safe: both summands are smaller than 256 bits
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        // No underflow: loan.startTime is only ever set to a block timestamp
        // Cast is safe: if this overflows, then all loans have expired anyway
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            // No overflow: result fits in BentoBox
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    // Function on BentoBox
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    // Any external call (except to BentoBox)
    uint8 internal constant ACTION_CALL = 30;

    // Signed requests
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    /// @dev Helper function for depositing into `bentoBox`.
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    /// @dev Helper function to withdraw from the `bentoBox`.
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.
    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.
    /// This also means that calls made from this contract shall *not* be trusted.
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.
    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).
    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.
    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.
    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.
    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).
    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    /// @notice Withdraws the fees accumulated.
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    /// @notice Sets the beneficiary of fees accrued in liquidations.
    /// MasterContract Only Admin function.
    /// @param newFeeTo The address of the receiver.
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",8413,754,"[H-01] Avoidance of Liquidation Via Malicious Oracle
Issue: Arbitrary oracles are permitted on construction of loans, and there is no check that the lender agrees to the used oracle.
Consequences: A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation. Lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed
  [H-02] The return value success of the get function of the INFTOracle interface is not checked “(, uint256 rate) = loanParams.oracle.get(address(this), tokenId);”
The get function of the INFTOracle interface returns two values, but the success value is not checked when used in the NFTPairWithOracle contract. When success is false, NFTOracle may return stale data.
  [H-03] Critical Oracle Manipulation Risk by Lender
The intended use of the Oracle is to protect the lender from a drop in the borrower's collateral value. If the collateral value goes up significantly and higher than borrowed amount + interest, the lender should not be able to seize the collateral at the expense of the borrower. However, in the NFTPairWithOracle contract, the lender could change the Oracle once a loan is outstanding, and therefore seize the collateral at the expense of the borrower, if the actual value of the collateral has increased significantly. This is a critical risk because borrowers asset could be lost to malicious lenders.
  [H-04] Lender is able to seize the collateral by changing the loan parameters The `updateLoanParams()` allows the lender to modify the parameters of an active loan in favor of the borrower. But, by setting the ltvBPS value to 0 they are able to seize the collateral.   [H-05] Mistake while checking LTV to lender accepted LTV
It comments in the `_lend()` function that lender accepted conditions must be at least as good as the borrower is asking for. The line which checks the accepted LTV (lender's LTV) against borrower asking LTV is: `params.ltvBPS >= accepted.ltvBPS`, This means lender should be offering a lower LTV, which must be the opposite way around. I think this may have the potential to strand the lender, if he enters a lower LTV. For example borrower asking LTV is 86%. However, lender enters his accepted LTV as 80%. lend() will execute with 86% LTV and punish the lender, whereas it should revert and acknowledge the lender that his bid is not good enough.
  [M-01] Reentrancy at _requestLoan allows requesting a loan without supplying collateral
The function `_requestLoan` makes an external call to the collateral contract before updating the NFTPair contract state.",6,"pragma solidity 0.6.12;
pragma experimental ABIEncoderV2;
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol"";
import ""@boringcrypto/boring-solidity/contracts/BoringOwnable.sol"";
import ""@boringcrypto/boring-solidity/contracts/Domain.sol"";
import ""@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol"";
import ""@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol"";
import ""@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol"";
import ""./interfaces/IERC721.sol"";
import ""./interfaces/INFTOracle.sol"";

struct TokenLoanParams {
    uint128 valuation; 
    uint64 duration; 
    uint16 annualInterestBPS; 
    uint16 ltvBPS; 
    INFTOracle oracle; 
}

struct SignatureParams {
    uint256 deadline;
    uint8 v;
    bytes32 r;
    bytes32 s;
}

interface ILendingClub {
    
    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);

    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);
}

interface INFTPair {
    function collateral() external view returns (IERC721);

    function asset() external view returns (IERC20);

    function masterContract() external view returns (address);

    function bentoBox() external view returns (IBentoBoxV1);

    function removeCollateral(uint256 tokenId, address to) external;
}




contract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using RebaseLibrary for Rebase;
    using BoringERC20 for IERC20;

    event LogRequestLoan(
        address indexed borrower,
        uint256 indexed tokenId,
        uint128 valuation,
        uint64 duration,
        uint16 annualInterestBPS,
        uint16 ltvBPS
    );
    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);
    
    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);
    
    event LogLend(address indexed lender, uint256 indexed tokenId);
    event LogRepay(address indexed from, uint256 indexed tokenId);
    event LogFeeTo(address indexed newFeeTo);
    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);

    
    IBentoBoxV1 public immutable bentoBox;
    NFTPairWithOracle public immutable masterContract;

    
    address public feeTo;

    
    
    IERC721 public collateral;
    IERC20 public asset;

    
    

    
    uint256 public feesEarnedShare;

    
    mapping(uint256 => TokenLoanParams) public tokenLoanParams;

    uint8 private constant LOAN_INITIAL = 0;
    uint8 private constant LOAN_REQUESTED = 1;
    uint8 private constant LOAN_OUTSTANDING = 2;
    struct TokenLoan {
        address borrower;
        address lender;
        uint64 startTime;
        uint8 status;
    }
    mapping(uint256 => TokenLoan) public tokenLoan;

    
    uint256 private constant PROTOCOL_FEE_BPS = 1000;
    uint256 private constant OPEN_FEE_BPS = 100;
    uint256 private constant BPS = 10_000;
    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    uint8 private constant COMPOUND_INTEREST_TERMS = 6;

    
    mapping(address => uint256) public nonces;

    
    
    constructor(IBentoBoxV1 bentoBox_) public {
        bentoBox = bentoBox_;
        masterContract = this;
    }

    
    function init(bytes calldata data) public payable override {
        require(address(collateral) == address(0), ""NFTPair: already initialized"");
        (collateral, asset) = abi.decode(data, (IERC721, IERC20));
        require(address(collateral) != address(0), ""NFTPair: bad pair"");
    }

    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_OUTSTANDING) {
            
            
            require(msg.sender == loan.lender, ""NFTPair: not the lender"");
            TokenLoanParams memory cur = tokenLoanParams[tokenId];
            require(
                params.duration >= cur.duration &&
                    params.valuation <= cur.valuation &&
                    params.annualInterestBPS <= cur.annualInterestBPS &&
                    params.ltvBPS <= cur.ltvBPS,
                ""NFTPair: worse params""
            );
        } else if (loan.status == LOAN_REQUESTED) {
            
            
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else {
            
            
            revert(""NFTPair: no collateral"");
        }
        tokenLoanParams[tokenId] = params;
        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    function _requestLoan(
        address collateralProvider,
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) private {
        
        
        require(tokenLoan[tokenId].status == LOAN_INITIAL, ""NFTPair: loan exists"");
        if (skim) {
            require(collateral.ownerOf(tokenId) == address(this), ""NFTPair: skim failed"");
        } else {
            collateral.transferFrom(collateralProvider, address(this), tokenId);
        }
        TokenLoan memory loan;
        loan.borrower = to;
        loan.status = LOAN_REQUESTED;
        tokenLoan[tokenId] = loan;
        tokenLoanParams[tokenId] = params;

        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);
    }

    
    
    
    
    
    function requestLoan(
        uint256 tokenId,
        TokenLoanParams memory params,
        address to,
        bool skim
    ) public {
        _requestLoan(msg.sender, tokenId, params, to, skim);
    }

    
    
    
    
    function removeCollateral(uint256 tokenId, address to) public {
        TokenLoan memory loan = tokenLoan[tokenId];
        if (loan.status == LOAN_REQUESTED) {
            
            require(msg.sender == loan.borrower, ""NFTPair: not the borrower"");
        } else if (loan.status == LOAN_OUTSTANDING) {
            
            
            require(to == loan.lender, ""NFTPair: not the lender"");

            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {
                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
                
                
                uint256 interest = calculateInterest(
                    loanParams.valuation,
                    uint64(block.timestamp - loan.startTime),
                    loanParams.annualInterestBPS
                ).to128();
                uint256 amount = loanParams.valuation + interest;
                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);
                require(rate.mul(loanParams.ltvBPS) / BPS < amount, ""NFT is still valued"");
            }
        }
        
        
        
        delete tokenLoan[tokenId];
        collateral.transferFrom(address(this), to, tokenId);
        emit LogRemoveCollateral(tokenId, to);
    }

    
    function _lend(
        address lender,
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) internal {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_REQUESTED, ""NFTPair: not available"");
        TokenLoanParams memory params = tokenLoanParams[tokenId];

        
        
        require(
            params.valuation == accepted.valuation &&
                params.duration <= accepted.duration &&
                params.annualInterestBPS >= accepted.annualInterestBPS &&
                params.ltvBPS >= accepted.ltvBPS,
            ""NFTPair: bad params""
        );

        if (params.oracle != INFTOracle(0)) {
            (, uint256 rate) = params.oracle.get(address(this), tokenId);
            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, ""Oracle: price too low."");
        }

        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);
        
        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;
        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;

        if (skim) {
            require(
                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),
                ""NFTPair: skim too much""
            );
        } else {
            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);
        }
        
        uint256 borrowerShare = totalShare - openFeeShare;
        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);
        
        feesEarnedShare += protocolFeeShare;

        loan.lender = lender;
        loan.status = LOAN_OUTSTANDING;
        loan.startTime = uint64(block.timestamp); 
        tokenLoan[tokenId] = loan;

        emit LogLend(lender, tokenId);
    }

    
    
    
    
    function lend(
        uint256 tokenId,
        TokenLoanParams memory accepted,
        bool skim
    ) public {
        _lend(msg.sender, tokenId, accepted, skim);
    }

    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    
    

    
    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;

    
    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;

    

    
    
    
    
    
    
    
    function requestAndBorrow(
        uint256 tokenId,
        address lender,
        address recipient,
        TokenLoanParams memory params,
        bool skimCollateral,
        bool anyTokenId,
        SignatureParams memory signature
    ) public {
        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {
            require(ILendingClub(lender).willLend(tokenId, params), ""NFTPair: LendingClub does not like you"");
        } else {
            require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
            uint256 nonce = nonces[lender]++;
            bytes32 dataHash = keccak256(
                abi.encode(
                    LEND_SIGNATURE_HASH,
                    address(this),
                    anyTokenId ? 0 : tokenId,
                    anyTokenId,
                    params.valuation,
                    params.duration,
                    params.annualInterestBPS,
                    params.ltvBPS,
                    params.oracle,
                    nonce,
                    signature.deadline
                )
            );
            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, ""NFTPair: signature invalid"");
        }
        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);
        _lend(lender, tokenId, params, false);
    }

    
    
    
    
    
    
    function takeCollateralAndLend(
        uint256 tokenId,
        address borrower,
        TokenLoanParams memory params,
        bool skimFunds,
        SignatureParams memory signature
    ) public {
        require(block.timestamp <= signature.deadline, ""NFTPair: signature expired"");
        uint256 nonce = nonces[borrower]++;
        bytes32 dataHash = keccak256(
            abi.encode(
                BORROW_SIGNATURE_HASH,
                address(this),
                tokenId,
                params.valuation,
                params.duration,
                params.annualInterestBPS,
                params.ltvBPS,
                params.oracle,
                nonce,
                signature.deadline
            )
        );
        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, ""NFTPair: signature invalid"");
        _requestLoan(borrower, tokenId, params, borrower, false);
        _lend(msg.sender, tokenId, params, skimFunds);
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    function calculateInterest(
        uint256 principal,
        uint64 t,
        uint16 aprBPS
    ) public pure returns (uint256 interest) {
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        uint256 x = uint256(t) * aprBPS;
        uint256 term_k = (principal * x) / YEAR_BPS;
        uint256 denom_k = YEAR_BPS;

        interest = term_k;
        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {
            denom_k += YEAR_BPS;
            term_k = (term_k * x) / denom_k;
            interest = interest.add(term_k); 
        }

        if (interest >= 2**128) {
            revert();
        }
    }

    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {
        TokenLoan memory loan = tokenLoan[tokenId];
        require(loan.status == LOAN_OUTSTANDING, ""NFTPair: no loan"");
        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];
        require(
            
            uint256(loan.startTime) + loanParams.duration > block.timestamp,
            ""NFTPair: loan expired""
        );

        uint128 principal = loanParams.valuation;

        
        
        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();
        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;
        amount = principal + interest;

        uint256 totalShare = bentoBox.toShare(asset, amount, false);
        uint256 feeShare = bentoBox.toShare(asset, fee, false);

        address from;
        if (skim) {
            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), ""NFTPair: skim too much"");
            from = address(this);
            
        } else {
            bentoBox.transfer(asset, msg.sender, address(this), feeShare);
            from = msg.sender;
        }
        
        feesEarnedShare += feeShare;
        delete tokenLoan[tokenId];

        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);
        collateral.transferFrom(address(this), loan.borrower, tokenId);

        emit LogRepay(from, tokenId);
    }

    uint8 internal constant ACTION_REPAY = 2;
    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;

    uint8 internal constant ACTION_REQUEST_LOAN = 12;
    uint8 internal constant ACTION_LEND = 13;

    
    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;
    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;
    uint8 internal constant ACTION_BENTO_TRANSFER = 22;
    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;
    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;

    
    uint8 internal constant ACTION_CALL = 30;

    
    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;
    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;

    int256 internal constant USE_VALUE1 = -1;
    int256 internal constant USE_VALUE2 = -2;

    
    function _num(
        int256 inNum,
        uint256 value1,
        uint256 value2
    ) internal pure returns (uint256 outNum) {
        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);
    }

    
    function _bentoDeposit(
        bytes memory data,
        uint256 value,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        amount = int256(_num(amount, value1, value2)); 
        share = int256(_num(share, value1, value2));
        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));
    }

    
    function _bentoWithdraw(
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (uint256, uint256) {
        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));
        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));
    }

    
    
    
    function _call(
        uint256 value,
        bytes memory data,
        uint256 value1,
        uint256 value2
    ) internal returns (bytes memory, uint8) {
        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(
            data,
            (address, bytes, bool, bool, uint8)
        );

        if (useValue1 && !useValue2) {
            callData = abi.encodePacked(callData, value1);
        } else if (!useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value2);
        } else if (useValue1 && useValue2) {
            callData = abi.encodePacked(callData, value1, value2);
        }

        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), ""NFTPair: can't call"");

        (bool success, bytes memory returnData) = callee.call{value: value}(callData);
        require(success, ""NFTPair: call failed"");
        return (returnData, returnValues);
    }

    
    
    
    
    
    
    
    function cook(
        uint8[] calldata actions,
        uint256[] calldata values,
        bytes[] calldata datas
    ) external payable returns (uint256 value1, uint256 value2) {
        for (uint256 i = 0; i < actions.length; i++) {
            uint8 action = actions[i];
            if (action == ACTION_REPAY) {
                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));
                repay(tokenId, skim);
            } else if (action == ACTION_REMOVE_COLLATERAL) {
                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));
                removeCollateral(tokenId, to);
            } else if (action == ACTION_REQUEST_LOAN) {
                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(
                    datas[i],
                    (uint256, TokenLoanParams, address, bool)
                );
                requestLoan(tokenId, params, to, skim);
            } else if (action == ACTION_LEND) {
                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));
                lend(tokenId, params, skim);
            } else if (action == ACTION_BENTO_SETAPPROVAL) {
                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(
                    datas[i],
                    (address, address, bool, uint8, bytes32, bytes32)
                );
                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);
            } else if (action == ACTION_BENTO_DEPOSIT) {
                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);
            } else if (action == ACTION_BENTO_WITHDRAW) {
                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);
            } else if (action == ACTION_BENTO_TRANSFER) {
                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));
                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));
            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {
                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));
                bentoBox.transferMultiple(token, msg.sender, tos, shares);
            } else if (action == ACTION_CALL) {
                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);

                if (returnValues == 1) {
                    (value1) = abi.decode(returnData, (uint256));
                } else if (returnValues == 2) {
                    (value1, value2) = abi.decode(returnData, (uint256, uint256));
                }
            } else if (action == ACTION_REQUEST_AND_BORROW) {
                (
                    uint256 tokenId,
                    address lender,
                    address recipient,
                    TokenLoanParams memory params,
                    bool skimCollateral,
                    bool anyTokenId,
                    SignatureParams memory signature
                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));
                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);
            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {
                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi
                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));
                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);
            }
        }
    }

    
    function withdrawFees() public {
        address to = masterContract.feeTo();

        uint256 _share = feesEarnedShare;
        if (_share > 0) {
            bentoBox.transfer(asset, address(this), to, _share);
            feesEarnedShare = 0;
        }

        emit LogWithdrawFees(to, _share);
    }

    
    
    
    function setFeeTo(address newFeeTo) public onlyOwner {
        feeTo = newFeeTo;
        emit LogFeeTo(newFeeTo);
    }
}",4953,5,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unauthorized Loan Request via Skim**  
   The `_requestLoan` function allows any user to create a loan request using existing collateral in the contract when `skim` is enabled. If another user's NFT is already deposited, an attacker can initiate a loan without owning the NFT, potentially stealing collateral.

2. **Insecure Oracle Reliance**  
   The contract depends on an external `INFTOracle` for NFT valuations. If the oracle is manipulated, returns stale data, or is compromised, loans may be undercollateralized, leading to financial losses for lenders.

3. **Interest Calculation Precision Issues**  
   The `calculateInterest` function uses a fixed-term approximation (6 iterations) for compounding interest. This truncation may result in inaccurate interest calculations, especially for high APRs or long durations, disadvantaging lenders or borrowers.

4. **Expired Loan Handling in Repayment**  
   The `repay` function cannot be called after the loan duration expires. Lenders must remove collateral directly, potentially at a loss if the collateral's market value has dropped below the owed amount. This shifts risk to lenders post-expiry.

5. **Front-Runnable Loan Parameter Updates**  
   Borrowers can modify loan parameters (e.g., lower interest rates) while a loan is in `REQUESTED` status, which could invalidate lender expectations. However, lenders validate parameters during `_lend`, mitigating this risk.

6. **Unrestricted Fee Withdrawal**  
   The `withdrawFees` function is publicly callable, allowing anyone to trigger fee transfers. While not directly exploitable, it could lead to unnecessary gas costs or governance issues if misconfigured.

7. **Signature Verification Risks**  
   While signatures include nonces and contract addresses, potential edge cases (e.g., reused nonces across functions) could allow replay attacks if not rigorously validated in dependent code.

8. **Insufficient Validation in Collateral Removal**  
   Lenders can remove collateral post-expiry without rechecking the NFT's value, risking loss if the collateral depreciates. This is a design choice but exposes lenders to market volatility.

9. **Incorrect Loan State Transitions**  
   The loan state transitions (e.g., allowing lenders to update terms post-loan issuance) may enable unfavorable modifications if the lender's account is compromised, though the code enforces parameter downgrades (e.g., lower interest).

10. **ERC-721 Reentrancy During Transfers**  
    While the contract deletes loan data before transferring NFTs, external ERC-721 `transferFrom` implementations could theoretically reenter, though no state inconsistencies were identified.","### **Analysis of Alignment Between Issue Report and Response List**

---

#### **[H-01] Avoidance of Liquidation Via Malicious Oracle**

**Report Description**:  
Arbitrary oracles are permitted on loan construction, and there is no check that the lender agrees to the used oracle. A borrower who requests a loan with a malicious oracle can avoid legitimate liquidation. The lender cannot call `removeCollateral` to liquidate the NFT when it should be allowed.

**Match in Response List**:  
Matches with the issue titled **""Insecure Oracle Reliance""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of relying on an external oracle but does not explicitly address the issue of malicious oracles being used without lender consent. The response focuses on oracle manipulation and stale data but misses the critical aspect of lender agreement on the oracle.

**Suggestions**:  
The response should explicitly recommend validating that the lender agrees to the oracle used in the loan construction to prevent malicious oracle usage.

---

#### **[H-02] Unchecked Return Value of `get` Function in INFTOracle Interface**

**Report Description**:  
The `get` function of the `INFTOracle` interface returns two values, but the `success` value is not checked when used in the `NFTPairWithOracle` contract. When `success` is false, the oracle may return stale data.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the unchecked return value of the `get` function, which is a critical security vulnerability. This oversight could lead to the use of stale or incorrect data, impacting loan valuations and collateral management.

**Suggestions**:  
The response should recommend checking the `success` return value of the `get` function to ensure the oracle data is valid and up-to-date.

---

#### **[H-03] Critical Oracle Manipulation Risk by Lender**

**Report Description**:  
The lender can change the oracle once a loan is outstanding, potentially seizing the collateral at the borrower's expense if the collateral value has increased significantly. This is a critical risk because the borrower's asset could be lost to malicious lenders.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the risk of lenders changing the oracle after a loan is issued. This is a severe vulnerability that could lead to unfair seizure of collateral.

**Suggestions**:  
The response should recommend restricting oracle changes after a loan is issued to prevent malicious behavior by lenders.

---

#### **[H-04] Lender is Able to Seize the Collateral by Changing Loan Parameters**

**Report Description**:  
The `updateLoanParams()` function allows the lender to modify the parameters of an active loan. By setting the `ltvBPS` value to `0`, the lender can seize the collateral.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the risk of lenders modifying loan parameters to seize collateral. This is a critical vulnerability that undermines borrower trust.

**Suggestions**:  
The response should recommend restricting the ability to modify loan parameters after a loan is issued, especially for critical fields like `ltvBPS`.

---

#### **[H-05] Mistake While Checking LTV to Lender Accepted LTV**

**Report Description**:  
The `_lend()` function incorrectly checks the lender's accepted LTV against the borrower's asking LTV. The condition `params.ltvBPS >= accepted.ltvBPS` allows the lender to offer a lower LTV, which should be the opposite. This could strand the lender if they enter a lower LTV.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the logical error in the LTV check, which could lead to unfavorable loan terms for lenders.

**Suggestions**:  
The response should recommend correcting the LTV check condition to ensure the lender's accepted LTV is at least as good as the borrower's asking LTV.

---

#### **[M-01] Reentrancy at `_requestLoan` Allows Requesting a Loan Without Supplying Collateral**

**Report Description**:  
The `_requestLoan` function makes an external call to the collateral contract before updating the NFTPair contract state, potentially allowing a loan request without supplying collateral.

**Match in Response List**:  
Matches with the issue titled **""Unauthorized Loan Request via Skim""**.

**Validation**:  
**Correct**. The response accurately identifies the reentrancy risk in the `_requestLoan` function and explains how it could be exploited to request a loan without supplying collateral. This aligns with the issue description.

**Suggestions**:  
No additional suggestions. The response appropriately addresses the issue.

---

### **GPT-Generated Potential Issues (May Be Incorrect)**

#### **[R-01] Interest Calculation Precision Issues**

**Response Description**:  
The `calculateInterest` function uses a fixed-term approximation (6 iterations) for compounding interest, which may result in inaccurate calculations, especially for high APRs or long durations.

**Assessment**:  
**Valid Concern**. While this issue was not mentioned in the original `issue` report, it highlights a potential risk in the interest calculation logic. Inaccurate interest calculations could disadvantage lenders or borrowers, making this a relevant concern.

---

#### **[R-02] Expired Loan Handling in Repayment**

**Response Description**:  
The `repay` function cannot be called after the loan duration expires, forcing lenders to remove collateral directly, potentially at a loss if the collateral's market value has dropped.

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the original `issue` report but identifies a design flaw that shifts risk to lenders post-expiry. It is a valid concern that should be addressed to ensure fair loan management.

---

#### **[R-03] Front-Runnable Loan Parameter Updates**

**Response Description**:  
Borrowers can modify loan parameters (e.g., lower interest rates) while a loan is in `REQUESTED` status, which could invalidate lender expectations.

**Assessment**:  
**Valid Concern**. This issue was not mentioned in the original `issue` report but highlights a potential risk in loan parameter updates. While the response notes that lenders validate parameters during `_lend`, this could still lead to unfavorable conditions for lenders.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-01] Reentrancy at `_requestLoan` Allows Requesting a Loan Without Supplying Collateral**

**Partially Correct Matches**:

- **[H-01] Avoidance of Liquidation Via Malicious Oracle**

**Missed Issues from Issue Report**:

- **[H-02] Unchecked Return Value of `get` Function in INFTOracle Interface**
- **[H-03] Critical Oracle Manipulation Risk by Lender**
- **[H-04] Lender is Able to Seize the Collateral by Changing Loan Parameters**
- **[H-05] Mistake While Checking LTV to Lender Accepted LTV**

--- 

This analysis highlights significant gaps in the response list, particularly in addressing critical oracle-related vulnerabilities and logical errors. The GPT-generated potential issues, while not part of the original report, identify valid concerns that warrant further attention.",1,1,4,10,"Okay, let me take a look at this smart contract and try to find any vulnerabilities. I'll start by reading through the code carefully and note any potential issues.

First, the contract is an ERC721 lending pair with some complex logic around loans, collateral, and interest calculations. Let's break it down function by function.

Looking at the `updateLoanParams` function: it allows the lender or borrower to update loan parameters depending on the loan's status. There's a check for the loan status, but I should check if there's any way to manipulate the parameters to the detriment of the other party. For example, if a lender can reduce the duration after a loan is taken, that might be problematic. Wait, the code requires that the new duration is >= current duration when the loan is outstanding. So that's enforced. Hmm, maybe that's okay. But what if other parameters are changed in a way that's not safe?

Next, the `removeCollateral` function. If the loan is in REQUESTED status, the borrower can remove collateral. But once the loan is OUTSTANDING, the lender can remove collateral only if certain conditions are met. There's a check for the loan duration and whether the NFT's value is still sufficient. Wait, the code here uses the oracle to check the rate multiplied by LTV BPS. If the oracle returns a manipulated rate, maybe due to a stale price, the lender could remove collateral prematurely. That's a possible issue if the oracle isn't secure or updated.

In the `_lend` function, there's a check using the oracle's rate. If the oracle is not properly secured or can be manipulated, this could lead to undercollateralized loans. For example, if the oracle returns a higher rate than actual, the loan might be approved when it shouldn't be. So dependency on a secure oracle is critical here.

The `calculateInterest` function uses a loop up to COMPOUND_INTEREST_TERMS (which is 6). The code uses divisions which could lead to truncation errors. Also, if the loop runs multiple times with large inputs, it could consume a lot of gas. However, since COMPOUND_INTEREST_TERMS is fixed at 6, it's manageable, but the precision might be an issue. For example, if the interest calculation truncates too much, lenders might not get the correct interest.

Looking at the `repay` function: the require statement checks if startTime + duration > block.timestamp. Wait, that means the loan hasn't expired yet. But if the loan has expired, the borrower can't repay through this function. So loans that have expired might not be handled properly. The lender would need to remove collateral, but if the repayment is only allowed before expiry, that's a problem. Because normally, even after expiry, the borrower should be able to repay with penalty or something. But according to the code, if the loan is expired, repay() would revert. That could lead to issues where the lender can't get their funds back if the loan is past duration.

Another thing in `repay`: the interest is calculated based on the time from startTime to now. But if the loan is expired, this function can't be called, so the lender has to remove collateral. But when removing collateral, the code checks if the current value is still sufficient. However, if the loan is expired and the collateral's value has dropped, the lender might end up with a loss. But the code allows the lender to remove collateral only if the current value is less than the owed amount. Wait, no: the code in `removeCollateral` when the loan is OUTSTANDING and the lender is trying to remove collateral checks:

if (startTime + duration > block.timestamp) {
    ... calculate interest and check rate * ltvBPS / BPS < amount
}

But if the loan has expired (block.timestamp >= startTime + duration), this check is skipped. So the lender can remove collateral without any check. That means once the loan is expired, the lender can take the collateral even if the value is lower. That's a vulnerability because the lender could end up with collateral that's worth less than the loan, leading to a loss for the lender. Wait, no. Let me check again. When the loan is outstanding, the lender can call `removeCollateral` only if the loan is expired (since the check is skipped in that case). But when the loan is expired, the borrower hasn't repaid, so the lender can take the collateral. However, if the collateral's value has dropped, the lender might not get their principal + interest back. But that's part of the risk. However, if the code allows the lender to remove collateral even when the loan hasn't expired (if the duration hasn't passed), then there's a problem. Wait, no. The code in `removeCollateral` for the lender (when status is OUTSTANDING) checks if the duration hasn't passed. If it hasn't, then they check the oracle's rate. If it has passed, they can take the collateral without checking. So during the loan period, the lender can only take collateral if the value is too low. After the loan expires, the lender can take the collateral regardless of its value.

But maybe that's intended. However, if the oracle is not reliable or if there's a way to bypass the oracle check, that's a problem.

Another potential issue is reentrancy. Looking through the code, external calls are made via `collateral.transferFrom` and `bentoBox.transfer`, and the `_call` function which can call arbitrary addresses. However, the `_call` function has a check that callee is not bentoBox, collateral, or this contract. But if another contract is called that reenters into NFTPairWithOracle functions, could that lead to reentrancy? For example, during a cook action that does a call, which then calls back into cook. Since the state is updated before the call, maybe not. But need to check for any functions that are vulnerable.

Looking at the `cook` function, which processes multiple actions. Each action is executed in sequence. If during an action, a malicious contract is called that reenters into the cook function, it could potentially manipulate the state. For example, during a repay action, but the state is deleted before the transfer. Wait, in `repay`, after calculating the amounts, the code deletes the tokenLoan[tokenId], then transfers the collateral back. So if the collateral transfer is to a malicious contract that reenters, the loan would already be marked as repaid. So reentrancy here might not be an issue. But other functions like `removeCollateral` also delete the loan data before transferring. So maybe the code is safe from reentrancy because state changes are done before external calls. However, the `_call` function allows arbitrary calls, which could interact with other functions. But the checks in `_call` prevent calling bentoBox, collateral, or the contract itself. Wait, no: the check is callee != address(bentoBox), etc. So any other contracts can be called. If such a contract calls back into this contract, is there any vulnerability? For example, if during a call action, the external contract calls `repay` again. But since the state is updated after each step, maybe not. Need to check if any functions are vulnerable to reentrancy in between state changes.

Another thing: the `calculateInterest` function uses a loop with fixed iterations (up to 6), so gas shouldn't be a problem here. But the function can revert if the interest is >= 2^128. However, that's a check after the calculation. If the interest overflows, it would revert. But with the parameters, maybe that's handled.

Looking at the signature verification in `requestAndBorrow` and `takeCollateralAndLend`: they use ecrecover to verify the signature. There's a potential for signature malleability if the signature isn't checked properly. However, the code uses the _getDigest which includes the domain separator, so that's probably safe. But nonce is used per user, so replay attacks on different contracts or different users are prevented. But what if the same signature is used on different instances of this contract? The dataHash includes the address(this), so signatures are specific to the contract instance, so that's okay.

Another possible issue is in the `init` function: it can only be called once, as it checks that collateral is address(0). So that's okay.

In the `requestLoan` and `_requestLoan` functions, when the collateral is transferred in, they use `skim` to check if the collateral is already in the contract. But if `skim` is true, they require that the collateral is owned by the contract. However, there's a possible front-running attack where someone transfers the token to the contract before the function is called, making the `skim` succeed even though the user didn't own it. But the `requestLoan` function is called by the user, so if they set `skim` to true, but the token wasn't theirs, then the collateral is taken from the contract's balance. That's a problem if the user doesn't own the token. So `skim` should only be allowed if the caller is the owner of the token. But the code doesn't check that. Wait, in `_requestLoan`, when `skim` is true, it checks that the collateral.ownerOf(tokenId) is address(this). But if someone else's token is already in the contract, then another user can call requestLoan with skim=true and tokenId, effectively using someone else's collateral. That's a major vulnerability. For example, if Alice deposits her NFT as collateral, and then Bob sees that and calls requestLoan with skim=true for that tokenId, he can initiate a loan using Alice's collateral. Then Bob would be the borrower, and when the loan is taken, the lender would send funds to Bob. But the collateral was Alice's. So this allows anyone to create a loan using any token already in the contract, regardless of ownership. That's a critical issue.

Another issue: in `removeCollateral`, when the loan is in REQUESTED status, the borrower can remove the collateral. But if the borrower is a malicious actor who front-runs the lender's `lend` transaction, they could remove the collateral before the loan is processed, leading to the lender sending funds but not getting the collateral. However, since in REQUESTED status, the borrower can remove the collateral at any time, which would cancel the loan request. That's a design choice, but could be a problem if not handled properly in the frontend.

In the `cook` function, multiple actions can be executed. The `ACTION_CALL` allows arbitrary calls to external contracts. If a user is allowed to call this with a malicious contract, it could drain funds. However, the `_call` function checks that the callee is not bentoBox, collateral, or this contract. But if the callee is another contract, like a token, the user could approve transfers or perform other actions. However, since the cook function is called with msg.sender as the user, any calls made would be on behalf of the user's bentoBox approvals. So if the user's bentoBox allowances are set, the call could transfer tokens. But the `cook` function is designed to allow complex interactions. The risk here is that if a user is tricked into calling a malicious cook action that does a call to a harmful contract, but that's more of a phishing issue rather than a contract vulnerability.

In the `takeCollateralAndLend` function, the `_requestLoan` is called with `borrower` as the collateral provider. But if the borrower doesn't actually own the token, but the function is called with `skim` as false, it would attempt to transfer the token from the borrower to the contract. If the borrower doesn't own it, the transfer would fail. However, in this function, `_requestLoan` is called with `skim` as false, so the code would try to transfer the collateral from the borrower to the contract. If the borrower doesn't own the token, this would revert. So that's safe.

Another issue: the `calculateInterest` function's formula. It's trying to compute compound interest, but the code seems to be using a Taylor series expansion. Let me check:

The code has a loop from k=2 to COMPOUND_INTEREST_TERMS (6). For each term, term_k is (term_k * x) / denom_k. The initial term is (principal * x) / YEAR_BPS, where x is t * aprBPS. The denom for k=2 is YEAR_BPS + YEAR_BPS? Wait, no. denom_k starts at YEAR_BPS, then for each k, denom_k += YEAR_BPS. Wait, let's see:

For k=1: term_1 = (principal * x)/YEAR_BPS. denom_1 = YEAR_BPS.

For k=2: term_2 = (term_1 * x)/(YEAR_BPS + YEAR_BPS). Because denom_k is increased by YEAR_BPS each step. So denom_2 = YEAR_BPS * 2.

For k=3: denom_3 = YEAR_BPS *3, etc.

This is actually the expansion of principal * (e^(x/YEAR_BPS) -1). Wait, but the Taylor series for e^y is 1 + y + y^2/2! + y^3/3! + ... So if each term is (principal * y^k)/k! where y = (t * aprBPS)/YEAR_BPS. But in the code, it's calculated as (principal * x)/YEAR_BPS + (principal * x^2)/(YEAR_BPS^2 * 2) + ... which matches the series. So the code is approximating e^(x/YEAR_BPS) - 1, multiplied by principal. But since COMPOUND_INTEREST_TERMS is 6, this is an approximation. The problem is whether this approximation is correct and if truncating after 6 terms could lead to under/overestimation. However, the code may be intended to use this approximation, but if the APR is high or the duration is long, the approximation might not be accurate. But this is more of a precision issue rather than a vulnerability.

Another possible issue: in the `removeCollateral` function, after the loan is deleted, the collateral is transferred to the lender. However, if the loan was in OUTSTANDING status and the duration has passed, the lender can take the collateral. But the protocol doesn't ensure that the lender is repaid. So the lender can take the collateral once the loan expires, which is standard in many lending protocols (like NFT pawn shops). So this is by design.

But what if the lender removes collateral before the loan expires? In the code, when the loan is outstanding and the duration hasn't passed, the lender can only remove collateral if the current value (from oracle) * ltvBPS / BPS is less than the owed amount (principal + interest). However, if the oracle is manipulated or returns a lower value, the lender could remove the collateral even if the actual value is sufficient. So the security here relies heavily on the oracle's correctness.

So summarizing the possible vulnerabilities:

1. **Unauthorized Loan Request via Skim**: When `skim` is set to true in `requestLoan`, the contract checks if the collateral is already present. However, if another user's collateral is already in the contract, any user can create a loan request using that collateral. This allows stealing of others' collateral by initiating a loan without owning the NFT.

2. **Oracle Manipulation**: The contract relies on an external oracle (`INFTOracle`) to determine the NFT's value. If the oracle is compromised, returns stale data, or can be manipulated, loans could be undercollateralized, leading to losses.

3. **Interest Calculation Precision**: The `calculateInterest` function uses a fixed number of terms for approximation, which may lead to inaccuracies in interest calculation, especially for high APRs or long durations. This could result in incorrect interest amounts, affecting lenders or borrowers.

4. **Loan Expiry Handling**: The `repay` function can only be called before the loan expires. After expiry, the lender can remove collateral without repaying, which might be intended, but if the loan's value is higher than the collateral's market value, lenders could incur losses. However, this is part of the lending risk.

5. **Signature Replay Across Contracts**: Signatures in `requestAndBorrow` and `takeCollateralAndLend` use `address(this)` in the hash, preventing cross-contract replays. But if multiple instances of the contract are deployed with the same parameters, signatures intended for one could be used on another. However, since the domain includes the contract's address, this is mitigated.

6. **Reentrancy in External Calls**: The `cook` function allows arbitrary calls via `ACTION_CALL`. While the current checks prevent calling critical contracts, a malicious external call could reenter the contract in a different function. However, state changes are done before the call, reducing the risk. Need to check if any state is inconsistent during the call.

7. **Insufficient Validation in Loan Parameters Update**: When updating loan parameters via `updateLoanParams`, certain conditions are checked. However, if parameters are updated after a loan is taken, could they be made worse for the counterparty? The code checks that the new parameters are better or equal (e.g., duration can't be decreased, valuation can't be increased). So if a lender reduces the duration after the loan is taken, but the code requires params.duration >= cur.duration, that's okay. So parameters can only be updated to be more favorable to the borrower.

Wait, when a loan is in OUTSTANDING status, the lender can update the parameters. The code requires that the new duration is >= current duration, valuation <= current, annualInterestBPS <= current, and ltvBPS <= current. So the lender can only make the terms better for the borrower (lower interest, longer duration, lower valuation, lower LTV). But why would a lender do that? It could be a mistake or an attack. For example, reducing the interest rate after the loan is taken, allowing the borrower to repay less. This could be a vulnerability if the lender's account is compromised, allowing an attacker to worsen the terms for the lender. However, this requires the lender's private key to be compromised. So the vulnerability here is that once a loan is outstanding, the lender can worsen their own terms, but that's up to their own risk. The code allows it, but maybe it's intended for flexibility. However, it's a potential issue if not properly handled by the frontend.

Another possible issue: **Front-Running Loan Requests**. A borrower could front-run a lender's transaction to modify loan parameters or remove collateral before the lender can fund the loan. For example, a borrower requests a loan, a lender sends a transaction to lend, but the borrower front-runs with updating the parameters to worse terms for the lender. However, in the code, once a loan is in REQUESTED status, the borrower can update the parameters. If a lender is about to lend based on initial parameters, the borrower could change them to worse terms. This would require the lender's transaction to check the parameters again when processing. Wait, in the `_lend` function, it checks that the stored params match the accepted params. So when the lender calls `lend`, they pass the `accepted` params, which must match the stored params. If the borrower changed the params after the lender initiated the transaction, the lender's transaction would fail because the stored params no longer meet the accepted params. So this is protected against front-running because the lender's transaction checks the current params against their accepted terms. Thus, the borrower cannot front-run to change params after the lender's transaction is sent. That's handled.

Another thing: **Fee Calculation in Lend Function**. The code calculates openFeeShare and protocolFeeShare. If the math here is incorrect, it could lead to loss of funds. For example, `openFeeShare` is (totalShare * OPEN_FEE_BPS) / BPS. Then protocolFeeShare is (openFeeShare * PROTOCOL_FEE_BPS) / BPS. So the protocol takes a portion of the open fee. Then the borrower gets totalShare - openFeeShare. However, if the percentages are miscalculated, but assuming the constants are correct (OPEN_FEE_BPS=100, PROTOCOL_FEE_BPS=1000), then open fee is 1%, protocol fee is 10% of that (0.1% total). That seems correct.

**Token Loan Params Storage Collision**: The `tokenLoanParams` is a mapping from tokenId to the struct. Since ERC721 tokens are unique, each tokenId should have its own loan params. No collision here.

**Uninitialized Master Contract**: The `masterContract` is set to `this` in the constructor. But when using clones or proxies, the master contract should not be initialized. However, the `init` function is called once, and the contract uses `BoringOwnable`, which is from the boring-solidity library. If this contract is meant to be used as a master contract for cloning, the initializer pattern is correct. But the constructor sets masterContract to itself, which might not be intended. Wait, in the code, the masterContract is an immutable variable set to `this` in the constructor. Then, in the `init` function, the masterContract is the same as the deployed contract. But if this is a master contract that's meant to be cloned, each clone would have `masterContract` pointing to the original. However, the `init` function is called on the clone, and the code checks that collateral is address(0) before initializing. So maybe this is intended. However, if the contract is deployed directly (not as a clone), then the masterContract is the contract itself. This might not be an issue, but depends on the deployment setup.

**Missing Access Control in withdrawFees**: The `withdrawFees` function is public, so anyone can call it. However, it transfers the fees to `feeTo` address. If the feeTo is set, calling this function would send the fees to feeTo. But since it's a public function, anyone can trigger the transfer. However, this is not a vulnerability per se, as it's just sending the fees to the designated address. The funds are sent correctly regardless of who calls it. So no issue here.

**Division Truncation**: Several divisions (e.g., in `calculateInterest`, fee calculations) use integer division which truncates. This could lead to small inaccuracies. For example, protocolFeeShare is (openFeeShare * PROTOCOL_FEE_BPS) / BPS. If the multiplication isn't a multiple of BPS, it truncates. However, this is common in Solidity and usually accepted.

**Use of Deprecated SafeMath**: The code uses BoringMath which is a SafeMath library. Since Solidity 0.8.x has built-in overflow checks, but the pragma is 0.6.12, so SafeMath is necessary. No vulnerability here, but the code is using an older compiler version which might have other issues.

**ERC721 Reentrancy**: When transferring ERC721 tokens, the `transferFrom` function is used. If the collateral is a malicious ERC721 contract that calls back into the lending contract, could this cause issues? For example, during `removeCollateral`, after deleting the loan data, the contract transfers the NFT. If the NFT's `transferFrom` function calls back into the contract, the state has already been updated, so reentrancy would not affect the loan data. Therefore, this is safe.

**Lack of Event Emission for Critical Actions**: Some critical actions should emit events for tracking. For example, updating loan parameters emits an event. Other functions like `removeCollateral` and repay emit events. Seems comprehensive.

**Potential Front-Running in Lending**: When a lender lends, they have to ensure that the loan parameters haven't changed since they agreed. The code checks the current parameters against the accepted parameters, which prevents front-running. So if a borrower changes the parameters after the lender's check, the transaction fails. So that's mitigated.

**Possible Integer Overflow/Underflow**: The code uses SafeMath (BoringMath), so overflows/underflows are prevented. So no issues here.

In summary, the main vulnerabilities I can spot are:

1. **Unauthorized Loan Request via Skim**: Skim allows using any collateral already in the contract, which can be exploited if another user's NFT is present.

2. **Reliance on External Oracle**: If the oracle is compromised or manipulated, loans can be undercollateralized.

3. **Incorrect Interest Calculation**: The approximation might lead to inaccuracies affecting lenders or borrowers.

4. **Loan Expiry Handling**: Repay is blocked after expiry, forcing lenders to take collateral which might have depreciated.

But the question is to list vulnerabilities without mitigation. So these are the main ones.","```
1. Unauthorized Loan Request via Skim
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Unauthorized Loan Request via Skim"".
   - It appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
