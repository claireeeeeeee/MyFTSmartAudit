nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
NestedFactory.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Multicall.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""./libraries/ExchangeHelpers.sol"";
import ""./libraries/OperatorHelpers.sol"";
import ""./interfaces/external/IWETH.sol"";
import ""./interfaces/INestedFactory.sol"";
import ""./FeeSplitter.sol"";
import ""./MixinOperatorResolver.sol"";
import ""./NestedReserve.sol"";
import ""./NestedAsset.sol"";
import ""./NestedRecords.sol"";

/// @title Creates, updates and destroys NestedAssets.
/// @notice Responsible for the business logic of the protocol and interaction with operators
contract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {
    using SafeERC20 for IERC20;
    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Supported operators by the factory contract
    bytes32[] private operators;

    /// @dev Current feeSplitter contract/address
    FeeSplitter public feeSplitter;

    /// @dev Current reserve contract/address
    NestedReserve public reserve;

    NestedAsset public immutable nestedAsset;
    IWETH public immutable weth;
    NestedRecords public immutable nestedRecords;

    constructor(
        NestedAsset _nestedAsset,
        NestedRecords _nestedRecords,
        FeeSplitter _feeSplitter,
        IWETH _weth,
        address _operatorResolver
    ) MixinOperatorResolver(_operatorResolver) {
        nestedAsset = _nestedAsset;
        nestedRecords = _nestedRecords;
        feeSplitter = _feeSplitter;
        weth = _weth;
    }

    /// @dev Reverts the transaction if the caller is not the token owner
    /// @param _nftId The NFT Id
    modifier onlyTokenOwner(uint256 _nftId) {
        require(nestedAsset.ownerOf(_nftId) == _msgSender(), ""NestedFactory: Not the token owner"");
        _;
    }

    /// @dev Reverts the transaction if the nft is locked (hold by design).
    /// The block.timestamp must be greater than NFT record lock timestamp
    /// @param _nftId The NFT Id
    modifier isUnlocked(uint256 _nftId) {
        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), ""NestedFactory: The NFT is currently locked"");
        _;
    }

    /// @dev Receive function
    receive() external payable {}

    /// @notice Get the required operator addresses
    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        return operators;
    }

    /// @inheritdoc INestedFactory
    function addOperator(bytes32 operator) external override onlyOwner {
        operators.push(operator);
    }

    /// @inheritdoc INestedFactory
    function removeOperator(bytes32 operator) external override onlyOwner {
        uint256 i = 0;
        while (operators[i] != operator) {
            i++;
        }
        require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
        delete operators[i];
    }

    /// @inheritdoc INestedFactory
    function setReserve(NestedReserve _reserve) external override onlyOwner {
        require(address(reserve) == address(0), ""NestedFactory::setReserve: Reserve is immutable"");
        reserve = _reserve;
        emit ReserveUpdated(address(_reserve));
    }

    /// @inheritdoc INestedFactory
    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {
        require(address(_feeSplitter) != address(0), ""NestedFactory::setFeeSplitter: Invalid feeSplitter address"");
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(address(_feeSplitter));
    }

    /// @inheritdoc INestedFactory
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant {
        require(_orders.length > 0, ""NestedFactory::create: Missing orders"");

        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);
        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);

        _transferFeeWithRoyalty(fees, tokenSold, nftId);
        emit NftCreated(nftId, _originalTokenId);
    }

    /// @inheritdoc INestedFactory
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant onlyTokenOwner(_nftId) {
        require(_orders.length > 0, ""NestedFactory::addTokens: Missing orders"");

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);
        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::swapTokenForTokens: Missing orders"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::swapTokenForTokens: Assets in different reserve""
        );

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToNft: Missing orders"");
        require(_sellTokensAmount.length == _orders.length, ""NestedFactory::sellTokensToNft: Input lengths must match"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToNft: Assets in different reserve""
        );

        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToWallet: Missing orders"");
        require(
            _sellTokensAmount.length == _orders.length,
            ""NestedFactory::sellTokensToWallet: Input lengths must match""
        );
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToWallet: Assets in different reserve""
        );

        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(
            _nftId,
            _buyToken,
            _sellTokensAmount,
            _orders,
            false,
            true
        );
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);
        require(_orders.length > 0, ""NestedFactory::destroy: Missing orders"");
        require(tokens.length == _orders.length, ""NestedFactory::destroy: Missing sell args"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::destroy: Assets in different reserve""
        );

        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));

        for (uint256 i = 0; i < tokens.length; i++) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);
            reserve.withdraw(IERC20(holding.token), holding.amount);

            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);
            nestedRecords.freeHolding(_nftId, tokens[i]);
        }

        // Amount calculation to send fees and tokens
        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;
        uint256 amountFees = _calculateFees(_msgSender(), amountBought);
        amountBought = amountBought - amountFees;

        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());

        // Burn NFT
        nestedRecords.removeNFT(_nftId);
        nestedAsset.burn(_msgSender(), _nftId);
        emit NftBurned(_nftId);
    }

    /// @inheritdoc INestedFactory
    function withdraw(uint256 _nftId, uint256 _tokenIndex)
        external
        override
        nonReentrant
        onlyTokenOwner(_nftId)
        isUnlocked(_nftId)
    {
        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);
        require(assetTokensLength > _tokenIndex, ""NestedFactory::withdraw: Invalid token index"");
        // Use destroy instead if NFT has a single holding
        require(assetTokensLength > 1, ""NestedFactory::withdraw: Can't withdraw the last asset"");

        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(
            _nftId,
            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]
        );
        reserve.withdraw(IERC20(holding.token), holding.amount);
        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);

        nestedRecords.deleteAsset(_nftId, _tokenIndex);

        emit NftUpdated(_nftId);
    }

    /// @inheritdoc INestedFactory
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {
        nestedRecords.updateLockTimestamp(_nftId, _timestamp);
    }

    /// @inheritdoc INestedFactory
    function unlockTokens(IERC20 _token) external override onlyOwner {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit buy orders (where the input is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _inputToken Token used to make the orders
    /// @param _inputTokenAmount Amount of input tokens to use
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)
    function _submitInOrders(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, IERC20 tokenSold) {
        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);
        uint256 amountSpent;
        for (uint256 i = 0; i < _orders.length; i++) {
            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);
        }
        feesAmount = _calculateFees(_msgSender(), amountSpent);
        assert(amountSpent <= _inputTokenAmount - feesAmount); // overspent

        // If input is from the reserve, update the records
        if (_fromReserve) {
            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);
        }

        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);

        tokenSold = _inputToken;
    }

    /// @dev For every orders, call the operator with the calldata
    /// to submit sell orders (where the output is one asset).
    /// @param _nftId The id of the NFT impacted by the orders
    /// @param _outputToken Token received for every orders
    /// @param _inputTokenAmounts Amounts of tokens to use (respectively with Orders)
    /// @param _orders Orders calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    /// @param _fromReserve True if the input tokens are from the reserve
    /// @return feesAmount The total amount of fees
    /// @return amountBought The total amount bought
    function _submitOutOrders(
        uint256 _nftId,
        IERC20 _outputToken,
        uint256[] memory _inputTokenAmounts,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, uint256 amountBought) {
        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));

        for (uint256 i = 0; i < _orders.length; i++) {
            IERC20 _inputToken = _transferInputTokens(
                _nftId,
                IERC20(_orders[i].token),
                _inputTokenAmounts[i],
                _fromReserve
            );

            // Submit order and update holding of spent token
            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);
            assert(amountSpent <= _inputTokenAmounts[i]);

            if (_fromReserve) {
                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);
            }

            // Under spent input amount send to fee splitter
            if (_inputTokenAmounts[i] - amountSpent > 0) {
                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);
            }
        }

        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;
        feesAmount = _calculateFees(_msgSender(), amountBought);

        if (_reserved) {
            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);
        }
    }

    /// @dev Call the operator to submit the order (commit/revert) and add the output
    /// assets to the reserve (if needed).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _nftId The nftId
    /// @param _order The order calldata
    /// @param _reserved True if the output is store in the reserve/records, false if not.
    function _submitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _nftId,
        Order calldata _order,
        bool _reserved
    ) private returns (uint256 amountSpent) {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        require(success, ""NestedFactory::_submitOrder: Operator call failed"");

        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
            data,
            _inputToken,
            _outputToken
        );

        if (_reserved) {
            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);
        }
        amountSpent = amounts[1];
    }

    /// @dev Call the operator to submit the order (commit/revert) but dont stop if
    /// the call to the operator fail. It will send the input token back to the msg.sender.
    /// Note : The _reserved Boolean has been removed (compare to _submitOrder) since it was
    ///        useless for the only use case (destroy).
    /// @param _inputToken Token used to make the orders
    /// @param _outputToken Expected output token
    /// @param _amountToSpend The input amount available (to spend)
    /// @param _nftId The nftId
    /// @param _order The order calldata
    function _safeSubmitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _amountToSpend,
        uint256 _nftId,
        Order calldata _order
    ) private {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        if (success) {
            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
                data,
                _inputToken,
                _outputToken
            );
            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));
        } else {
            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);
        }
    }

    /// @dev Transfer tokens to the reserve, and compute the amount received to store
    /// in the records. We need to know the amount received in case of deflationary tokens.
    /// @param _token The token address
    /// @param _amount The amount to send to the reserve
    /// @param _nftId The Token ID to store the assets
    function _transferToReserveAndStore(
        address _token,
        uint256 _amount,
        uint256 _nftId
    ) private {
        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));

        // Send output to reserve
        IERC20(_token).safeTransfer(address(reserve), _amount);

        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));

        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));
    }

    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve
    ///      or the user wallet, to the factory.
    /// @param _nftId The NFT id
    /// @param _inputToken The token to receive
    /// @param _inputTokenAmount Amount to transfer
    /// @param _fromReserve True to transfer from the reserve
    /// @return tokenUsed Token transfered (in case of ETH)
    function _transferInputTokens(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        bool _fromReserve
    ) private returns (IERC20 tokenUsed) {
        if (_fromReserve) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));
            require(holding.amount >= _inputTokenAmount, ""NestedFactory:_transferInputTokens: Insufficient amount"");

            // Get input from reserve
            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);
        } else if (address(_inputToken) == ETH) {
            require(msg.value == _inputTokenAmount, ""NestedFactory::_transferInputTokens: Insufficient amount in"");
            weth.deposit{ value: msg.value }();
            _inputToken = IERC20(address(weth));
        } else {
            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);
        }
        tokenUsed = _inputToken;
    }

    /// @dev Send the under spent amount to the FeeSplitter without the royalties.
    ///      The ""under spent"" amount is the positive difference between the amount supposed
    ///      to be spent and the amount really spent.
    /// @param _amountToSpent The amount supposed to be spent
    /// @param _amountSpent The amount really spent
    /// @param _token The amount-related token
    function _handleUnderSpending(
        uint256 _amountToSpent,
        uint256 _amountSpent,
        IERC20 _token
    ) private {
        if (_amountToSpent - _amountSpent > 0) {
            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);
        }
    }

    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset
    /// @param _amount Amount to send
    /// @param _token Token to send
    /// @param _nftId User portfolio ID used to find a potential royalties recipient
    function _transferFeeWithRoyalty(
        uint256 _amount,
        IERC20 _token,
        uint256 _nftId
    ) private {
        address originalOwner = nestedAsset.originalOwner(_nftId);
        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
        if (originalOwner != address(0)) {
            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);
        } else {
            feeSplitter.sendFees(_token, _amount);
        }
    }

    /// @dev Decrease the amount of a NFT holding
    /// @param _nftId The NFT id
    /// @param _inputToken The token holding
    /// @param _amount The amount to subtract from the actual holding amount
    function _decreaseHoldingAmount(
        uint256 _nftId,
        address _inputToken,
        uint256 _amount
    ) private {
        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);
        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);
    }

    /// @dev Transfer a token amount from the factory to the recipient.
    ///      The token is unwrapped if WETH.
    /// @param _token The token to transfer
    /// @param _amount The amount to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferAndUnwrap(
        IERC20 _token,
        uint256 _amount,
        address _dest
    ) private {
        // if buy token is WETH, unwrap it instead of transferring it to the sender
        if (address(_token) == address(weth)) {
            IWETH(weth).withdraw(_amount);
            (bool success, ) = _dest.call{ value: _amount }("""");
            require(success, ""ETH_TRANSFER_ERROR"");
        } else {
            _token.safeTransfer(_dest, _amount);
        }
    }

    /// @dev Transfer from factory and collect fees
    /// @param _token The token to transfer
    /// @param _amount The amount (with fees) to transfer
    /// @param _dest The address receiving the funds
    function _safeTransferWithFees(
        IERC20 _token,
        uint256 _amount,
        address _dest,
        uint256 _nftId
    ) private {
        uint256 feeAmount = _calculateFees(_dest, _amount);
        _transferFeeWithRoyalty(feeAmount, _token, _nftId);
        _token.safeTransfer(_dest, _amount - feeAmount);
    }

    /// @dev Calculate the fees for a specific user and amount (1%)
    /// @param _user The user address
    /// @param _amount The amount
    /// @return The fees amount
    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {
        return _amount / 100;
    }
}",5567.0,562.0,"[H-01] Copy your own portfolio to keep earning royalties
In NestedFactory.sol going through the `create()` function which leads to the `sendFeesWithRoyalties()` => `addShares()` function, Im not seeing any checks preventing someone from copying their own portfolio and receiving royalty shares for it and simply repeating the process over and over again.
 
[M-01] setReserve() can be front-run
The `reserve` address variable in NestedFactory.sol remains equal to 0 before the `setReserve()` function is called by an owner. This may lead to incorrect transfers of tokens or invalid comparison with e.g., the asset reserve (`nestedRecords.getAssetReserve(_nftId) == address(reserve)`), should they occur before the value for reserve was set. In addition, the immutabiliy of the `reserve` variable requires extra caution when setting the value.
Proof of Concept

 [M-06] NestedFactory.sol#_submitInOrders() Wrong implementation cause users to be overcharged
Function `_submitInOrders`
When executing orders, the actual `amountSpent + feesAmount` can be lower than `_inputTokenAmount`, the unspent amount should be returned to the user.
However, in the current implementation, the unspent amount will be taken as part of the fee. NestedFactory.sol L285-L309
  [M-07] Ensure on-chain that cache is synced
Currently, many core operations (like `NestedFactory.create()`, `NestedFactory.swapTokenForTokens()`) are dependent on the assumption that the cache is synced before these functions are executed however this may not necessarily be the case.
  [M-08] Passing multiple ETH deposits in orders array will use the same `msg.value` many times
Contract holdings can be emptied as malicious user will do deposit/withdraw to extract value. This is possible because after `transferInputTokens` system uses contract balance for user's operations, assuming that equivalent value was transferred. `msg.value` persist over calls, so passing 'Order[] calldata _orders' holding multiple ETH deposits will use the same msg.value in each of them, resulting in multiple deposits, that sums up to much bigger accounted value than actually deposited value, up to contract's ETH holdings.",5.0,"pragma solidity 0.8.9;

import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/utils/Multicall.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";
import ""./libraries/ExchangeHelpers.sol"";
import ""./libraries/OperatorHelpers.sol"";
import ""./interfaces/external/IWETH.sol"";
import ""./interfaces/INestedFactory.sol"";
import ""./FeeSplitter.sol"";
import ""./MixinOperatorResolver.sol"";
import ""./NestedReserve.sol"";
import ""./NestedAsset.sol"";
import ""./NestedRecords.sol"";



contract NestedFactory is INestedFactory, ReentrancyGuard, Ownable, MixinOperatorResolver, Multicall {
    using SafeERC20 for IERC20;
    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    
    bytes32[] private operators;

    
    FeeSplitter public feeSplitter;

    
    NestedReserve public reserve;

    NestedAsset public immutable nestedAsset;
    IWETH public immutable weth;
    NestedRecords public immutable nestedRecords;

    constructor(
        NestedAsset _nestedAsset,
        NestedRecords _nestedRecords,
        FeeSplitter _feeSplitter,
        IWETH _weth,
        address _operatorResolver
    ) MixinOperatorResolver(_operatorResolver) {
        nestedAsset = _nestedAsset;
        nestedRecords = _nestedRecords;
        feeSplitter = _feeSplitter;
        weth = _weth;
    }

    
    
    modifier onlyTokenOwner(uint256 _nftId) {
        require(nestedAsset.ownerOf(_nftId) == _msgSender(), ""NestedFactory: Not the token owner"");
        _;
    }

    
    
    
    modifier isUnlocked(uint256 _nftId) {
        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), ""NestedFactory: The NFT is currently locked"");
        _;
    }

    
    receive() external payable {}

    
    function resolverAddressesRequired() public view override returns (bytes32[] memory addresses) {
        return operators;
    }

    
    function addOperator(bytes32 operator) external override onlyOwner {
        operators.push(operator);
    }

    
    function removeOperator(bytes32 operator) external override onlyOwner {
        uint256 i = 0;
        while (operators[i] != operator) {
            i++;
        }
        require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
        delete operators[i];
    }

    
    function setReserve(NestedReserve _reserve) external override onlyOwner {
        require(address(reserve) == address(0), ""NestedFactory::setReserve: Reserve is immutable"");
        reserve = _reserve;
        emit ReserveUpdated(address(_reserve));
    }

    
    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {
        require(address(_feeSplitter) != address(0), ""NestedFactory::setFeeSplitter: Invalid feeSplitter address"");
        feeSplitter = _feeSplitter;
        emit FeeSplitterUpdated(address(_feeSplitter));
    }

    
    function create(
        uint256 _originalTokenId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant {
        require(_orders.length > 0, ""NestedFactory::create: Missing orders"");

        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);
        (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _sellToken, _sellTokenAmount, _orders, true, false);

        _transferFeeWithRoyalty(fees, tokenSold, nftId);
        emit NftCreated(nftId, _originalTokenId);
    }

    
    function addTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external payable override nonReentrant onlyTokenOwner(_nftId) {
        require(_orders.length > 0, ""NestedFactory::addTokens: Missing orders"");

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, false);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);
        emit NftUpdated(_nftId);
    }

    
    function swapTokenForTokens(
        uint256 _nftId,
        IERC20 _sellToken,
        uint256 _sellTokenAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::swapTokenForTokens: Missing orders"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::swapTokenForTokens: Assets in different reserve""
        );

        (uint256 fees, IERC20 tokenSold) = _submitInOrders(_nftId, _sellToken, _sellTokenAmount, _orders, true, true);
        _transferFeeWithRoyalty(fees, tokenSold, _nftId);

        emit NftUpdated(_nftId);
    }

    
    function sellTokensToNft(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToNft: Missing orders"");
        require(_sellTokensAmount.length == _orders.length, ""NestedFactory::sellTokensToNft: Input lengths must match"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToNft: Assets in different reserve""
        );

        (uint256 feesAmount, ) = _submitOutOrders(_nftId, _buyToken, _sellTokensAmount, _orders, true, true);
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);

        emit NftUpdated(_nftId);
    }

    
    function sellTokensToWallet(
        uint256 _nftId,
        IERC20 _buyToken,
        uint256[] memory _sellTokensAmount,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        require(_orders.length > 0, ""NestedFactory::sellTokensToWallet: Missing orders"");
        require(
            _sellTokensAmount.length == _orders.length,
            ""NestedFactory::sellTokensToWallet: Input lengths must match""
        );
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::sellTokensToWallet: Assets in different reserve""
        );

        (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(
            _nftId,
            _buyToken,
            _sellTokensAmount,
            _orders,
            false,
            true
        );
        _transferFeeWithRoyalty(feesAmount, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought - feesAmount, _msgSender());

        emit NftUpdated(_nftId);
    }

    
    function destroy(
        uint256 _nftId,
        IERC20 _buyToken,
        Order[] calldata _orders
    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {
        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);
        require(_orders.length > 0, ""NestedFactory::destroy: Missing orders"");
        require(tokens.length == _orders.length, ""NestedFactory::destroy: Missing sell args"");
        require(
            nestedRecords.getAssetReserve(_nftId) == address(reserve),
            ""NestedFactory::destroy: Assets in different reserve""
        );

        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));

        for (uint256 i = 0; i < tokens.length; i++) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, tokens[i]);
            reserve.withdraw(IERC20(holding.token), holding.amount);

            _safeSubmitOrder(tokens[i], address(_buyToken), holding.amount, _nftId, _orders[i]);
            nestedRecords.freeHolding(_nftId, tokens[i]);
        }

        
        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;
        uint256 amountFees = _calculateFees(_msgSender(), amountBought);
        amountBought = amountBought - amountFees;

        _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);
        _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());

        
        nestedRecords.removeNFT(_nftId);
        nestedAsset.burn(_msgSender(), _nftId);
        emit NftBurned(_nftId);
    }

    
    function withdraw(uint256 _nftId, uint256 _tokenIndex)
        external
        override
        nonReentrant
        onlyTokenOwner(_nftId)
        isUnlocked(_nftId)
    {
        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);
        require(assetTokensLength > _tokenIndex, ""NestedFactory::withdraw: Invalid token index"");
        
        require(assetTokensLength > 1, ""NestedFactory::withdraw: Can't withdraw the last asset"");

        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(
            _nftId,
            nestedRecords.getAssetTokens(_nftId)[_tokenIndex]
        );
        reserve.withdraw(IERC20(holding.token), holding.amount);
        _safeTransferWithFees(IERC20(holding.token), holding.amount, _msgSender(), _nftId);

        nestedRecords.deleteAsset(_nftId, _tokenIndex);

        emit NftUpdated(_nftId);
    }

    
    function increaseLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {
        nestedRecords.updateLockTimestamp(_nftId, _timestamp);
    }

    
    function unlockTokens(IERC20 _token) external override onlyOwner {
        _token.transfer(owner(), _token.balanceOf(address(this)));
    }

    
    
    
    
    
    
    
    
    
    
    function _submitInOrders(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, IERC20 tokenSold) {
        _inputToken = _transferInputTokens(_nftId, _inputToken, _inputTokenAmount, _fromReserve);
        uint256 amountSpent;
        for (uint256 i = 0; i < _orders.length; i++) {
            amountSpent += _submitOrder(address(_inputToken), _orders[i].token, _nftId, _orders[i], _reserved);
        }
        feesAmount = _calculateFees(_msgSender(), amountSpent);
        assert(amountSpent <= _inputTokenAmount - feesAmount); 

        
        if (_fromReserve) {
            _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount);
        }

        _handleUnderSpending(_inputTokenAmount - feesAmount, amountSpent, _inputToken);

        tokenSold = _inputToken;
    }

    
    
    
    
    
    
    
    
    
    
    function _submitOutOrders(
        uint256 _nftId,
        IERC20 _outputToken,
        uint256[] memory _inputTokenAmounts,
        Order[] calldata _orders,
        bool _reserved,
        bool _fromReserve
    ) private returns (uint256 feesAmount, uint256 amountBought) {
        uint256 _outputTokenInitialBalance = _outputToken.balanceOf(address(this));

        for (uint256 i = 0; i < _orders.length; i++) {
            IERC20 _inputToken = _transferInputTokens(
                _nftId,
                IERC20(_orders[i].token),
                _inputTokenAmounts[i],
                _fromReserve
            );

            
            uint256 amountSpent = _submitOrder(address(_inputToken), address(_outputToken), _nftId, _orders[i], false);
            assert(amountSpent <= _inputTokenAmounts[i]);

            if (_fromReserve) {
                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmounts[i]);
            }

            
            if (_inputTokenAmounts[i] - amountSpent > 0) {
                _transferFeeWithRoyalty(_inputTokenAmounts[i] - amountSpent, _inputToken, _nftId);
            }
        }

        amountBought = _outputToken.balanceOf(address(this)) - _outputTokenInitialBalance;
        feesAmount = _calculateFees(_msgSender(), amountBought);

        if (_reserved) {
            _transferToReserveAndStore(address(_outputToken), amountBought - feesAmount, _nftId);
        }
    }

    
    
    
    
    
    
    
    function _submitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _nftId,
        Order calldata _order,
        bool _reserved
    ) private returns (uint256 amountSpent) {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        require(success, ""NestedFactory::_submitOrder: Operator call failed"");

        (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
            data,
            _inputToken,
            _outputToken
        );

        if (_reserved) {
            _transferToReserveAndStore(_outputToken, amounts[0], _nftId);
        }
        amountSpent = amounts[1];
    }

    
    
    
    
    
    
    
    
    
    function _safeSubmitOrder(
        address _inputToken,
        address _outputToken,
        uint256 _amountToSpend,
        uint256 _nftId,
        Order calldata _order
    ) private {
        address operator = requireAndGetAddress(_order.operator);
        (bool success, bytes memory data) = OperatorHelpers.callOperator(operator, _order.commit, _order.callData);
        if (success) {
            (uint256[] memory amounts, address[] memory tokens) = OperatorHelpers.decodeDataAndRequire(
                data,
                _inputToken,
                _outputToken
            );
            _handleUnderSpending(_amountToSpend, amounts[1], IERC20(_inputToken));
        } else {
            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);
        }
    }

    
    
    
    
    
    function _transferToReserveAndStore(
        address _token,
        uint256 _amount,
        uint256 _nftId
    ) private {
        uint256 balanceReserveBefore = IERC20(_token).balanceOf(address(reserve));

        
        IERC20(_token).safeTransfer(address(reserve), _amount);

        uint256 balanceReserveAfter = IERC20(_token).balanceOf(address(reserve));

        nestedRecords.store(_nftId, _token, balanceReserveAfter - balanceReserveBefore, address(reserve));
    }

    
    
    
    
    
    
    
    function _transferInputTokens(
        uint256 _nftId,
        IERC20 _inputToken,
        uint256 _inputTokenAmount,
        bool _fromReserve
    ) private returns (IERC20 tokenUsed) {
        if (_fromReserve) {
            NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, address(_inputToken));
            require(holding.amount >= _inputTokenAmount, ""NestedFactory:_transferInputTokens: Insufficient amount"");

            
            reserve.withdraw(IERC20(holding.token), _inputTokenAmount);
        } else if (address(_inputToken) == ETH) {
            require(msg.value == _inputTokenAmount, ""NestedFactory::_transferInputTokens: Insufficient amount in"");
            weth.deposit{ value: msg.value }();
            _inputToken = IERC20(address(weth));
        } else {
            _inputToken.safeTransferFrom(_msgSender(), address(this), _inputTokenAmount);
        }
        tokenUsed = _inputToken;
    }

    
    
    
    
    
    
    function _handleUnderSpending(
        uint256 _amountToSpent,
        uint256 _amountSpent,
        IERC20 _token
    ) private {
        if (_amountToSpent - _amountSpent > 0) {
            ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
            feeSplitter.sendFees(_token, _amountToSpent - _amountSpent);
        }
    }

    
    
    
    
    function _transferFeeWithRoyalty(
        uint256 _amount,
        IERC20 _token,
        uint256 _nftId
    ) private {
        address originalOwner = nestedAsset.originalOwner(_nftId);
        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));
        if (originalOwner != address(0)) {
            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);
        } else {
            feeSplitter.sendFees(_token, _amount);
        }
    }

    
    
    
    
    function _decreaseHoldingAmount(
        uint256 _nftId,
        address _inputToken,
        uint256 _amount
    ) private {
        NestedRecords.Holding memory holding = nestedRecords.getAssetHolding(_nftId, _inputToken);
        nestedRecords.updateHoldingAmount(_nftId, _inputToken, holding.amount - _amount);
    }

    
    
    
    
    
    function _safeTransferAndUnwrap(
        IERC20 _token,
        uint256 _amount,
        address _dest
    ) private {
        
        if (address(_token) == address(weth)) {
            IWETH(weth).withdraw(_amount);
            (bool success, ) = _dest.call{ value: _amount }("""");
            require(success, ""ETH_TRANSFER_ERROR"");
        } else {
            _token.safeTransfer(_dest, _amount);
        }
    }

    
    
    
    
    function _safeTransferWithFees(
        IERC20 _token,
        uint256 _amount,
        address _dest,
        uint256 _nftId
    ) private {
        uint256 feeAmount = _calculateFees(_dest, _amount);
        _transferFeeWithRoyalty(feeAmount, _token, _nftId);
        _token.safeTransfer(_dest, _amount - feeAmount);
    }

    
    
    
    
    function _calculateFees(address _user, uint256 _amount) private view returns (uint256) {
        return _amount / 100;
    }
}",4148.0,1,4,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Operator Removal Leading to Panic and Locked Operators**:
   - The `removeOperator` function contains a loop that may exceed array bounds if the operator is not found, causing a panic. Additionally, the `require(i > 0)` check erroneously prevents removing the operator at index 0. This makes it impossible to remove the first operator and risks out-of-bounds access.

2. **Use of `assert` for Input Validation**:
   - The `assert(amountSpent <= _inputTokenAmount - feesAmount)` in `_submitInOrders` is misused for input validation. `assert` should only check invariants; `require` is appropriate here. Incorrect use of `assert` can cause unnecessary gas exhaustion on failure.

3. **Owner Can Drain ERC20 Tokens via `unlockTokens`**:
   - The `unlockTokens` function allows the owner to withdraw any ERC20 tokens held by the contract. If tokens are inadvertently sent to the contract (outside the reserve), the owner can drain them, posing a centralization risk.

4. **Unchecked Duplicate Operators**:
   - The `addOperator` function permits adding duplicate entries in the `operators` array. This can lead to redundant or unintended resolver behavior when fetching required addresses.

5. **Unsafe ETH Transfer in `_safeTransferAndUnwrap`**:
   - ETH is sent using a low-level call without specifying a gas limit. While the check ensures success, contracts requiring more than 2300 gas (default for `.call`) may fail, potentially locking funds.

6. **Zero Entries in Operators Array Post-Removal**:
   - Removing an operator via `delete operators[i]` leaves a zero entry in the array. The `resolverAddressesRequired` function may return these zero bytes, leading to unintended resolution of addresses (e.g., resolving to `address(0)`).

7. **Insufficient Fee Precision**:
   - Fees are calculated as `_amount / 100`, which truncates for small values (e.g., amounts < 100 wei yield zero fees). While not a direct vulnerability, this can lead to loss of fee revenue or undercharging.

8. **Potential Reentrancy in External Operator Calls**:
   - Although `nonReentrant` modifiers are used, external operators (via `callOperator`) could theoretically reenter functions if the modifier is absent in internal paths. However, the current use of `nonReentrant` on public functions mitigates this risk.

9. **Improper Handling of ETH/WETH Wrapping**:
   - Direct ETH transfers to the contract (outside designated functions) remain as ETH and are withdrawable by the owner via `unlockTokens`. This could lead to accidental fund locking if users send ETH directly.","### **[H-01] Copy your own portfolio to keep earning royalties**

**Report Description**:  
In `NestedFactory.sol`, the `create()` function leads to `sendFeesWithRoyalties()` and `addShares()`. There are no checks to prevent users from copying their own portfolio and receiving royalty shares repeatedly. This could lead to an infinite loop of royalty earnings, exploiting the system.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves improper access control and lack of checks for portfolio duplication, which is not covered in the provided responses.

---

### **[M-01] setReserve() can be front-run**

**Report Description**:  
The `reserve` address variable in `NestedFactory.sol` remains uninitialized (equal to `0`) until `setReserve()` is called by the owner. This could lead to incorrect token transfers or invalid comparisons (e.g., `nestedRecords.getAssetReserve(_nftId) == address(reserve)`). Additionally, the immutability of `reserve` requires careful handling when setting its value.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the front-running risk or the initialization issue with the `reserve` variable. This is a critical oversight in the responses.

---

### **[M-06] NestedFactory.sol#_submitInOrders() Wrong implementation cause users to be overcharged**

**Report Description**:  
In `_submitInOrders`, the actual `amountSpent + feesAmount` can be lower than `_inputTokenAmount`. The unspent amount should be returned to the user, but the current implementation takes it as part of the fee. This results in users being overcharged.

**Match in Response List**:  
Matches with the issue titled **""Use of `assert` for Input Validation""**.

**Validation**:  
**Partially Correct**. The response identifies the misuse of `assert` in `_submitInOrders`, which is related to the issue. However, it does not address the core problem of overcharging users due to unspent amounts being taken as fees. The response misses the critical detail of improper fee handling.

---

### **[M-07] Ensure on-chain that cache is synced**

**Report Description**:  
Core operations like `NestedFactory.create()` and `NestedFactory.swapTokenForTokens()` depend on the assumption that the cache is synced before execution. However, there is no on-chain mechanism to ensure this, which could lead to incorrect behavior if the cache is out of sync.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of cache synchronization. This is a significant gap in the responses.

---

### **[M-08] Passing multiple ETH deposits in orders array will use the same `msg.value` many times**

**Report Description**:  
Passing multiple ETH deposits in the `_orders` array will reuse the same `msg.value` for each deposit, allowing malicious users to extract value from the contract. This is because the system assumes the equivalent value was transferred, but `msg.value` persists over calls, leading to multiple deposits with the same value.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The vulnerability involves improper handling of `msg.value` in multiple ETH deposits, which is not covered in the provided responses.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-06] NestedFactory.sol#_submitInOrders() Wrong implementation cause users to be overcharged**

**Missed Issues from Issue Report**:  
- **[H-01] Copy your own portfolio to keep earning royalties**  
- **[M-01] setReserve() can be front-run**  
- **[M-07] Ensure on-chain that cache is synced**  
- **[M-08] Passing multiple ETH deposits in orders array will use the same `msg.value` many times**  

---

### **Conclusion**  
The response list fails to address most of the issues in the issue report. Only one issue ([M-06]) is partially covered, while the rest are entirely missed. The responses focus on unrelated vulnerabilities, such as operator management and ETH/WETH handling, which do not align with the reported issues. Significant gaps exist in addressing critical vulnerabilities like portfolio duplication, front-running, cache synchronization, and improper ETH deposit handling.",0,1,4,9,"Okay, I need to analyze the given smart contract for vulnerabilities. Let me start by going through the code step by step.

First, the contract imports several OpenZeppelin libraries like ReentrancyGuard, Ownable, Multicall, and SafeERC20. It also has some custom imports. The contract NestedFactory inherits from multiple contracts, including ReentrancyGuard, Ownable, MixinOperatorResolver, and Multicall. This means it should have features like reentrancy protection, ownership control, and the ability to handle multiple calls.

Looking at the state variables, there's a feeSplitter, reserve, nestedAsset, weth, and nestedRecords. The constructor initializes these variables. The modifiers check if the caller is the token owner and if the NFT is unlocked.

Now, let's check for common vulnerabilities. 

Reentrancy: The functions have the nonReentrant modifier, so that's probably covered. But maybe in some places where external calls are made, like in the operators via callOperator. Since the modifier is applied to the main functions, maybe that's okay, but need to check if internal functions that do calls are protected.

Access Control: The onlyTokenOwner modifier checks that the sender owns the NFT. The onlyOwner is used where appropriate. But in functions like unlockTokens, onlyOwner can transfer any ERC20 token's balance from the contract. That could be a risk if the contract holds tokens that shouldn't be withdrawable by the owner.

Integer Overflows/Underflows: The contract uses Solidity 0.8.9, which has built-in checks, so those are handled.

ETH Handling: The receive function allows the contract to accept ETH. When wrapping ETH into WETH, they use weth.deposit{value: msg.value}(). However, in _safeTransferAndUnwrap, they withdraw WETH and send ETH using a low-level call. That's risky if the recipient is a contract that could revert, but they have a require statement. But maybe there's a reentrancy issue here? Wait, but the functions using this are nonReentrant, so maybe not.

Input Validation: For example, in create(), they check that _orders.length > 0. But in other functions like destroy(), they check tokens.length == _orders.length. But in _submitInOrders and others, loops iterate over _orders. Are the orders validated properly? What if an order is malformed?

Another thing is the use of require in the modifiers. Like in onlyTokenOwner, it uses require with a message. That's standard.

Operator Helpers: The contract uses external operators via OperatorHelpers.callOperator. These operators are external addresses, so if they're malicious or buggy, they could cause issues. Since operators are added by the owner, if the owner is compromised, they can add malicious operators. But that's more of a trust issue. However, in the resolverAddressesRequired function, operators are dynamic. The addOperator and removeOperator functions allow the owner to manage operators. If an operator is removed incorrectly (like in removeOperator, which deletes the element but leaves a gap in the array), it might cause issues. Wait, the removeOperator function has a loop to find the operator, then deletes operators[i]. However, deleting an element from an array in Solidity just sets it to zero, and the array length doesn't change. So the resolverAddressesRequired would return an array with a zero address if an operator is removed. That could break things when trying to get the address for a zero bytes32 operator. Also, the loop in removeOperator could run out of gas if the operator isn't found, because i starts at 0 and increments until it finds the operator. If the operator isn't present, it will revert when i exceeds the array length, causing a panic. Wait, no. The operators array is of bytes32[], and i starts at 0. If the operator isn't in the array, the loop will keep increasing i until it's beyond the array length, causing an out-of-bounds access, which in Solidity 0.8.9 would revert with an error. The require(i > 0, ""..."") after the loop is supposed to check if the operator was found. But the loop condition is while (operators[i] != operator), so if the operator isn't found, i will increment until it's equal to operators.length, which would cause an index out of bounds. So the require(i > 0) is incorrect. For example, if the array has one element and we try to remove an operator that's not present, the loop would check i=0: if operators[0] is not the target, i becomes 1. Then accessing operators[1] would be out of bounds, causing a revert. So the removeOperator function has a vulnerability where trying to remove a non-existent operator will cause an out-of-bounds access and revert, but the error message is misleading. Also, after deletion, the array isn't properly shrunk; it just leaves a zero in the array, which might not be handled correctly elsewhere.

Another possible issue: In _submitInOrders, after processing the orders, they calculate fees as amountSpent / 100 (1% fee). Then they check that amountSpent <= _inputTokenAmount - feesAmount. But feesAmount is calculated based on amountSpent, not the input amount. So if amountSpent is less than the input, the fees could be less than 1% of the input. Wait, the _calculateFees function takes _amount (which is amountSpent in _submitInOrders) and returns _amount / 100. So the fees are 1% of the amountSpent. Then they check that amountSpent <= (_inputTokenAmount - feesAmount). But since feesAmount is amountSpent / 100, this would be amountSpent <= (input - (amountSpent / 100)). Rearranged, amountSpent + (amountSpent / 100) <= input. So the total spent including fees must be less than or equal to the input. But this could allow the sum of amountSpent and fees to exceed the input. Wait, let's see: inputTokenAmount is the total available. feesAmount is based on amountSpent. So if amountSpent is 100, fees is 1, then the inputTokenAmount must be at least 101. Otherwise, the assert would fail. The assert is there to check that amountSpent <= (inputTokenAmount - feesAmount). So inputTokenAmount must be >= amountSpent + feesAmount. But since feesAmount is a fraction of amountSpent, maybe this is okay, but perhaps the fees should be calculated based on the inputTokenAmount. This could lead to underflow if amountSpent is more than inputTokenAmount - feesAmount, but the assert is there. However, asserts should only be used for invariants; this is a check that could potentially fail due to input, so using require would be better. But the code uses assert, which consumes all gas in case of failure. This is not a vulnerability per se but a bad practice. However, in Solidity 0.8.9, assert is still used for checking invariants, so this could be a problem if the condition is not always true.

Another area: The _handleUnderSpending function sends the remaining tokens (inputTokenAmount - feesAmount - amountSpent) to the feeSplitter. But if the sum of amountSpent and fees is more than inputTokenAmount, this would underflow. But the assert in _submitInOrders is supposed to prevent that. So if the assert fails, the transaction reverts. However, using assert here is incorrect because assert is meant for internal errors, not input validation. It's better to use require here. So this is a potential issue because if the condition fails, the transaction reverts with a panic, which is not informative and consumes all gas.

Another possible issue is in the _safeSubmitOrder function. If the operator call fails, the code transfers the input token to the sender with fees. However, the amount transferred is the entire _amountToSpend, but if the operator failed, maybe some tokens were already spent? Or is the _amountToSpend the total that was supposed to be used, and the function is returning the unspent tokens? Need to check. The _safeSubmitOrder is called in the destroy function. For each token, they withdraw from the reserve and call _safeSubmitOrder. If the operator call fails, the code sends the _amountToSpend (the holding.amount) to the sender, minus fees. But if the operator failed, perhaps some tokens were already spent, leading to a situation where more tokens are sent than available. Wait, no. The code in destroy function first withdraws the holding.amount from the reserve, which is then passed to _safeSubmitOrder as _amountToSpend. Then, in _safeSubmitOrder, if the operator call fails, it transfers _amountToSpend (the entire amount) to the sender, minus fees. But if the operator failed but still spent some tokens, this would lead to a double-spend. However, the operator's call is supposed to handle the token transfers. But since the operator is called via callOperator, which uses a low-level call, if the operator fails, any state changes made before the revert would be rolled back. Therefore, if the operator call fails, the entire transaction is reverted, and the code in the else clause (the _safeTransferWithFees) would only execute if the call was successful but returned false. Wait, no. The code says:

(success, data) = OperatorHelpers.callOperator(...);
if (success) {
    ... process ...
} else {
    _safeTransferWithFees(...);
}

Wait, no. If the callOperator returns success as false (i.e., the call reverted), then the else clause is executed. But in that case, the _safeTransferWithFees is called, which sends the _amountToSpend (the entire amount) to the user. However, if the operator actually did transfer some tokens but then reverted, those transfers would still have happened, but since the call is made with a low-level call that catches the revert, the overall transaction would not revert. Wait, no. The callOperator function uses a low-level call and returns success as false if the call reverted. In that case, any state changes made by the operator during the call would be rolled back. So if the operator's code did some transfers and then reverted, all those changes would be undone. Therefore, in the else clause, the code can safely transfer the _amountToSpend because the operator's code didn't actually spend any tokens. Therefore, this part is safe.

Another vulnerability: The FeeSplitter's sendFees and sendFeesWithRoyalties functions are called with the fee amount, but in _calculateFees, the fee is 1% (amount / 100). If the fee calculation is too low, but that's a business logic issue, not a vulnerability. However, if the fee is supposed to be configurable and is hardcoded, that's an issue, but according to the code, it's fixed at 1%.

Another area: The use of require in the removeOperator function. The loop while (operators[i] != operator) { i++; } will increment i until it finds the operator. However, if the operator is not present in the array, this loop will run indefinitely until it runs out of gas. For example, if the operators array has elements [op1, op2, op3], and we try to remove op4, the loop will check i=0 (op1 != op4 → i=1), i=1 (op2 != op4 → i=2), i=2 (op3 != op4 → i=3), then check operators[3] which is out of bounds. Accessing operators[3] when the array has length 3 (indices 0-2) would cause a panic error, and the transaction would revert. The require(i > 0) after the loop is intended to check that the operator was found, but if the loop exits because i went beyond the array length, the require would fail. However, the loop can't exit normally; it will either find the operator and exit, or cause an out-of-bounds access which reverts. Therefore, the removeOperator function has a vulnerability where trying to remove an operator that doesn't exist will cause a panic error (array out of bounds), which is not properly handled. The function should first check if the operator exists in the array before attempting to remove it.

Another issue: When adding an operator with addOperator, there's no check for duplicates. The same operator can be added multiple times, leading to duplicates in the operators array. This could cause the resolverAddressesRequired function to return multiple entries of the same operator, leading to redundant calls or other issues.

In the destroy function, when processing each token, they call reserve.withdraw and then call _safeSubmitOrder. The _safeSubmitOrder is supposed to swap the token, but if it fails, it sends the tokens to the user with fees. However, the for loop in destroy processes each token in sequence. If one of the _safeSubmitOrder calls fails (i.e., the operator call fails), then the tokens for that order are sent back to the user, but the loop continues. However, since the code is in a nonReentrant function, and the reserve.withdraw has already transferred the tokens to the factory contract, the _safeSubmitOrder is supposed to handle transferring them. But if an operator fails, the tokens are sent back to the user. However, the rest of the tokens are still processed. This might leave some tokens in the reserve or the factory, but the code in destroy is supposed to remove all assets. However, if some tokens are not successfully sold via the orders and are sent back to the user, the nestedRecords.removeNFT(_nftId) is still called, which might leave the reserve with some remaining tokens if they were not properly withdrawn. Wait, no. The destroy function first withdraws all holdings from the reserve via reserve.withdraw for each token. So the tokens are moved from the reserve to the factory contract. Then, for each token, the code attempts to swap them via _safeSubmitOrder. If that fails, the tokens are sent to the user (minus fees). So after processing all tokens, the reserve should have no holdings left for the NFT, as they were all withdrawn. Therefore, calling nestedRecords.removeNFT(_nftId) is correct because all holdings have been withdrawn and either swapped or returned to the user.

Another potential issue: The FeeSplitter's address can be changed via setFeeSplitter, but there's no check that the new feeSplitter is a valid contract (only that it's not address(0)). However, the function is only callable by the owner, so it's a trust issue.

In the unlockTokens function, the owner can transfer any ERC20 token's balance from the contract to themselves. This could be a problem if the contract holds tokens that are not supposed to be accessible by the owner. For example, if users have deposited tokens into the contract (not via the reserve), the owner could withdraw them. However, in the current code, user funds should be held in the reserve, not in the factory contract. However, in functions like create or addTokens, if the _sellToken is transferred to the factory, and then processed, there might be scenarios where tokens are temporarily held in the factory. For example, in create(), if the _sellToken is ETH, it's wrapped into WETH in the factory. Then, during _submitInOrders, the WETH is used. But any leftover tokens after processing would be sent to feeSplitter via _handleUnderSpending. So the factory's balance of tokens should be zero under normal operation. However, if there's a bug or an unexpected situation where tokens are left in the factory, the owner can withdraw them. This is a centralization risk and could be considered a vulnerability if the contract is supposed to be trustless.

In the _transferInputTokens function, when _fromReserve is false and the _inputToken is ETH, the code wraps it into WETH. But if someone sends ETH directly to the contract (not via the create or addTokens function), the owner can withdraw it using unlockTokens. Again, this is a trust issue.

Another possible issue: The NestedRecords contract's functions like getAssetHolding, store, updateHoldingAmount, etc., are used, but if those functions have any vulnerabilities, they could affect the factory. But since it's an external contract, we can't audit it here. The same applies to FeeSplitter and other dependencies.

In the _safeTransferAndUnwrap function, when unwrapping WETH, the code does a low-level call to send ETH. If the recipient is a contract that uses more than 2300 gas, it could fail. However, the function is used to send to _msgSender(), which is a user's EOA in most cases. But if the user is a contract, this could lead to failed transfers. The SafeERC20 library isn't used here for ETH transfers, which could be an issue. For example, using .transfer or .send would be safer, but this code uses a low-level call with value. The code checks for success, so if the transfer fails, it reverts. That's correct.

In the _transferFeeWithRoyalty function, the code sets max allowance to feeSplitter and then calls sendFees or sendFeesWithRoyalties. However, setting max allowance could be a risk if the feeSplitter is compromised, as it would allow it to spend any amount of the token. However, since the feeSplitter is a trusted contract set by the owner, this is a trust issue. If the feeSplitter has a vulnerability, it could lead to loss of funds.

In the destroy function, after processing all tokens, the code calculates the amountBought as the difference in the _buyToken's balance. However, if the _buyToken is ETH (unlikely since it's an ERC20 interface), but if it's WETH, then the balance would be correct. The code then subtracts fees and sends the rest to the user. However, if other functions or contracts interact with the factory's token balances, this could affect the amountBought calculation. For example, if someone sends _buyToken to the factory during the destroy transaction, the amountBought would be inflated. But since the function is nonReentrant and the calls are all within the same transaction, this is unlikely unless the _buyToken is a malicious ERC20 that calls back into the factory. However, the SafeERC20 library is used, which should handle reentrant tokens. But if the _buyToken is a ERC777 token that calls back into the contract, there could be reentrancy issues. However, the nonReentrant modifier should protect against that.

Another thing to check is the handling of ETH/WETH. The code uses address(ETH) as a constant (0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE). When _inputToken is ETH, it wraps it into WETH. But in other parts, when transferring, it unwraps WETH into ETH. This seems consistent. However, if someone sends ETH directly to the contract (not via a function that expects it), it could get stuck until the owner uses unlockTokens to withdraw it. But the receive function allows the contract to accept ETH, which is then wrapped into WETH only in specific functions. So any ETH sent to the contract outside of those functions would remain as ETH, and the owner could withdraw it.

Possible issues summary:

1. **Incorrect Operator Removal Leading to Panic**: The removeOperator function can cause an out-of-bounds array access if the operator is not present, leading to a revert. The loop in removeOperator does not check the array bounds, which can result in an index out of range error.

2. **Potential Duplicate Operators**: The addOperator function allows adding the same operator multiple times, leading to duplicates in the operators array.

3. **Use of Assert for Input Validation**: The assert in _submitInOrders checks that amountSpent <= _inputTokenAmount - feesAmount. Using assert here is incorrect as it's meant for invariants; a require should be used instead.

4. **Owner Can Drain ERC20 Tokens**: The unlockTokens function allows the owner to withdraw any ERC20 token balance from the contract, which could be risky if tokens are accidentally sent to the contract.

5. **Fee Calculation Based on Spent Amount**: Fees are calculated based on the amount spent (1%) instead of the input amount, which might not align with user expectations and could lead to undercharging or overcharging if not intended.

6. **Unsafe Low-Level Call in _safeTransferAndUnwrap**: While the code checks for success, using a low-level call to send ETH could fail for contracts that require more gas. However, it's mitigated by the nonReentrant modifier and the fact that it's sent to _msgSender().

7. **Improper Handling of Operator Array in Resolver**: The resolverAddressesRequired function returns the operators array, which may contain zero entries after removal, leading to unintended behavior when resolving addresses.

8. **Incorrect Index Check in removeOperator**: The require(i > 0) in removeOperator is incorrect. If the operator is at index 0, the condition i > 0 would fail. It should be require(i < operators.length) to confirm the operator was found.

Let me elaborate on these points.

1. **Incorrect Operator Removal Leading to Panic**: When removing an operator, the loop increments i until it finds the operator, but if not found, i exceeds the array length, causing a panic. Also, deleting the element leaves a gap in the array.

2. **Duplicate Operators**: The addOperator function doesn't check if the operator already exists, leading to duplicates which could affect the resolver's behavior.

3. **Assert Misuse**: Using assert for input validation can cause the transaction to consume all gas if the condition fails, which is unnecessary and should be a require.

4. **Owner Drain**: The unlockTokens function allows the owner to withdraw any ERC20, which could be abused if the contract holds unexpected tokens.

5. **Fee Calculation**: Fees are 1% of the spent amount, not the input. If the input is 100, but only 50 is spent, the fee is 0.5, which is 1% of 50. But the user provided 100, so the remaining 49.5 (100 - 50 - 0.5) is sent to the feeSplitter. This is a design choice but could be considered a vulnerability if not intended.

6. **Low-Level Call**: Using .call for ETH transfers is safer than .transfer but still has gas stipend issues. However, the code checks for success.

7. **Zero Entries in Operators Array**: After removing an operator, the array may have a zero entry, which when passed to the resolver, would attempt to get the address for bytes32(0), which may not be intended.

8. **Index Check in removeOperator**: The current require(i > 0) would not allow removing the operator at index 0. For example, if the first operator is to be removed, i is 0, and require(i > 0) would fail, preventing removal. This is a bug.

Wait, let's check the removeOperator code:

function removeOperator(bytes32 operator) external override onlyOwner {
    uint256 i = 0;
    while (operators[i] != operator) {
        i++;
    }
    require(i > 0, ""NestedFactory::removeOperator: Cant remove non-existent operator"");
    delete operators[i];
}

Wait, suppose the operator is at index 0. Then, the loop starts at i=0, checks operators[0] == operator. If yes, exits the loop. Then require(i > 0) would be false, and the function would revert. Therefore, operators at index 0 cannot be removed. This is a critical bug. The require should check that i < operators.length, not i > 0. The require is intended to ensure that the operator exists, but the current check is incorrect.

This is a vulnerability because the owner cannot remove an operator that is at the first position (index 0). Moreover, the loop may run out of bounds if the operator is not found.

So, this is a major issue.

Other issues:

In the _submitOrder function, after calling the operator, it decodes the amounts and tokens. Then, if _reserved is true, it transfers to reserve and stores. But there's no check that the _outputToken matches the token in the order. The OperatorHelpers.decodeDataAndRequire function is supposed to check that, but if not, this could lead to storing wrong tokens in the reserve.

In the FeeSplitter's sendFees, if the feeSplitter is malicious or has a bug, funds could be lost. But since the owner controls feeSplitter, this is a trust issue.

So, compiling all these, the main vulnerabilities are:

1. **Incorrect Operator Removal Leading to Panic and Unremovable Operators**: The removeOperator function has multiple issues, including inability to remove the first operator (index 0) and potential out-of-bounds access.

2. **Use of Assert for Input Validation**: The assert in _submitInOrders should be a require.

3. **Owner Can Drain ERC20 Tokens via unlockTokens**: The unlockTokens function allows the owner to withdraw any ERC20 tokens from the contract, which could include user funds if any are accidentally left in the contract.

4. **Unchecked Operator Array Duplicates**: Adding the same operator multiple times could lead to unexpected resolver behavior.

5. **Potential Division in Fee Calculation**: The 1% fee is calculated as _amount / 100, which could truncate for small amounts (e.g., 1 wei would result in 0 fees). However, this is more of a precision issue than a vulnerability.

6. **Incorrect Index Check in removeOperator**: As mentioned, the require(i > 0) prevents removing the first operator.

7. **Unsafe ETH Transfer**: Using a low-level call without a gas limit could fail for contracts, but the check is present.

8. **Zero Address in Operators Array**: After removing an operator, the array may contain a zero, leading to resolver errors.

Now, let's list these as vulnerabilities, focusing on the most critical ones first.","```
None.
```",0.0
FeeSplitter.sol,"// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/external/IWETH.sol"";

/// @title Manage the fees between shareholders
/// @notice Receives fees collected by the NestedFactory, and splits the income among
/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).
contract FeeSplitter is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    /// @dev Emitted when a payment is released
    /// @param to The address receiving the payment
    /// @param token The token transfered
    /// @param amount The amount paid
    event PaymentReleased(address to, address token, uint256 amount);

    /// @dev Emitted when a payment is released
    /// @param from The address sending the tokens
    /// @param token The token received
    /// @param amount The amount received
    event PaymentReceived(address from, address token, uint256 amount);

    /// @dev Represent a shareholder
    /// @param account Shareholders address that can receive income
    /// @param weight Determines share allocation
    struct Shareholder {
        address account;
        uint256 weight;
    }

    /// @dev Registers shares and amount release for a specific token or ETH
    struct TokenRecords {
        uint256 totalShares;
        uint256 totalReleased;
        mapping(address => uint256) shares;
        mapping(address => uint256) released;
    }

    /// @dev Map of tokens with the tokenRecords
    mapping(address => TokenRecords) private tokenRecords;

    /// @dev All the shareholders (array)
    Shareholder[] private shareholders;

    /// @dev Royalties part weights when applicable
    uint256 public royaltiesWeight;

    uint256 public totalWeights;

    address public immutable weth;

    constructor(
        address[] memory _accounts,
        uint256[] memory _weights,
        uint256 _royaltiesWeight,
        address _weth
    ) {
        // Initial shareholders addresses and weights
        setShareholders(_accounts, _weights);
        setRoyaltiesWeight(_royaltiesWeight);
        weth = _weth;
    }

    /// @dev Receive ether after a WETH withdraw call
    receive() external payable {
        require(_msgSender() == weth, ""FeeSplitter: ETH_SENDER_NOT_WETH"");
    }

    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.
    /// @param _account Account address to check the amount due for
    /// @param _token ERC20 payment token address (or ETH_ADDR)
    /// @return The total amount due for the requested currency
    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 totalReceived = _tokenRecords.totalReleased;
        if (_tokenRecords.totalShares == 0) return 0;
        else totalReceived += _token.balanceOf(address(this));
        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /
            _tokenRecords.totalShares -
            _tokenRecords.released[_account];
        return amountDue;
    }

    /// @notice Sets the weight assigned to the royalties part for the fee
    /// @param _weight The new royalties weight
    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {
        totalWeights -= royaltiesWeight;
        royaltiesWeight = _weight;
        totalWeights += _weight;
    }

    /// @notice Sets a new list of shareholders
    /// @param _accounts Shareholders accounts list
    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them
    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {
        delete shareholders;
        require(_accounts.length > 0 && _accounts.length == _weights.length, ""FeeSplitter: ARRAY_LENGTHS_ERR"");
        totalWeights = royaltiesWeight;

        for (uint256 i = 0; i < _accounts.length; i++) {
            _addShareholder(_accounts[i], _weights[i]);
        }
    }

    /// @notice Triggers a transfer to `msg.sender` of the amount of token they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    /// @param _token Payment token address
    function releaseToken(IERC20 _token) public nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), _token);
        _token.safeTransfer(_msgSender(), amount);
        emit PaymentReleased(_msgSender(), address(_token), amount);
    }

    /// @notice Call releaseToken() for multiple tokens
    /// @param _tokens ERC20 tokens to release
    function releaseTokens(IERC20[] memory _tokens) external {
        for (uint256 i = 0; i < _tokens.length; i++) {
            releaseToken(_tokens[i]);
        }
    }

    /// @dev Triggers a transfer to `msg.sender` of the amount of Ether they are owed, according to
    /// the amount of shares they own and their previous withdrawals.
    function releaseETH() external nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));
        IWETH(weth).withdraw(amount);
        (bool success, ) = _msgSender().call{ value: amount }("""");
        require(success, ""FeeSplitter: ETH_TRANFER_ERROR"");
        emit PaymentReleased(_msgSender(), ETH, amount);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {
        uint256 weights = totalWeights - royaltiesWeight;
        _sendFees(_token, _amount, weights);
    }

    /// @notice Sends a fee to this contract for splitting, as an ERC20 token
    /// @param _royaltiesTarget The account that can claim royalties
    /// @param _token Currency for the fee as an ERC20 token
    /// @param _amount Amount of token as fee to be claimed by this contract
    function sendFeesWithRoyalties(
        address _royaltiesTarget,
        IERC20 _token,
        uint256 _amount
    ) external nonReentrant {
        require(_royaltiesTarget != address(0), ""FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS"");

        _sendFees(_token, _amount, totalWeights);
        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));
    }

    /// @notice Updates weight for a shareholder
    /// @param _accountIndex Account to change the weight of
    /// @param _weight The new weight
    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {
        require(_accountIndex + 1 <= shareholders.length, ""FeeSplitter: INVALID_ACCOUNT_INDEX"");
        uint256 _totalWeights = totalWeights;
        _totalWeights -= shareholders[_accountIndex].weight;
        shareholders[_accountIndex].weight = _weight;
        _totalWeights += _weight;
        require(_totalWeights > 0, ""FeeSplitter: TOTAL_WEIGHTS_ZERO"");
        totalWeights = _totalWeights;
    }

    /// @notice Getter for the total shares held by shareholders.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total shares count
    function totalShares(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalShares;
    }

    /// @notice Getter for the total amount of token already released.
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The total amount release to shareholders
    function totalReleased(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalReleased;
    }

    /// @notice Getter for the amount of shares held by an account.
    /// @param _account Account the shares belong to
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The shares owned by the account
    function shares(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].shares[_account];
    }

    /// @notice Getter for the amount of Ether already released to a shareholders.
    /// @param _account The target account for this request
    /// @param _token Payment token address, use ETH_ADDR for ETH
    /// @return The amount already released to this account
    function released(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].released[_account];
    }

    /// @notice Finds a shareholder and return its index
    /// @param _account Account to find
    /// @return The shareholder index in the storage array
    function findShareholder(address _account) external view returns (uint256) {
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (shareholders[i].account == _account) return i;
        }
        revert(""FeeSplitter: NOT_FOUND"");
    }

    /// @dev Transfers a fee to this contract
    /// @param _token Currency for the fee
    /// @param _amount Amount of token as fee
    /// @param _totalWeights Total weights to determine the share count to allocate
    function _sendFees(
        IERC20 _token,
        uint256 _amount,
        uint256 _totalWeights
    ) private {
        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);

        for (uint256 i = 0; i < shareholders.length; i++) {
            _addShares(
                shareholders[i].account,
                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),
                address(_token)
            );
        }
        emit PaymentReceived(_msgSender(), address(_token), _amount);
    }

    /// @dev Increase the shares of a shareholder
    /// @param _account The shareholder address
    /// @param _shares The shares of the holder
    /// @param _token The updated token
    function _addShares(
        address _account,
        uint256 _shares,
        address _token
    ) private {
        TokenRecords storage _tokenRecords = tokenRecords[_token];
        _tokenRecords.shares[_account] += _shares;
        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;
    }

    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 amountToRelease = getAmountDue(_account, _token);
        require(amountToRelease != 0, ""FeeSplitter: NO_PAYMENT_DUE"");

        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;
        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;

        return amountToRelease;
    }

    function _addShareholder(address _account, uint256 _weight) private {
        require(_weight > 0, ""FeeSplitter: ZERO_WEIGHT"");
        shareholders.push(Shareholder(_account, _weight));
        totalWeights += _weight;
    }

    function _computeShareCount(
        uint256 _amount,
        uint256 _weight,
        uint256 _totalWeights
    ) private pure returns (uint256) {
        return (_amount * _weight) / _totalWeights;
    }
}",2615.0,277.0,"[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice.
It is possible for duplicate shareholders to be added. These shareholders will get more than intended when `_sendFee()` is called.
  [M-04] FeeSplitter: Unbounded number of shareholders can cause DOS
There is no limit to the number of shareholders. It is therefore possible to set a large number of shareholders such that `_sendFees()` will run out of gas when adding shares to each shareholder. This will cause denial of service to all NestedFactory functions, especially the ones that will remove funds like `withdraw()` and `destroy()`.",2.0,"pragma solidity 0.8.9;

import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";
import ""@openzeppelin/contracts/security/ReentrancyGuard.sol"";
import ""@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol"";

import ""./interfaces/external/IWETH.sol"";




contract FeeSplitter is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;

    
    
    
    
    event PaymentReleased(address to, address token, uint256 amount);

    
    
    
    
    event PaymentReceived(address from, address token, uint256 amount);

    
    
    
    struct Shareholder {
        address account;
        uint256 weight;
    }

    
    struct TokenRecords {
        uint256 totalShares;
        uint256 totalReleased;
        mapping(address => uint256) shares;
        mapping(address => uint256) released;
    }

    
    mapping(address => TokenRecords) private tokenRecords;

    
    Shareholder[] private shareholders;

    
    uint256 public royaltiesWeight;

    uint256 public totalWeights;

    address public immutable weth;

    constructor(
        address[] memory _accounts,
        uint256[] memory _weights,
        uint256 _royaltiesWeight,
        address _weth
    ) {
        
        setShareholders(_accounts, _weights);
        setRoyaltiesWeight(_royaltiesWeight);
        weth = _weth;
    }

    
    receive() external payable {
        require(_msgSender() == weth, ""FeeSplitter: ETH_SENDER_NOT_WETH"");
    }

    
    
    
    
    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 totalReceived = _tokenRecords.totalReleased;
        if (_tokenRecords.totalShares == 0) return 0;
        else totalReceived += _token.balanceOf(address(this));
        uint256 amountDue = (totalReceived * _tokenRecords.shares[_account]) /
            _tokenRecords.totalShares -
            _tokenRecords.released[_account];
        return amountDue;
    }

    
    
    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {
        totalWeights -= royaltiesWeight;
        royaltiesWeight = _weight;
        totalWeights += _weight;
    }

    
    
    
    function setShareholders(address[] memory _accounts, uint256[] memory _weights) public onlyOwner {
        delete shareholders;
        require(_accounts.length > 0 && _accounts.length == _weights.length, ""FeeSplitter: ARRAY_LENGTHS_ERR"");
        totalWeights = royaltiesWeight;

        for (uint256 i = 0; i < _accounts.length; i++) {
            _addShareholder(_accounts[i], _weights[i]);
        }
    }

    
    
    
    function releaseToken(IERC20 _token) public nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), _token);
        _token.safeTransfer(_msgSender(), amount);
        emit PaymentReleased(_msgSender(), address(_token), amount);
    }

    
    
    function releaseTokens(IERC20[] memory _tokens) external {
        for (uint256 i = 0; i < _tokens.length; i++) {
            releaseToken(_tokens[i]);
        }
    }

    
    
    function releaseETH() external nonReentrant {
        uint256 amount = _releaseToken(_msgSender(), IERC20(weth));
        IWETH(weth).withdraw(amount);
        (bool success, ) = _msgSender().call{ value: amount }("""");
        require(success, ""FeeSplitter: ETH_TRANFER_ERROR"");
        emit PaymentReleased(_msgSender(), ETH, amount);
    }

    
    
    
    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {
        uint256 weights = totalWeights - royaltiesWeight;
        _sendFees(_token, _amount, weights);
    }

    
    
    
    
    function sendFeesWithRoyalties(
        address _royaltiesTarget,
        IERC20 _token,
        uint256 _amount
    ) external nonReentrant {
        require(_royaltiesTarget != address(0), ""FeeSplitter: INVALID_ROYALTIES_TARGET_ADDRESS"");

        _sendFees(_token, _amount, totalWeights);
        _addShares(_royaltiesTarget, _computeShareCount(_amount, royaltiesWeight, totalWeights), address(_token));
    }

    
    
    
    function updateShareholder(uint256 _accountIndex, uint256 _weight) external onlyOwner {
        require(_accountIndex + 1 <= shareholders.length, ""FeeSplitter: INVALID_ACCOUNT_INDEX"");
        uint256 _totalWeights = totalWeights;
        _totalWeights -= shareholders[_accountIndex].weight;
        shareholders[_accountIndex].weight = _weight;
        _totalWeights += _weight;
        require(_totalWeights > 0, ""FeeSplitter: TOTAL_WEIGHTS_ZERO"");
        totalWeights = _totalWeights;
    }

    
    
    
    function totalShares(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalShares;
    }

    
    
    
    function totalReleased(address _token) external view returns (uint256) {
        return tokenRecords[_token].totalReleased;
    }

    
    
    
    
    function shares(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].shares[_account];
    }

    
    
    
    
    function released(address _account, address _token) external view returns (uint256) {
        return tokenRecords[_token].released[_account];
    }

    
    
    
    function findShareholder(address _account) external view returns (uint256) {
        for (uint256 i = 0; i < shareholders.length; i++) {
            if (shareholders[i].account == _account) return i;
        }
        revert(""FeeSplitter: NOT_FOUND"");
    }

    
    
    
    
    function _sendFees(
        IERC20 _token,
        uint256 _amount,
        uint256 _totalWeights
    ) private {
        IERC20(_token).safeTransferFrom(_msgSender(), address(this), _amount);

        for (uint256 i = 0; i < shareholders.length; i++) {
            _addShares(
                shareholders[i].account,
                _computeShareCount(_amount, shareholders[i].weight, _totalWeights),
                address(_token)
            );
        }
        emit PaymentReceived(_msgSender(), address(_token), _amount);
    }

    
    
    
    
    function _addShares(
        address _account,
        uint256 _shares,
        address _token
    ) private {
        TokenRecords storage _tokenRecords = tokenRecords[_token];
        _tokenRecords.shares[_account] += _shares;
        _tokenRecords.totalShares = _tokenRecords.totalShares + _shares;
    }

    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {
        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];
        uint256 amountToRelease = getAmountDue(_account, _token);
        require(amountToRelease != 0, ""FeeSplitter: NO_PAYMENT_DUE"");

        _tokenRecords.released[_account] = _tokenRecords.released[_account] + amountToRelease;
        _tokenRecords.totalReleased = _tokenRecords.totalReleased + amountToRelease;

        return amountToRelease;
    }

    function _addShareholder(address _account, uint256 _weight) private {
        require(_weight > 0, ""FeeSplitter: ZERO_WEIGHT"");
        shareholders.push(Shareholder(_account, _weight));
        totalWeights += _weight;
    }

    function _computeShareCount(
        uint256 _amount,
        uint256 _weight,
        uint256 _totalWeights
    ) private pure returns (uint256) {
        return (_amount * _weight) / _totalWeights;
    }
}",1677.0,0,2,"The FeeSplitter smart contract contains several vulnerabilities:

1. **Direct Token Transfer Vulnerability**: ERC20 tokens or ETH sent directly to the contract (outside `sendFees`/`sendFeesWithRoyalties`) are included in distribution calculations. This allows attackers to manipulate payouts by front-running transactions and injecting tokens, leading to incorrect fund distributions.

2. **Uncleared Shares for Removed Shareholders**: Removing shareholders via `setShareholders` does not clear their existing shares in previous token allocations. Removed shareholders can still claim funds from old distributions, leading to unintended payouts.

3. **Zero Address Shareholder Risk**: The contract permits adding `address(0)` as a shareholder due to missing validation. This results in irreversible token burns when funds are released to the zero address.

4. **Division Rounding Issues**: Integer division in share calculations may leave residual tokens (""dust"") in the contract. While carried over to future distributions, these can become permanently stuck if no further fees are sent.

5. **Duplicate Shareholders in Configuration**: The owner can erroneously add duplicate accounts in `setShareholders`, multiplying their weight and skewing future distributions.

6. **Stranded ETH from Direct Transfers**: ETH sent directly (not via WETH) is untracked and irrecoverable, as the contract only handles WETH-wrapped ETH.

7. **Incorrect Share Allocation from External Balances**: Existing token balances in the contract (from prior transfers) are included in new distributions when `sendFees` is called, causing unintended allocation of old and new funds together.","### **Output**

---

**[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice**

**Report Description**:  
The `FeeSplitter` contract lacks a sanity check to prevent duplicate shareholders from being added. This oversight allows the same shareholder to be added multiple times, leading to unintended overpayments when `_sendFee()` is called. This could result in skewed fund distributions and potential financial losses.

**Match in Response List**:  
Matches with the issue titled **""Duplicate Shareholders in Configuration""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of duplicate shareholders being added in the `FeeSplitter` contract. It correctly explains the risk of skewed distributions due to duplicate entries, which aligns with the reported issue.

---

**[M-04] FeeSplitter: Unbounded number of shareholders can cause DOS**

**Report Description**:  
The `FeeSplitter` contract does not impose a limit on the number of shareholders. This allows an attacker to add a large number of shareholders, causing the `_sendFees()` function to run out of gas during execution. This denial of service (DOS) could disrupt critical functions like `withdraw()` and `destroy()` in the `NestedFactory` contract, leading to operational failures.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of an unbounded number of shareholders causing a DOS. This is a critical oversight, as the lack of a shareholder limit poses a significant risk to the contract's functionality and security.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[M-02] FeeSplitter: No sanity check to prevent shareholder from being added twice**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-04] FeeSplitter: Unbounded number of shareholders can cause DOS**

--- 

### **Overall Assessment**  
The response list covers some vulnerabilities in the `FeeSplitter` contract, such as duplicate shareholders and direct token transfer risks. However, it fails to address the critical issue of an unbounded number of shareholders causing a DOS. This gap highlights the need for a more comprehensive review of the contract's security mechanisms.",1,0,1,7,"Okay, let's see. I need to analyze this FeeSplitter contract for vulnerabilities. Let me start by reading through the code carefully.

First, the contract imports several OpenZeppelin libraries like ReentrancyGuard, Ownable, SafeERC20, etc. It uses SafeERC20 for transfers, which is good. The contract is Ownable and uses ReentrancyGuard, so they're trying to prevent reentrancy attacks. But let's check each function for possible issues.

The receive() function is payable but checks that the sender is WETH. That's probably okay because it's meant to handle ETH sent via WETH withdrawals. But maybe there's a way to trick that? Not sure yet.

Looking at getAmountDue: It calculates the amount due based on the token's balance. But wait, the calculation adds totalReleased and the current balance. However, if someone sends tokens directly to the contract without using sendFees, it could affect the accounting. Because the totalReceived includes the balance, any external token transfers would be considered part of the fees. That could be a problem. For example, if someone accidentally transfers tokens to the contract, they get included in the shares, leading to incorrect distributions.

Another point: When releasing tokens, the contract uses safeTransfer, which is good. But in releaseETH, it withdraws WETH and sends ETH. The check in receive() requires that the sender is WETH, which might be when unwrapping. But in releaseETH, they call IWETH(weth).withdraw(amount), which converts WETH to ETH in the contract. Then they send that ETH to the user. However, if the contract's ETH balance is not properly tracked, there might be issues. Wait, the contract's ETH balance could come from other sources. For example, if someone sends ETH directly to the contract, not via WETH, would that affect anything? Let me check.

In the sendFees functions, they handle ERC20 tokens. But for ETH, the receive function is only triggered when WETH sends ETH (since IWETH's withdraw function sends ETH to the contract). But if someone sends ETH directly, the receive function would not be called, right? Because the receive function is only triggered on a plain ETH transfer with empty calldata. So if someone sends ETH directly, it would go into the contract's balance, but the contract doesn't track it as part of any token's records. However, the releaseETH function deals with the WETH token. So the ETH in the contract (not wrapped) would not be accounted for in any shares. That could be a problem because any ETH sent directly would be stuck or could be taken by someone else.

Wait, the releaseETH function calls _releaseToken with IERC20(weth). That means it's treating WETH as the token. So when someone calls releaseETH, it's calculating the amount due based on WETH's balance. But if the contract has native ETH (not WETH), that isn't tracked here. So if someone mistakenly sends ETH instead of WETH, those funds wouldn't be accounted for in the shares and could be locked in the contract. That's a potential issue.

Another thing: In the sendFeesWithRoyalties function, they compute shares including royaltiesWeight. They call _addShares for the _royaltiesTarget. But what if _royaltiesTarget is already a shareholder? Their shares for that token would be increased, which might not be intended. The shareholders array is for the regular shareholders, but the royalties target is a separate entity. However, the _addShares function just adds to the existing shares for the account. So if the royalties target is also a shareholder, their share weight would effectively be higher. Is that intended? Maybe not. It could lead to double-counting if the royalties target is already in the shareholders list. But the code allows that, which might be a vulnerability if not properly handled.

Looking at the setShareholders function: It deletes the shareholders array and then adds new ones. But when deleting, does it properly update the tokenRecords for existing tokens? For example, if a shareholder is removed, their existing shares in various tokens aren't cleared. So even after removing a shareholder via setShareholders, their existing shares in each token would still allow them to claim funds. That's a problem because the shareholders array is used to distribute new fees, but old shares remain. This could lead to a situation where a removed shareholder still has shares from previous distributions and can claim those tokens. So the contract doesn't handle the removal of shareholders properly. The shares for each token are not reset when shareholders are changed. That's a vulnerability.

Another thing: The updateShareholder function allows changing the weight of a shareholder. However, changing the weight affects future distributions but not existing shares. Existing shares in tokens are based on previous weights. So if a shareholder's weight is reduced, their existing shares in tokens from previous distributions remain the same. The new weight only affects future sendFees calls. This might be intended, but if the weights are supposed to dynamically adjust all existing shares, then it's a problem. But according to the current logic, shares are added each time sendFees is called, based on the current weight. So changing the weight would only affect future distributions, which is correct. But existing shares for tokens are not adjusted. That might be acceptable, but depends on the intended functionality. Maybe not a vulnerability, just a design choice.

In the _sendFees function, when adding shares, they loop through the shareholders and compute the share count based on the current weight. If during this loop the shareholders array is modified (e.g., in another function), it could cause inconsistencies. But since setShareholders is only callable by the owner and the functions are nonReentrant, maybe that's not an issue. But if the owner calls setShareholders while a sendFees transaction is pending, it could cause unexpected behavior. However, that's more of an admin privilege issue rather than a vulnerability in the code.

There's also a possible division rounding issue. For example, in _computeShareCount, if the division isn't exact, some dust amounts might be left in the contract. But this is common in such contracts and usually handled by allowing the last person to claim the remainder. However, in this contract, since shares are cumulative, maybe the dust could accumulate and not be distributed. Let's see: each time sendFees is called, the _amount is split into shares based on weights. If the division isn't exact, the sum of shares might be less than _amount. The remaining tokens would stay in the contract and be part of the next totalReceived in getAmountDue. So over time, it could accumulate and be distributed proportionally. But that depends on the implementation. Wait, in _computeShareCount, they do (amount * weight) / totalWeights. If multiple shareholders, the sum of all shares might be less than the total amount. Let's say _amount is 100, and two shareholders each with weight 1, totalWeights 2. Each gets 50, sum is 100. But if _amount is 101, each would get 50.5, but since it's integer division, 50 each, sum is 100, leaving 1. That 1 would remain in the contract's balance and be added to the next totalReceived. So over time, the leftover would be distributed. But if no further sendFees calls, that 1 would stay. So maybe not a vulnerability, but a known issue with division.

Another potential issue: The setShareholders function doesn't check for duplicate accounts. If the same account is added multiple times, their weight would be added each time. For example, if the owner adds the same address twice in _accounts, their total weight would be the sum of the two entries, leading to more shares. This could be a mistake by the owner, but the contract allows it, leading to unintended higher shares for that account.

Looking at the _addShareholder function: It requires that the weight is >0, but when the owner calls setShareholders, each account's weight must be >0. However, the owner could set a weight to zero via updateShareholder, but in that function, the new weight is checked only by the require statement that the totalWeights after update is >0. So the owner could set a shareholder's weight to zero, which would remove their weight from totalWeights. However, their existing shares in tokens are not affected. So they could still claim their previous shares, but future distributions wouldn't include them. But the code allows setting a weight to zero, which could be a way to disable a shareholder from future distributions. However, in the _addShareholder function, the private function checks for weight >0. So during setShareholders, adding a zero weight is prevented. Wait, in setShareholders, the code loops through _accounts and _weights and calls _addShareholder for each. _addShareholder checks that _weight >0. So the owner can't add a shareholder with zero weight. But in updateShareholder, they can set a shareholder's weight to zero. Because the updateShareholder function allows any _weight as long as the totalWeights after is >0. So if the owner sets a shareholder's weight to zero, the totalWeights would decrease, but the shareholder's existing shares in tokens remain. So in future sendFees, that shareholder would not receive new shares, but old shares are still there. This could be a way to stop a shareholder from receiving new distributions but still allowing them to claim old ones. But if the intention is to completely remove a shareholder, this isn't sufficient because their existing shares aren't revoked. So again, the issue is that the contract doesn't handle the removal of shareholders' existing shares, only stops them from receiving new distributions.

Another thing: The getAmountDue function uses _token.balanceOf(address(this)). But since the contract can receive tokens outside of sendFees (like someone directly transferring), this balance could include those tokens, leading to incorrect calculations. For example, if someone sends ERC20 tokens to the contract directly, those tokens would be considered part of the totalReceived, and thus distributed to shareholders. This is a vulnerability because it allows anyone to inflate the balance, causing shareholders to receive tokens that weren't intended to be distributed. For instance, an attacker could send a small amount of a worthless token, and when someone calls sendFees for that token, the existing balance (including the attacker's transfer) would be distributed. But in this case, sendFees is called by someone else, but the totalReceived is based on balance, which includes any direct transfers. So this could be exploited to trick the contract into distributing unintended tokens.

Wait, in sendFees, the function transfers _amount from the sender to the contract. Then, for each shareholder, it adds shares based on (_amount * weight) / totalWeights. But the getAmountDue function uses the current balance, which is _amount plus any existing balance. So if there was a prior balance (from direct transfers), that would be included in totalReceived. So when sendFees is called, the existing balance (from direct transfers) plus the new _amount is used to calculate the shares. This would lead to incorrect distribution because the direct transfers are not part of the _amount sent via sendFees. So the shares for the new _amount would be calculated, but the existing balance (from direct sends) would also be distributed, leading to more shares than intended. This is a problem.

For example: Suppose the contract already has 100 tokens from a direct transfer. Then someone calls sendFees with _amount = 100. The totalReceived in getAmountDue becomes 100 (existing) + 100 (new) = 200. The shares for each shareholder would be computed as (100 * weight) / totalWeights, but the getAmountDue would calculate based on 200. This leads to the existing 100 tokens being distributed along with the new 100, even though only 100 was intended. So the direct transfers get swept into the shares, leading to loss of funds for the person who called sendFees, as their tokens are combined with existing ones. This is a major vulnerability.

Moreover, when sendFees is called, it adds shares based on the _amount provided, but the getAmountDue uses the total balance. So the shares added are proportional to _amount, but the actual distribution is based on the contract's balance. If the contract already had a balance, the shares would be under or over what they should be. This discrepancy allows for manipulation. For example, an attacker could front-run a sendFees transaction by sending some tokens to the contract, thereby increasing the totalReceived, leading to more tokens being distributed than intended. The person calling sendFees would have their _amount combined with the attacker's sent tokens, and the shares would be miscalculated.

Another vulnerability: In sendFeesWithRoyalties, the _royaltiesTarget can be any address, including a contract. But when adding shares for _royaltiesTarget, if that target is malicious, could they perform some reentrancy? But the function is nonReentrant, so maybe not. However, the shares are added, and when the royaltiesTarget calls releaseToken, it would transfer the tokens. But since the release functions are nonReentrant, reentrancy is prevented there. So maybe not a reentrancy issue here.

Also, in the constructor, setShareholders is called, which in turn calls _addShareholder for each account. The setShareholders function deletes the existing shareholders array. But in the constructor, the array is empty initially, so that's okay. But if during deployment, _accounts has a zero address, _addShareholder would check for weight >0 but not for account != address(0). So a shareholder could be the zero address, which would cause tokens to be sent to address(0) when released. That's a possible vulnerability if the owner mistakenly adds the zero address as a shareholder.

Wait, looking at _addShareholder: It takes _account and _weight. There's no check that _account is not address(0). So the owner could add the zero address as a shareholder, leading to funds being unrecoverable once shares are assigned to it. That's a vulnerability because it allows the owner to mistakenly configure the contract to send funds to address(0), which is irreversible.

Another thing: The findShareholder function loops through the array and reverts if not found. If there are many shareholders, this could run into gas limits. But that's a view function, so maybe not a big issue. However, if used in a transaction, it could cause out-of-gas errors, but the function is external view, so it's not called in transactions that modify state. So probably not a vulnerability, but a potential gas inefficiency.

Also, when releasing ETH, the contract converts WETH to ETH. But if the WETH contract has any issues (e.g., it's a malicious WETH), this could be a problem. However, the WETH address is set as immutable in the constructor, so once deployed, it can't be changed. So if the owner sets a malicious WETH, that's a problem. But the contract is dependent on the correctness of the WETH address, which is a trust assumption. But that's beyond the contract's control once deployed.

In summary, the main vulnerabilities I can see are:

1. **Direct Token Transfers Affect Accounting**: If someone sends ERC20 tokens or ETH/WETH directly to the contract outside of the sendFees functions, it will be included in the totalReceived calculations, leading to incorrect distribution of funds. This allows attackers to manipulate distributions by front-running transactions and injecting tokens.

2. **Shareholders' Existing Shares Not Cleared on Removal**: When shareholders are removed via setShareholders, their existing shares in previous token distributions are not cleared. This allows removed shareholders to continue claiming funds from previous allocations.

3. **Zero Address Shareholder**: The contract allows the owner to add a shareholder with address(0), leading to irreversible loss of funds sent to the zero address.

4. **Division Rounding Errors**: The use of integer division in share calculations could leave dust amounts in the contract, but these are carried over into future distributions. However, if distributions stop, these funds could be locked indefinitely.

5. **Dependence on External WETH Contract**: If the WETH contract is compromised or incorrectly set, the ETH handling could malfunction. But this is more of a configuration risk.

6. **Possible Duplicate Shareholders in setShareholders**: The owner could accidentally add the same account multiple times, leading to higher weights than intended.

7. **Unhandled ETH in Contract**: If ETH is sent directly to the contract (not via WETH), it's not tracked and can't be released, leading to stuck funds.

Let me verify each of these points again.

For point 1: Yes, because getAmountDue uses the current balance of the token, any direct transfer increases totalReceived, leading to higher amounts due. The shares added in sendFees are based on the sent _amount, but the actual distribution includes the pre-existing balance. So the person calling sendFees is effectively paying for the distribution of their tokens plus any existing ones. This is a critical vulnerability.

Point 2: Yes. When shareholders are updated, their old shares for each token remain. So even after removal, they can claim old allocations. For example, if shareholder A is removed, they still have shares in token X from before and can release them. The setShareholders function only affects future distributions.

Point 3: The _addShareholder function does not check if _account is address(0). So the owner can mistakenly add the zero address as a shareholder. When fees are sent, shares are allocated to address(0), and releasing them would send tokens to zero address, burning them.

Point 4: Yes, but as mentioned, dust might accumulate. However, since the contract uses cumulative accounting, future sendFees would distribute the dust. But if no more sendFees, dust remains.

Point 5: The WETH address is set in the constructor and is immutable. If it's incorrect, the contract would malfunction. But this is a deployment issue, not a code vulnerability per se.

Point 6: setShareholders allows adding the same account multiple times, which would multiply their weight. For example, adding [Alice, Alice] with [10, 10] would result in Alice having a weight of 20. This is possible if the owner makes a mistake, leading to unintended high weights.

Point 7: ETH sent directly (not via WETH) isn't tracked. The receive function only accepts ETH from WETH. So any other ETH sent via a regular transfer would remain in the contract's balance but isn't part of the WETH token records. Thus, it's stuck unless the contract has a function to handle it, which it doesn't.

Another point: The releaseToken and releaseETH functions use nonReentrant, which is good. So reentrancy is mitigated there.

Wait, another possible issue: In the sendFeesWithRoyalties function, the royaltiesTarget could be a contract that doesn't handle ERC20 tokens properly, causing tokens to be stuck. But that's a user error, not a contract vulnerability.

Another thing: The getAmountDue function could be manipulated by transferring tokens to the contract right before a release, making the balance higher, thus increasing the amount due. But this ties into point 1, where direct transfers affect accounting.

So the main vulnerabilities are the ones listed above. The most critical ones are points 1 and 2, and 3.","```
1. Duplicate Shareholders in Configuration
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Duplicate Shareholders in Configuration"".
   - This appears at rank 5 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank \( k \) (\( P@k \)) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Here, there is only one true positive up to rank 5.
   - \( P@5 = \frac{1}{5} = 0.2 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - \( AP = 0.2 \).

**Output**:
```
0.2
```"
,,,,,,,,1,6,,,1,1,5,16,,,
