nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
StabilityPool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";


/*
 * The Stability Pool holds YUSD tokens deposited by Stability Pool depositors.
 *
 * When a trove is liquidated, then depending on system conditions, some of its YUSD debt gets offset with
 * YUSD in the Stability Pool: that is, the offset debt evaporates, and an equal amount of YUSD tokens in the Stability Pool is burned.
 *
 * Thus, a liquidation causes each depositor to receive a YUSD loss, in proportion to their deposit as a share of total deposits.
 * They also receive an Collateral gain, as the amount of collateral of the liquidated trove is distributed among Stability depositors,
 * in the same proportion.
 *
 * When a liquidation occurs, it depletes every deposit by the same fraction: for example, a liquidation that depletes 40%
 * of the total YUSD in the Stability Pool, depletes 40% of each deposit.
 *
 * A deposit that has experienced a series of liquidations is termed a ""compounded deposit"": each liquidation depletes the deposit,
 * multiplying it by some factor in range ]0,1[
 *
 *
 * --- IMPLEMENTATION ---
 *
 * We use a highly scalable method of tracking deposits and Collateral gains that has O(1) complexity.
 *
 * When a liquidation occurs, rather than updating each depositor's deposit and Collateral gain, we simply update two state variables:
 * a product P, and a sum S. These are kept track for each type of collateral.
 *
 * A mathematical manipulation allows us to factor out the initial deposit, and accurately track all depositors' compounded deposits
 * and accumulated Collateral amount gains over time, as liquidations occur, using just these two variables P and S. When depositors join the
 * Stability Pool, they get a snapshot of the latest P and S: P_t and S_t, respectively.
 *
 * The formula for a depositor's accumulated Collateral amount gain is derived here:
 * https://github.com/liquity/dev/blob/main/packages/contracts/mathProofs/Scalable%20Compounding%20Stability%20Pool%20Deposits.pdf
 *
 * For a given deposit d_t, the ratio P/P_t tells us the factor by which a deposit has decreased since it joined the Stability Pool,
 * and the term d_t * (S - S_t)/P_t gives us the deposit's total accumulated Collateral amount gain.
 *
 * Each liquidation updates the product P and sum S. After a series of liquidations, a compounded deposit and corresponding Collateral amount gain
 * can be calculated using the initial deposit, the depositorâ€™s snapshots of P and S, and the latest values of P and S.
 *
 * Any time a depositor updates their deposit (withdrawal, top-up) their accumulated Collateral amount gain is paid out, their new deposit is recorded
 * (based on their latest compounded deposit and modified by the withdrawal/top-up), and they receive new snapshots of the latest P and S.
 * Essentially, they make a fresh deposit that overwrites the old one.
 *
 *
 * --- SCALE FACTOR ---
 *
 * Since P is a running product in range ]0,1] that is always-decreasing, it should never reach 0 when multiplied by a number in range ]0,1[.
 * Unfortunately, Solidity floor division always reaches 0, sooner or later.
 *
 * A series of liquidations that nearly empty the Pool (and thus each multiply P by a very small number in range ]0,1[ ) may push P
 * to its 18 digit decimal limit, and round it to 0, when in fact the Pool hasn't been emptied: this would break deposit tracking.
 *
 * So, to track P accurately, we use a scale factor: if a liquidation would cause P to decrease to <1e-9 (and be rounded to 0 by Solidity),
 * we first multiply P by 1e9, and increment a currentScale factor by 1.
 *
 * The added benefit of using 1e9 for the scale factor (rather than 1e18) is that it ensures negligible precision loss close to the
 * scale boundary: when P is at its minimum value of 1e9, the relative precision loss in P due to floor division is only on the
 * order of 1e-9.
 *
 * --- EPOCHS ---
 *
 * Whenever a liquidation fully empties the Stability Pool, all deposits should become 0. However, setting P to 0 would make P be 0
 * forever, and break all future reward calculations.
 *
 * So, every time the Stability Pool is emptied by a liquidation, we reset P = 1 and currentScale = 0, and increment the currentEpoch by 1.
 *
 * --- TRACKING DEPOSIT OVER SCALE CHANGES AND EPOCHS ---
 *
 * When a deposit is made, it gets snapshots of the currentEpoch and the currentScale.
 *
 * When calculating a compounded deposit, we compare the current epoch to the deposit's epoch snapshot. If the current epoch is newer,
 * then the deposit was present during a pool-emptying liquidation, and necessarily has been depleted to 0.
 *
 * Otherwise, we then compare the current scale to the deposit's scale snapshot. If they're equal, the compounded deposit is given by d_t * P/P_t.
 * If it spans one scale change, it is given by d_t * P/(P_t * 1e9). If it spans more than one scale change, we define the compounded deposit
 * as 0, since it is now less than 1e-9'th of its initial value (e.g. a deposit of 1 billion YUSD has depleted to < 1 YUSD).
 *
 *
 *  --- TRACKING DEPOSITOR'S COLLATERAL AMOUNT GAIN OVER SCALE CHANGES AND EPOCHS ---
 *
 * In the current epoch, the latest value of S is stored upon each scale change, and the mapping (scale -> S) is stored for each epoch.
 *
 * This allows us to calculate a deposit's accumulated Collateral amount gain, during the epoch in which the deposit was non-zero and earned Collateral amount.
 *
 * We calculate the depositor's accumulated Collateral amount gain for the scale at which they made the deposit, using the Collateral amount gain formula:
 * e_1 = d_t * (S - S_t) / P_t
 *
 * and also for scale after, taking care to divide the latter by a factor of 1e9:
 * e_2 = d_t * S / (P_t * 1e9)
 *
 * The gain in the second scale will be full, as the starting point was in the previous scale, thus no need to subtract anything.
 * The deposit therefore was present for reward events from the beginning of that second scale.
 *
 *        S_i-S_t + S_{i+1}
 *      .<--------.------------>
 *      .         .
 *      . S_i     .   S_{i+1}
 *   <--.-------->.<----------->
 *   S_t.         .
 *   <->.         .
 *      t         .
 *  |---+---------|-------------|-----...
 *         i            i+1
 *
 * The sum of (e_1 + e_2) captures the depositor's total accumulated Collateral amount gain, handling the case where their
 * deposit spanned one scale change. We only care about gains across one scale change, since the compounded
 * deposit is defined as being 0 once it has spanned more than one scale change.
 *
 *
 * --- UPDATING P WHEN A LIQUIDATION OCCURS ---
 *
 * Please see the implementation spec in the proof document, which closely follows on from the compounded deposit / Collateral amount gain derivations:
 * https://github.com/liquity/liquity/blob/master/papers/Scalable_Reward_Distribution_with_Compounding_Stakes.pdf
 *
 *
 * --- YETI ISSUANCE TO STABILITY POOL DEPOSITORS ---
 *
 * An YETI issuance event occurs at every deposit operation, and every liquidation.
 *
 * Each deposit is tagged with the address of the front end through which it was made.
 *
 * All deposits earn a share of the issued YETI in proportion to the deposit as a share of total deposits. The YETI earned
 * by a given deposit, is split between the depositor and the front end through which the deposit was made, based on the front end's kickbackRate.
 *
 * Please see the system Readme for an overview:
 * https://github.com/liquity/dev/blob/main/README.md#yeti-issuance-to-stability-providers
 *
 * We use the same mathematical product-sum approach to track YETI gains for depositors, where 'G' is the sum corresponding to YETI gains.
 * The product P (and snapshot P_t) is re-used, as the ratio P/P_t tracks a deposit's depletion due to liquidations.
 *
 */
contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    // Needed to check if there are pending liquidations
    ISortedTroves internal sortedTroves;

    // Tracker for YUSD held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.
    uint256 internal totalYUSDDeposits;

    // totalColl.tokens and totalColl.amounts should be the same length and always be the same length
    // as whitelist.validCollaterals(). Anytime a new collateral is added to whitelist
    // both lists are lengthened
    newColls internal totalColl;

    // --- Data structures ---

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; // depositor address -> Deposit struct

    /* depositSnapshots maintains an entry for each depositor
     * that tracks P, S, G, scale, and epoch.
     * depositor's snapshot is updated only when they
     * deposit or withdraw from stability pool
     * depositSnapshots are used to allocate YETI rewards, calculate compoundedYUSDDepositAmount
     * and to calculate how much Collateral amount the depositor is entitled to
     */
    mapping(address => Snapshots) public depositSnapshots; // depositor address -> snapshots struct

    mapping(address => FrontEnd) public frontEnds; // front end address -> FrontEnd struct
    mapping(address => uint256) public frontEndStakes; // front end address -> last recorded total deposits, tagged with that front end
    mapping(address => Snapshots) public frontEndSnapshots; // front end address -> snapshots struct

    /*  Product 'P': Running product by which to multiply an initial deposit, in order to find the current compounded deposit,
     * after a series of liquidations have occurred, each of which cancel some YUSD debt with the deposit.
     *
     * During its lifetime, a deposit's value evolves from d_t to d_t * P / P_t , where P_t
     * is the snapshot of P taken at the instant the deposit was made. 18-digit decimal.
     */
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    // Each time the scale of P shifts by SCALE_FACTOR, the scale is incremented by 1
    uint128 public currentScale;

    // With each offset that fully empties the Pool, the epoch is incremented by 1
    uint128 public currentEpoch;

    /* Collateral amount Gain sum 'S': During its lifetime, each deposit d_t earns an Collateral amount gain of ( d_t * [S - S_t] )/P_t,
     * where S_t is the depositor's snapshot of S taken at the time t when the deposit was made.
     *
     * The 'S' sums are stored in a nested mapping (epoch => scale => sum):
     *
     * - The inner mapping records the sum S at different scales
     * - The middle mapping records the (scale => sum) mappings, for different epochs.
     * - The outer mapping records the (collateralType => (epoch => (scale => sum)) mappings
     */
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    /*
     * Similarly, the sum 'G' is used to calculate YETI gains. During it's lifetime, each deposit d_t earns a YETI gain of
     *  ( d_t * [G - G_t] )/P_t, where G_t is the depositor's snapshot of G taken at time t when  the deposit was made.
     *
     *  YETI reward events occur are triggered by depositor operations (new deposit, topup, withdrawal), and liquidations.
     *  In each case, the YETI reward is issued (i.e. G is updated), before other state changes are made.
     */
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    // Error tracker for the error correction in the YETI issuance calculation
    uint256 public lastYETIError;
    // Error trackers for the error correction in the offset calculation
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    // --- Events ---

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    // --- Getters for public variables. Required by IPool interface --- 

    // total VC of collateral in Stability Pool
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    /*
     * Returns all collateral balances in state. Not necessarily the contract's actual balances.
     */
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    // --- External Depositor Functions ---

    /*  provideToSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Tags the deposit with the provided front end tag param, if it's a new deposit
     * - Sends depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.
     */
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake:
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        // just pulls YUSD into the pool, updates totalYUSDDeposits variable for the stability pool
        // and throws an event
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    /*  withdrawFromSP():
     *
     * - Triggers a YETI issuance, based on time passed since the last issuance. The YETI issuance is shared between *all* depositors and front ends
     * - Removes the deposit's front end tag if it is a full withdrawal
     * - Sends all depositor's accumulated gains (YETI, collateral assets) to depositor
     * - Sends the tagged front end's accumulated YETI gains to the tagged front end
     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.
     *
     * If _amount > userDeposit, the user withdraws all of their compounded deposit.
     */
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); // Needed only for event log

        // First pay out any YETI gains
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        // Update front end stake
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        // Update deposit
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); // YUSD Loss required for event log

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    // --- YETI issuance functions ---

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        /*
         * When total deposits is 0, G is not updated. In this case, the YETI issued can not be obtained by later
         * depositors - it is missed out on, and remains in the balanceof the CommunityIssuance contract.
         *
         */
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        /*
         * Calculate the YETI-per-unit staked.  Division uses a ""feedback"" error correction, to keep the
         * cumulative error low in the running total G:
         *
         * 1) Form a numerator which compensates for the floor division error that occurred the last time this
         * function was called.
         * 2) Calculate ""per-unit-staked"" ratio.
         * 3) Multiply the ratio back by its denominator, to reveal the current floor division error.
         * 4) Store this error for use in the next correction when this function is called.
         * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
         */
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    // --- Liquidation functions ---

    /*
     * Cancels out the specified debt against the YUSD contained in the Stability Pool (as far as possible)
     * and transfers the Trove's collateral from ActivePool to StabilityPool.
     * Only called by liquidation functions in the TroveManager.
     */
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; // cached to save an SLOAD
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); // updates S and P
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    // --- Offset helper functions ---


    /*
    * Compute the YUSD and Collateral amount rewards. Uses a ""feedback"" error correction, to keep
    * the cumulative error in the P and S state variables low:
    *
    * 1) Form numerators which compensate for the floor division errors that occurred the last time this
    * function was called.
    * 2) Calculate ""per-unit-staked"" ratios.
    * 3) Multiply each ratio back by its denominator, to reveal the current floor division error.
    * 4) Store these errors for use in the next correction when this function is called.
    * 5) Note: static analysis tools complain about this ""division before multiplication"", however, it is intended.
    */
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; // When the Pool depletes to 0, so does each deposit
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            /*
             * Add 1 to make error in quotient positive. We want ""slightly too much"" YUSD loss,
             * which ensures the error in any given compoundedYUSDDeposit favors the Stability Pool.
             */
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    // Update the Stability Pool reward sum S and product P
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        /*
         * The newProductFactor is the factor by which to change all deposits, due to the depletion of Stability Pool YUSD in the liquidation.
         * We make the product factor 0 if there was a pool-emptying. Otherwise, it is (1 - YUSDLossPerUnitStaked)
         */
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        /*
         * Calculate the new S first, before we update P.
         * The Collateral amount gain for any given depositor from a liquidation depends on the value of their deposit
         * (and the value of totalDeposits) prior to the Stability being depleted by the debt in the liquidation.
         *
         * Since S corresponds to Collateral amount gain, and P to deposit loss, we update S first.
         */
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            // uint256 marginalAssetGain = _AssetGainPerUnitStaked[i]; only used once, named here for clarity.
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        // If the Stability Pool was emptied, increment the epoch, and reset the scale and product P
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            // If multiplying P by a non-zero product factor would reduce P below the scale boundary, increment the scale
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    // Internal function to move offset collateral and debt between pools. 
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        // Cancel the liquidated YUSD debt with the YUSD in the stability pool
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        // Burn the debt that was successfully offset
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    // Decreases YUSD Stability pool balance. 
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    // --- Reward calculator functions for depositor and front end ---

    /* Calculates the gains earned by the deposit since its last snapshots were taken.
     * Given by the formula:  E = d0 * (S - S(0))/P(0)
     * where S(0) and P(0) are the depositor's snapshots of the sum S and product P, respectively.
     * d0 is the last recorded deposit value.
     * returns assets, amounts
     */
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    // get gains on each possible asset by looping through
    // assets with _getGainFromSnapshots function
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    // gets the gain in S for a given asset
    // for a user who deposited initialDeposit
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        /*
         * Grab the sum 'S' from the epoch at which the stake was made. The Collateral amount gain may span up to one scale change.
         * If it does, the second portion of the Collateral amount gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    /*
     * Calculate the YETI gain earned by a deposit since its last snapshots were taken.
     * Given by the formula:  YETI = d0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     * d0 is the last recorded deposit value.
     */
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        /*
         * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.
         * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through
         * which they made their deposit.
         */
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    /*
     * Return the YETI gain earned by the front end. Given by the formula:  E = D0 * (G - G(0))/P(0)
     * where G(0) and P(0) are the depositor's snapshots of the sum G and product P, respectively.
     *
     * D0 is the last recorded value of the front end's total tagged deposits.
     */
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        /*
         * Grab the sum 'G' from the epoch at which the stake was made. The YETI gain may span up to one scale change.
         * If it does, the second portion of the YETI gain is scaled by 1e9.
         * If the gain spans no scale change, the second portion will be 0.
         */
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    // --- Compounded deposit and compounded front end stake ---

    /*
     * Return the user's compounded deposit. Given by the formula:  d = d0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken when they last updated their deposit.
     */
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    /*
     * Return the front end's compounded stake. Given by the formula:  D = D0 * P/P(0)
     * where P(0) is the depositor's snapshot of the product P, taken at the last time
     * when one of the front end's tagged deposits updated their deposit.
     *
     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.
     */
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    // Internal function, used to calculate compounded deposits and compounded front end stakes.
    // returns 0 if the snapshots were taken prior to a a pool-emptying event
    // also returns zero if scaleDiff (currentScale.sub(scaleSnapshot)) is more than 2 or
    // If the scaleDiff is 0 or 1,
    // then adjust for changes in P and scale changes to calculate a compoundedStake.
    // IF the final compoundedStake isn't less than a billionth of the initial stake, return it.this
    // otherwise, just return 0.
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        // If stake was made before a pool-emptying event, then it has been fully cancelled with debt -- so, return 0
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        /* Compute the compounded stake. If a scale change in P was made during the stake's lifetime,
         * account for it. If more than one scale change was made, then the stake has decreased by a factor of
         * at least 1e-9 -- so return 0.
         */
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            // if scaleDiff >= 2
            compoundedStake = 0;
        }

        /*
         * If compounded deposit is less than a billionth of the initial deposit, return 0.
         *
         * NOTE: originally, this line was in place to stop rounding errors making the deposit too large. However, the error
         * corrections should ensure the error in P ""favors the Pool"", i.e. any given compounded deposit should slightly less
         * than it's theoretical value.
         *
         * Thus it's unclear whether this line is still really needed.
         */
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    // --- Sender functions for YUSD deposit, Collateral gains and YETI gains ---

    // Transfer the YUSD tokens from the user to the Stability Pool's address, and update its recorded YUSD
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                // In this case update the rewards from the treasury to the caller 
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                // unwrapFor ends the rewards for the caller and transfers the tokens to the _to param. 
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    // Send YUSD to user and decrease YUSD in Pool
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    // --- External Front End functions ---

    // Front end makes a one-time selection of kickback rate upon registering
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    // --- Stability Pool Deposit Functionality ---

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    // if _newValue is zero, delete snapshot for given _depositor and emit event
    // otherwise, add an entry or update existing entry for _depositor in the depositSnapshots
    // with current values for P, S, G, scale and epoch and then emit event.
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        // Get S and G for the current epoch and current scale
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P, sum S, and sum G, for the depositor
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        // Get G for the current epoch and current scale
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        // Record new snapshots of the latest running product P and sum G for the front end
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        // Pay out front end's YETI gain
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        // Pay out depositor's YETI gain
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    // --- 'require' functions ---

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    // Should be called by ActivePool
    // __after__ collateral is transferred to this contract from Active Pool
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    // should be called anytime a collateral is added to whitelist
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    // Gets reward snapshot S for certain collateral and depositor. 
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",12382.0,1177.0,"[H-01] receiveCollateral() can be called by anyone
In StabilityPool.sol, the `receiveCollateral()` function should be called by ActivePool per comments, but anyone can call it passing in `_tokens` and `_amounts` args to update stability pool balances.",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/IStabilityPool.sol"";
import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ICommunityIssuance.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IERC20.sol"";
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/LiquitySafeMath128.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/SafeERC20.sol"";



contract StabilityPool is LiquityBase, Ownable, CheckContract, IStabilityPool {
    using LiquitySafeMath128 for uint128;
    using SafeERC20 for IERC20;

    string public constant NAME = ""StabilityPool"";

    address internal troveManagerLiquidationsAddress;
    address internal whitelistAddress;

    IBorrowerOperations internal borrowerOperations;
    ITroveManager internal troveManager;
    IYUSDToken internal yusdToken;
    ICommunityIssuance internal communityIssuance;
    
    ISortedTroves internal sortedTroves;

    
    uint256 internal totalYUSDDeposits;

    
    
    
    newColls internal totalColl;

    

    struct FrontEnd {
        uint256 kickbackRate;
        bool registered;
    }

    struct Deposit {
        uint256 initialValue;
        address frontEndTag;
    }

    struct Snapshots {
        mapping(address => uint256) S;
        uint256 P;
        uint256 G;
        uint128 scale;
        uint128 epoch;
    }

    mapping(address => Deposit) public deposits; 

    
    mapping(address => Snapshots) public depositSnapshots; 

    mapping(address => FrontEnd) public frontEnds; 
    mapping(address => uint256) public frontEndStakes; 
    mapping(address => Snapshots) public frontEndSnapshots; 

    
    uint256 public P = DECIMAL_PRECISION;

    uint256 public constant SCALE_FACTOR = 1e9;

    
    uint128 public currentScale;

    
    uint128 public currentEpoch;

    
    mapping(address => mapping(uint128 => mapping(uint128 => uint256))) public epochToScaleToSum;

    
    mapping(uint128 => mapping(uint128 => uint256)) public epochToScaleToG;

    
    uint256 public lastYETIError;
    
    uint256[] public lastAssetError_Offset;
    uint256 public lastYUSDLossError_Offset;

    

    event StabilityPoolBalanceUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolBalancesUpdated(address[] assets, uint256[] amounts);
    event StabilityPoolYUSDBalanceUpdated(uint256 _newBalance);

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _newActivePoolAddress);
    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);
    event YUSDTokenAddressChanged(address _newYUSDTokenAddress);
    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);
    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);

    event P_Updated(uint256 _P);
    event S_Updated(address _asset, uint256 _S, uint128 _epoch, uint128 _scale);
    event G_Updated(uint256 _G, uint128 _epoch, uint128 _scale);
    event EpochUpdated(uint128 _currentEpoch);
    event ScaleUpdated(uint128 _currentScale);

    event FrontEndRegistered(address indexed _frontEnd, uint256 _kickbackRate);
    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);

    event DepositSnapshotUpdated(address indexed _depositor, uint256 _P, uint256 _G);
    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint256 _P, uint256 _G);
    event UserDepositChanged(address indexed _depositor, uint256 _newDeposit);
    event FrontEndStakeChanged(
        address indexed _frontEnd,
        uint256 _newFrontEndStake,
        address _depositor
    );

    event GainsWithdrawn(
        address indexed _depositor,
        address[] collaterals,
        uint256[] _amounts,
        uint256 _YUSDLoss
    );
    event YETIPaidToDepositor(address indexed _depositor, uint256 _YETI);
    event YETIPaidToFrontEnd(address indexed _frontEnd, uint256 _YETI);
    event CollateralSent(address _to, address[] _collaterals, uint256[] _amounts);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _activePoolAddress,
        address _yusdTokenAddress,
        address _sortedTrovesAddress,
        address _communityIssuanceAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress
    ) external override onlyOwner {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_communityIssuanceAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);

        borrowerOperations = IBorrowerOperations(_borrowerOperationsAddress);
        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        communityIssuance = ICommunityIssuance(_communityIssuanceAddress);
        whitelist = IWhitelist(_whitelistAddress);

        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        whitelistAddress = _whitelistAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit CommunityIssuanceAddressChanged(_communityIssuanceAddress);

        _renounceOwnership();
    }

    

    
    function getVC() external view override returns (uint256) {
        return _getVCColls(totalColl);
    }

    function getCollateral(address _collateral) external view override returns (uint256) {
        uint256 collateralIndex = whitelist.getIndex(_collateral);
        return totalColl.amounts[collateralIndex];
    }

    
    function getAllCollateral() external view override returns (address[] memory, uint256[] memory) {
        return (totalColl.tokens, totalColl.amounts);
    }

    function getTotalYUSDDeposits() external view override returns (uint256) {
        return totalYUSDDeposits;
    }

    

    
    function provideToSP(uint256 _amount, address _frontEndTag) external override {
        _requireFrontEndIsRegisteredOrZero(_frontEndTag);
        _requireFrontEndNotRegistered(msg.sender);
        _requireNonZeroAmount(_amount);

        uint256 initialDeposit = deposits[msg.sender].initialValue;

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        if (initialDeposit == 0) {
            _setFrontEndTag(msg.sender, _frontEndTag);
        }
        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);
        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.add(_amount);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        
        
        _sendYUSDtoStabilityPool(msg.sender, _amount);

        uint256 newDeposit = compoundedYUSDDeposit.add(_amount);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    
    function withdrawFromSP(uint256 _amount) external override {
        if (_amount != 0) {
            _requireNoUnderCollateralizedTroves();
        }
        uint256 initialDeposit = deposits[msg.sender].initialValue;
        _requireUserHasDeposit(initialDeposit);

        ICommunityIssuance communityIssuanceCached = communityIssuance;

        _triggerYETIIssuance(communityIssuanceCached);

        (address[] memory assets, uint256[] memory amounts) = getDepositorGains(msg.sender);

        uint256 compoundedYUSDDeposit = getCompoundedYUSDDeposit(msg.sender);

        uint256 YUSDtoWithdraw = LiquityMath._min(_amount, compoundedYUSDDeposit);
        uint256 YUSDLoss = initialDeposit.sub(compoundedYUSDDeposit); 

        
        address frontEnd = deposits[msg.sender].frontEndTag;
        _payOutYETIGains(communityIssuanceCached, msg.sender, frontEnd);

        
        uint256 compoundedFrontEndStake = getCompoundedFrontEndStake(frontEnd);
        uint256 newFrontEndStake = compoundedFrontEndStake.sub(YUSDtoWithdraw);
        _updateFrontEndStakeAndSnapshots(frontEnd, newFrontEndStake);
        emit FrontEndStakeChanged(frontEnd, newFrontEndStake, msg.sender);

        _sendYUSDToDepositor(msg.sender, YUSDtoWithdraw);

        
        uint256 newDeposit = compoundedYUSDDeposit.sub(YUSDtoWithdraw);
        _updateDepositAndSnapshots(msg.sender, newDeposit);
        emit UserDepositChanged(msg.sender, newDeposit);

        emit GainsWithdrawn(msg.sender, assets, amounts, YUSDLoss); 

        _sendGainsToDepositor(msg.sender, assets, amounts);
    }

    

    function _triggerYETIIssuance(ICommunityIssuance _communityIssuance) internal {
        uint256 YETIIssuance = _communityIssuance.issueYETI();
        _updateG(YETIIssuance);
    }

    function _updateG(uint256 _YETIIssuance) internal {
        uint256 totalYUSD = totalYUSDDeposits; 
        
        if (totalYUSD == 0 || _YETIIssuance == 0) {
            return;
        }

        uint256 YETIPerUnitStaked;
        YETIPerUnitStaked = _computeYETIPerUnitStaked(_YETIIssuance, totalYUSD);

        uint256 marginalYETIGain = YETIPerUnitStaked.mul(P);
        epochToScaleToG[currentEpoch][currentScale] = epochToScaleToG[currentEpoch][currentScale]
            .add(marginalYETIGain);

        emit G_Updated(epochToScaleToG[currentEpoch][currentScale], currentEpoch, currentScale);
    }

    function _computeYETIPerUnitStaked(uint256 _YETIIssuance, uint256 _totalYUSDDeposits)
        internal
        returns (uint256)
    {
        
        uint256 YETINumerator = _YETIIssuance.mul(DECIMAL_PRECISION).add(lastYETIError);

        uint256 YETIPerUnitStaked = YETINumerator.div(_totalYUSDDeposits);
        lastYETIError = YETINumerator.sub(YETIPerUnitStaked.mul(_totalYUSDDeposits));

        return YETIPerUnitStaked;
    }

    

    
    function offset(
        uint256 _debtToOffset,
        address[] memory _tokens,
        uint256[] memory _amountsAdded
    ) external override {
        _requireCallerIsTML();
        uint256 totalYUSD = totalYUSDDeposits; 
        if (totalYUSD == 0 || _debtToOffset == 0) {
            return;
        }

        _triggerYETIIssuance(communityIssuance);

        (
            uint256[] memory AssetGainPerUnitStaked,
            uint256 YUSDLossPerUnitStaked
        ) = _computeRewardsPerUnitStaked(_tokens, _amountsAdded, _debtToOffset, totalYUSD);

        _updateRewardSumAndProduct(_tokens, AssetGainPerUnitStaked, YUSDLossPerUnitStaked); 
        _moveOffsetCollAndDebt(_tokens, _amountsAdded, _debtToOffset);
    }

    


    
    function _computeRewardsPerUnitStaked(
        address[] memory _tokens,
        uint256[] memory _amountsAdded,
        uint256 _debtToOffset,
        uint256 _totalYUSDDeposits
    ) internal returns (uint256[] memory AssetGainPerUnitStaked, uint256 YUSDLossPerUnitStaked) {
        uint256 amountsLen = _amountsAdded.length;
        uint256[] memory CollateralNumerators = new uint256[](amountsLen);
        uint256 currentP = P;

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            CollateralNumerators[i] = _amountsAdded[i].mul(DECIMAL_PRECISION).add(
                lastAssetError_Offset[tokenIDX]
            );
        }

        require(_debtToOffset <= _totalYUSDDeposits, ""SP:This debt less than totalYUSD"");
        if (_debtToOffset == _totalYUSDDeposits) {
            YUSDLossPerUnitStaked = DECIMAL_PRECISION; 
            lastYUSDLossError_Offset = 0;
        } else {
            uint256 YUSDLossNumerator = _debtToOffset.mul(DECIMAL_PRECISION).sub(
                lastYUSDLossError_Offset
            );
            
            YUSDLossPerUnitStaked = (YUSDLossNumerator.div(_totalYUSDDeposits)).add(1);
            lastYUSDLossError_Offset = (YUSDLossPerUnitStaked.mul(_totalYUSDDeposits)).sub(
                YUSDLossNumerator
            );
        }

        AssetGainPerUnitStaked = new uint256[](_amountsAdded.length);
        for (uint256 i; i < amountsLen; ++i) {
            AssetGainPerUnitStaked[i] = CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits);
        }

        for (uint256 i; i < amountsLen; ++i) {
            uint256 tokenIDX = whitelist.getIndex(_tokens[i]);
            lastAssetError_Offset[tokenIDX] = CollateralNumerators[i].sub(
                AssetGainPerUnitStaked[i].mul(_totalYUSDDeposits).div(currentP)
            );
        }

    }

    
    function _updateRewardSumAndProduct(
        address[] memory _assets,
        uint256[] memory _AssetGainPerUnitStaked,
        uint256 _YUSDLossPerUnitStaked
    ) internal {
        uint256 currentP = P;
        uint256 newP;

        require(_YUSDLossPerUnitStaked <= DECIMAL_PRECISION, ""SP: YUSDLoss < 1"");
        
        uint256 newProductFactor = uint256(DECIMAL_PRECISION).sub(_YUSDLossPerUnitStaked);

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;

        
        uint256 assetsLen = _assets.length;
        for (uint256 i; i < assetsLen; ++i) {
            address asset = _assets[i];
            
            
            uint256 currentAssetS = epochToScaleToSum[asset][currentEpochCached][currentScaleCached];
            uint256 newAssetS = currentAssetS.add(_AssetGainPerUnitStaked[i]);

            epochToScaleToSum[asset][currentEpochCached][currentScaleCached] = newAssetS;
            emit S_Updated(asset, newAssetS, currentEpochCached, currentScaleCached);
        }

        
        if (newProductFactor == 0) {
            currentEpoch = currentEpochCached.add(1);
            emit EpochUpdated(currentEpoch);
            currentScale = 0;
            emit ScaleUpdated(currentScale);
            newP = DECIMAL_PRECISION;

            
        } else if (currentP.mul(newProductFactor).div(DECIMAL_PRECISION) < SCALE_FACTOR) {
            newP = currentP.mul(newProductFactor).mul(SCALE_FACTOR).div(DECIMAL_PRECISION);
            currentScale = currentScaleCached.add(1);
            emit ScaleUpdated(currentScale);
        } else {
            newP = currentP.mul(newProductFactor).div(DECIMAL_PRECISION);
        }

        require(newP != 0, ""SP: P = 0"");
        P = newP;
        emit P_Updated(newP);
    }

    
    function _moveOffsetCollAndDebt(
        address[] memory _collsToAdd,
        uint256[] memory _amountsToAdd,
        uint256 _debtToOffset
    ) internal {
        IActivePool activePoolCached = activePool;
        
        activePoolCached.decreaseYUSDDebt(_debtToOffset);
        _decreaseYUSD(_debtToOffset);

        
        yusdToken.burn(address(this), _debtToOffset);

        activePoolCached.sendCollaterals(address(this), _collsToAdd, _amountsToAdd);
    }

    
    function _decreaseYUSD(uint256 _amount) internal {
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.sub(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    

    
    function getDepositorGains(address _depositor)
        public
        view
        override
        returns (address[] memory, uint256[] memory)
    {
        uint256 initialDeposit = deposits[_depositor].initialValue;

        if (initialDeposit == 0) {
            address[] memory emptyAddress = new address[](0);
            uint256[] memory emptyUint = new uint256[](0);
            return (emptyAddress, emptyUint);
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        return _calculateGains(initialDeposit, snapshots);
    }

    
    
    function _calculateGains(uint256 initialDeposit, Snapshots storage snapshots)
        internal
        view
        returns (address[] memory assets, uint256[] memory amounts)
    {
        assets = whitelist.getValidCollateral();
        uint256 assetsLen = assets.length;
        amounts = new uint256[](assetsLen);
        for (uint256 i; i < assetsLen; ++i) {
            amounts[i] = _getGainFromSnapshots(initialDeposit, snapshots, assets[i]);
        }
    }

    
    
    function _getGainFromSnapshots(
        uint256 initialDeposit,
        Snapshots storage snapshots,
        address asset
    ) internal view returns (uint256) {
        
        uint256 S_Snapshot = snapshots.S[asset];
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale].sub(
            S_Snapshot
        );        
        uint256 secondPortion = epochToScaleToSum[asset][snapshots.epoch][snapshots.scale.add(1)]
            .div(SCALE_FACTOR);

        uint256 assetGain = initialDeposit.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );
        
        return assetGain;
    }

    
    function getDepositorYETIGain(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        address frontEndTag = deposits[_depositor].frontEndTag;

        
        uint256 kickbackRate = frontEndTag == address(0)
            ? DECIMAL_PRECISION
            : frontEnds[frontEndTag].kickbackRate;

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 YETIGain = kickbackRate
            .mul(_getYETIGainFromSnapshots(initialDeposit, snapshots))
            .div(DECIMAL_PRECISION);

        return YETIGain;
    }

    
    function getFrontEndYETIGain(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        uint256 kickbackRate = frontEnds[_frontEnd].kickbackRate;
        uint256 frontEndShare = uint256(DECIMAL_PRECISION).sub(kickbackRate);

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 YETIGain = frontEndShare
            .mul(_getYETIGainFromSnapshots(frontEndStake, snapshots))
            .div(DECIMAL_PRECISION);
        return YETIGain;
    }

    function _getYETIGainFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        
        uint128 epochSnapshot = snapshots.epoch;
        uint128 scaleSnapshot = snapshots.scale;
        uint256 G_Snapshot = snapshots.G;
        uint256 P_Snapshot = snapshots.P;

        uint256 firstPortion = epochToScaleToG[epochSnapshot][scaleSnapshot].sub(G_Snapshot);
        uint256 secondPortion = epochToScaleToG[epochSnapshot][scaleSnapshot.add(1)].div(
            SCALE_FACTOR
        );

        uint256 YETIGain = initialStake.mul(firstPortion.add(secondPortion)).div(P_Snapshot).div(
            DECIMAL_PRECISION
        );

        return YETIGain;
    }

    

    
    function getCompoundedYUSDDeposit(address _depositor) public view override returns (uint256) {
        uint256 initialDeposit = deposits[_depositor].initialValue;
        if (initialDeposit == 0) {
            return 0;
        }

        Snapshots storage snapshots = depositSnapshots[_depositor];

        uint256 compoundedDeposit = _getCompoundedStakeFromSnapshots(initialDeposit, snapshots);
        return compoundedDeposit;
    }

    
    function getCompoundedFrontEndStake(address _frontEnd) public view override returns (uint256) {
        uint256 frontEndStake = frontEndStakes[_frontEnd];
        if (frontEndStake == 0) {
            return 0;
        }

        Snapshots storage snapshots = frontEndSnapshots[_frontEnd];

        uint256 compoundedFrontEndStake = _getCompoundedStakeFromSnapshots(frontEndStake, snapshots);
        return compoundedFrontEndStake;
    }

    
    
    
    
    
    
    
    function _getCompoundedStakeFromSnapshots(uint256 initialStake, Snapshots storage snapshots)
        internal
        view
        returns (uint256)
    {
        uint256 snapshot_P = snapshots.P;
        uint128 scaleSnapshot = snapshots.scale;
        uint128 epochSnapshot = snapshots.epoch;

        
        if (epochSnapshot < currentEpoch) {
            return 0;
        }

        uint256 compoundedStake;
        uint128 scaleDiff = currentScale.sub(scaleSnapshot);

        
        if (scaleDiff == 0) {
            compoundedStake = initialStake.mul(P).div(snapshot_P);
        } else if (scaleDiff == 1) {
            compoundedStake = initialStake.mul(P).div(snapshot_P).div(SCALE_FACTOR);
        } else {
            
            compoundedStake = 0;
        }

        
        if (compoundedStake < initialStake.div(1e9)) {
            return 0;
        }

        return compoundedStake;
    }

    

    
    function _sendYUSDtoStabilityPool(address _address, uint256 _amount) internal {
        yusdToken.sendToPool(_address, address(this), _amount);
        uint256 newTotalYUSDDeposits = totalYUSDDeposits.add(_amount);
        totalYUSDDeposits = newTotalYUSDDeposits;
        emit StabilityPoolYUSDBalanceUpdated(newTotalYUSDDeposits);
    }

    function _sendGainsToDepositor(
        address _to,
        address[] memory assets,
        uint256[] memory amounts
    ) internal {
        uint256 assetsLen = assets.length;
        require(assetsLen == amounts.length, ""SP:Length mismatch"");
        uint256 thisAmounts;
        address thisAsset;
        for (uint256 i; i < assetsLen; ++i) {
            thisAmounts = amounts[i];
            thisAsset = assets[i];
            if (whitelist.isWrapped(thisAsset)) {
                
                IWAsset(thisAsset).endTreasuryReward(address(this), thisAmounts);
                
                IWAsset(thisAsset).unwrapFor(address(this), _to, thisAmounts);
            } else {
                IERC20(thisAsset).safeTransfer(_to, thisAmounts);
            }
        }
        totalColl.amounts = _leftSubColls(totalColl, assets, amounts);
    }

    
    function _sendYUSDToDepositor(address _depositor, uint256 YUSDWithdrawal) internal {
        if (YUSDWithdrawal == 0) {
            return;
        }

        yusdToken.returnFromPool(address(this), _depositor, YUSDWithdrawal);
        _decreaseYUSD(YUSDWithdrawal);
    }

    

    
    function registerFrontEnd(uint256 _kickbackRate) external override {
        _requireFrontEndNotRegistered(msg.sender);
        _requireUserHasNoDeposit(msg.sender);
        _requireValidKickbackRate(_kickbackRate);

        frontEnds[msg.sender].kickbackRate = _kickbackRate;
        frontEnds[msg.sender].registered = true;

        emit FrontEndRegistered(msg.sender, _kickbackRate);
    }

    

    function _setFrontEndTag(address _depositor, address _frontEndTag) internal {
        deposits[_depositor].frontEndTag = _frontEndTag;
        emit FrontEndTagSet(_depositor, _frontEndTag);
    }

    
    
    
    function _updateDepositAndSnapshots(address _depositor, uint256 _newValue) internal {
        deposits[_depositor].initialValue = _newValue;

        if (_newValue == 0) {
            delete deposits[_depositor].frontEndTag;
            address[] memory colls = whitelist.getValidCollateral();
            uint256 collsLen = colls.length;
            for (uint256 i; i < collsLen; ++i) {
                depositSnapshots[_depositor].S[colls[i]] = 0;
            }
            depositSnapshots[_depositor].P = 0;
            depositSnapshots[_depositor].G = 0;
            depositSnapshots[_depositor].epoch = 0;
            depositSnapshots[_depositor].scale = 0;
            emit DepositSnapshotUpdated(_depositor, 0, 0);
            return;
        }
        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        address[] memory allColls = whitelist.getValidCollateral();

        
        uint256 allCollsLen = allColls.length;
        for (uint256 i; i < allCollsLen; ++i) {
            address token = allColls[i];
            uint256 currentSForToken = epochToScaleToSum[token][currentEpochCached][
                currentScaleCached
            ];
            depositSnapshots[_depositor].S[token] = currentSForToken;
        }

        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        depositSnapshots[_depositor].P = currentP;
        depositSnapshots[_depositor].G = currentG;
        depositSnapshots[_depositor].scale = currentScaleCached;
        depositSnapshots[_depositor].epoch = currentEpochCached;

        emit DepositSnapshotUpdated(_depositor, currentP, currentG);
    }

    function _updateFrontEndStakeAndSnapshots(address _frontEnd, uint256 _newValue) internal {
        frontEndStakes[_frontEnd] = _newValue;

        if (_newValue == 0) {
            delete frontEndSnapshots[_frontEnd];
            emit FrontEndSnapshotUpdated(_frontEnd, 0, 0);
            return;
        }

        uint128 currentScaleCached = currentScale;
        uint128 currentEpochCached = currentEpoch;
        uint256 currentP = P;

        
        uint256 currentG = epochToScaleToG[currentEpochCached][currentScaleCached];

        
        frontEndSnapshots[_frontEnd].P = currentP;
        frontEndSnapshots[_frontEnd].G = currentG;
        frontEndSnapshots[_frontEnd].scale = currentScaleCached;
        frontEndSnapshots[_frontEnd].epoch = currentEpochCached;

        emit FrontEndSnapshotUpdated(_frontEnd, currentP, currentG);
    }

    function _payOutYETIGains(
        ICommunityIssuance _communityIssuance,
        address _depositor,
        address _frontEnd
    ) internal {
        
        if (_frontEnd != address(0)) {
            uint256 frontEndYETIGain = getFrontEndYETIGain(_frontEnd);
            _communityIssuance.sendYETI(_frontEnd, frontEndYETIGain);
            emit YETIPaidToFrontEnd(_frontEnd, frontEndYETIGain);
        }

        
        uint256 depositorYETIGain = getDepositorYETIGain(_depositor);
        _communityIssuance.sendYETI(_depositor, depositorYETIGain);
        emit YETIPaidToDepositor(_depositor, depositorYETIGain);
    }

    

    function _requireNoUnderCollateralizedTroves() internal view {
        address lowestTrove = sortedTroves.getLast();
        uint256 ICR = troveManager.getCurrentICR(lowestTrove);
        require(ICR >= MCR, ""SP:No Withdraw when troveICR<MCR"");
    }

    function _requireUserHasDeposit(uint256 _initialDeposit) internal pure {
        require(_initialDeposit != 0, ""SP: require nonzero deposit"");
    }

    function _requireUserHasNoDeposit(address _address) internal view {
        uint256 initialDeposit = deposits[_address].initialValue;
        require(initialDeposit == 0, ""SP: User must have no deposit"");
    }

    function _requireNonZeroAmount(uint256 _amount) internal pure {
        require(_amount != 0, ""SP: Amount must be non-zero"");
    }

    function _requireFrontEndNotRegistered(address _address) internal view {
        require(
            !frontEnds[_address].registered,
            ""SP: Frontend already registered""
        );
    }

    function _requireFrontEndIsRegisteredOrZero(address _address) internal view {
        require(
            frontEnds[_address].registered || _address == address(0),
            ""SP: Frontend not registered""
        );
    }

    function _requireValidKickbackRate(uint256 _kickbackRate) internal pure {
        require(
            _kickbackRate <= DECIMAL_PRECISION,
            ""SP:Invalid Kickback rate""
        );
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != whitelistAddress) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsActivePool() internal view {
        if (msg.sender != address(activePool)) {
            _revertWrongFuncCaller();
        }
    }

    function _requireCallerIsTML() internal view {
        if (msg.sender != address(troveManagerLiquidationsAddress)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""SP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] memory _tokens, uint256[] memory _amounts)
        external
        override
    {
        _requireCallerIsActivePool();
        totalColl.amounts = _leftSumColls(totalColl, _tokens, _amounts);
        emit StabilityPoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        lastAssetError_Offset.push(0);
        totalColl.tokens.push(_collateral);
        totalColl.amounts.push(0);
    }

    
    function getDepositSnapshotS(address _depositor, address _collateral)
        external
        view
        override
        returns (uint256)
    {
        return depositSnapshots[_depositor].S[_collateral];
    }
}",7250.0,1,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Compounded Deposit Calculation Flaw**  
   The function `_getCompoundedStakeFromSnapshots` fails to handle scale increments greater than 1, leading to a total loss of user deposits if the scale increases multiple times. This occurs because compounded deposits are set to zero when `scaleDiff > 1`, effectively erasing user balances after multiple offset operations.

2. **Precision Loss and Rounding Errors**  
   Integer division in reward/loss calculations (e.g., `_computeYETIPerUnitStaked`, `_computeRewardsPerUnitStaked`) truncates fractional values. Accumulated rounding errors over time could result in incorrect reward distributions or loss accounting, especially for small deposits.

3. **Inadequate Handling of Multiple Scale Resets**  
   The scaling mechanism (`currentScale` and `currentEpoch`) does not account for compounding effects beyond a single scale increment. Users with deposits spanning multiple scale resets will have their stakes reduced to zero due to division by `SCALE_FACTOR` multiple times.

4. **Dust Amounts Zeroing**  
   The check `if (compoundedStake < initialStake.div(1e9))` in `_getCompoundedStakeFromSnapshots` forces small deposits (after scaling) to zero, potentially locking users out of withdrawing residual amounts.

5. **Lack of Reentrancy Guards**  
   While the code follows checks-effects-interactions patterns, critical functions like `provideToSP` and `withdrawFromSP` interact with external contracts (e.g., `communityIssuance.sendYETI`) without explicit reentrancy protection, risking reentrancy attacks if external contracts are malicious.

6. **Dependency on External Contract Security**  
   The contract relies on external dependencies (e.g., `communityIssuance`, `yusdToken`). Compromise of these contracts could destabilize the system, though ownership renunciation mitigates post-deployment changes.

7. **Potential Mismatched Array Lengths**  
   Functions like `receiveCollateral` and `addCollateralType` accept token and amount arrays without explicit length checks, risking incorrect collateral accounting if arrays are mismatched (mitigated by internal `_leftSumColls` logic, but dependent on external input validation).

8. **Front-End Reward Snapshotting**  
   Front-end rewards are snapshotted at deposit time, but changes to a front-end's `kickbackRate` after user deposits are not retroactively applied, potentially misleading depositors about expected rewards.","---

**[H-01] receiveCollateral() can be called by anyone**

**Report Description**:  
In `StabilityPool.sol`, the `receiveCollateral()` function is intended to be called exclusively by the `ActivePool` contract, as indicated by the comments. However, the function lacks access control, allowing anyone to call it by passing `_tokens` and `_amounts` arguments. This oversight could enable unauthorized updates to the stability pool balances, potentially leading to incorrect accounting or manipulation of the system.

**Match in Response List**:  
Matches with the issue titled **""Potential Mismatched Array Lengths""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of mismatched array lengths in functions like `receiveCollateral`, which is a valid concern. However, it does not address the core issue of improper access control, which is the primary vulnerability in this case. While the response highlights a related risk, it misses the critical detail that the function is callable by anyone, leading to unauthorized updates. This oversight makes the response partially correct but insufficient to fully address the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-01] receiveCollateral() can be called by anyone**

**Missed Issues from Issue Report**:  
- *None*

---",0,1,0,8,"Okay, I need to analyze this StabilityPool smart contract for vulnerabilities. Let's start by going through the code step by step.

First, looking at the imports and dependencies. They're using SafeMath and SafeERC20, which is good for preventing overflows and safe token transfers. The contract inherits from LiquityBase, Ownable, CheckContract, and IStabilityPool. Ownable suggests there might be owner privileges, which could be a concern if not properly relinquished.

Checking the setAddresses function, it's external and onlyOwner. They call _renounceOwnership() at the end, which means after setting addresses, the owner is renounced. That's good because it prevents the owner from changing critical addresses later. But wait, are all the addresses properly validated? They use checkContract for each, which should ensure they're contracts. But maybe there's a dependency on those contracts being secure.

Looking at provideToSP and withdrawFromSP functions. These handle deposits and withdrawals. There's a _triggerYETIIssuance which updates rewards. They use communityIssuance.sendYETI to send tokens. Need to check for reentrancy here. The functions don't have a reentrancy guard modifier, but they follow checks-effects-interactions. Let's see: they calculate gains, update states, then send tokens. So maybe reentrancy isn't an issue here. But since they interact with external contracts (like ICommunityIssuance), if those are malicious, there could be risks. But assuming those contracts are trusted, since they're set by the owner initially.

In the offset function, it's called by TML (TroveManagerLiquidations). The function computes rewards and moves collateral. The _computeRewardsPerUnitStaked uses divisions which might lead to precision loss. They have some error term tracking (lastAssetError_Offset, lastYUSDLossError_Offset). But division before multiplication could be an issue here. For example, in YUSDLossPerUnitStaked calculation: if YUSDLossNumerator is divided by _totalYUSDDeposits, which could be a large number, leading to truncation. However, they track the error in lastYUSDLossError_Offset, which might mitigate that. But potential for rounding errors exists, which could accumulate over time.

The _updateRewardSumAndProduct function handles scaling factors. When newProductFactor is zero, they increment the epoch and reset scale. However, multiplying currentP by newProductFactor might underflow if not careful. They have require(newP != 0), but is there a scenario where currentP.mul(newProductFactor) could be zero even when newProductFactor is not zero? Maybe not, since newProductFactor is DECIMAL_PRECISION - YUSDLossPerUnitStaked, and YUSDLossPerUnitStaked is <= DECIMAL_PRECISION. So newProductFactor is >=0. But when YUSDLossPerUnitStaked is exactly DECIMAL_PRECISION, newProductFactor is zero, leading to newP being DECIMAL_PRECISION. Wait, in that case, newProductFactor is zero, so the code sets newP to DECIMAL_PRECISION. But that might be a problem because if all debt is offset (YUSDLoss is 100%), then P should reset. But the code seems to handle that by incrementing epoch and resetting scale.

Looking at the _getCompoundedStakeFromSnapshots function. It calculates compounded deposits. If the scaleDiff is more than 1, it returns zero. That's a problem. Because if the scale increments multiple times, the user's stake is considered zero. For example, if currentScale is 3 and the user's snapshot scale is 1, scaleDiff is 2, so compoundedStake is zero. This would mean that if the scale increases more than once between user's deposit and withdrawal, their deposit is lost. That's a critical vulnerability. Users could lose funds if the scale increments multiple times due to multiple offset operations leading to underflow in scaling.

Another thing: the function _getCompoundedStakeFromSnapshots checks if compoundedStake is less than initialStake divided by 1e9, it returns zero. This is to handle dust amounts, but if the scaling factor reduces the stake below this threshold, the user's deposit is zeroed out. However, the scaling factor is 1e9, so if the scale increases once, the compounded stake is initialStake * P / snapshot_P / 1e9. If P is similar to snapshot_P, then this division by 1e9 would make the compoundedStake very small, leading to it being considered zero. This could happen if the user's deposit is small, leading to loss of funds.

Also, in _computeRewardsPerUnitStaked, they have a loop that calculates AssetGainPerUnitStaked. They use CollateralNumerators[i].mul(currentP).div(_totalYUSDDeposits). But if _totalYUSDDeposits is zero, this would cause a division by zero. However, the function is called from offset, which has a check that totalYUSDDeposits is not zero. So maybe that's handled.

Another possible issue is the use of arrays without checking their lengths. For example, in receiveCollateral, the function takes _tokens and _amounts arrays. If their lengths don't match, the _leftSumColls function might have issues. But the function uses _leftSumColls which is supposed to handle summing the amounts for each token. However, if the arrays are mismatched, it could lead to incorrect accounting. Similarly, in addCollateralType, they push a new collateral, but are there checks for duplicates? The Whitelist might handle that, but if not, adding the same collateral twice would cause issues.

The _sendGainsToDepositor function transfers multiple collaterals. If any of the transfers fail (e.g., a non-standard ERC20 that returns false instead of reverting), the entire transaction would revert only if SafeERC20 is used. Since they're using SafeERC20's safeTransfer, which reverts on failure, this should be safe. However, for Wrapped Assets (IWAsset), if unwrapping fails, it might not revert. Need to check if IWAsset's unwrapFor function correctly reverts on errors.

Reentrancy in functions: provideToSP and withdrawFromSP both call external contracts (communityIssuance.sendYETI). If the YETI token is malicious and calls back into the contract, could that cause reentrancy issues? Since the state is updated before the external call (due to checks-effects-interactions), this should be safe. The sendYETI function would have to be a malicious contract that reenters, but the state changes (like updating deposits and snapshots) have already been done. So reentrancy here might not be a problem, but depends on the implementation of sendYETI.

Another thing is the use of floating point scaling. The contract uses a scaling mechanism with epoch and scale. If the scale increments multiple times, compounded deposits can become zero as discussed earlier, leading to loss of user funds. This is a critical issue because users could lose their entire deposits if multiple scale changes occur.

In _updateDepositAndSnapshots, when a deposit is updated, if the new value is zero, it deletes the frontEndTag and resets snapshots. But if a user deposits again after their deposit is zeroed, their frontEndTag would need to be set again. That's probably intended, but if there's a way to front-run a withdrawal and set a different frontEndTag, but the function _setFrontEndTag is only called when initialDeposit is zero in provideToSP. So once a user has a deposit, they can't change their frontEndTag unless they withdraw completely. That's by design.

Possible denial-of-service attacks: If an attacker causes the scale to increment multiple times, making many users' deposits zero. But how? Each offset that causes the product factor to drop below SCALE_FACTOR would increment the scale. If multiple such offsets happen rapidly, scales could increase. However, this is part of the protocol's design to handle decimal scaling. The problem is the compounded deposit calculation doesn't handle scale differences beyond 1.

In summary, the key vulnerabilities I can see are:

1. **Compounded Deposit Calculation Flaw**: The _getCompoundedStakeFromSnapshots function does not handle cases where the scale difference is greater than 1, leading to users losing their deposits if the scale increments multiple times. This is a critical vulnerability as it can result in loss of funds.

2. **Precision Loss and Rounding Errors**: The use of integer division in multiple places (e.g., _computeYETIPerUnitStaked, _computeRewardsPerUnitStaked) can lead to precision loss, especially when dealing with small numbers. Accumulated errors might slightly affect the distribution of rewards or losses.

3. **Front-End Race Conditions**: If a front-end is deregistered or changes kickback rates after users have deposited, existing depositors might be affected. However, the code seems to handle this by snapshotting the front-end's stake at the time of deposit.

4. **Dependency on External Contracts**: The contract relies on correctly functioning external contracts (e.g., communityIssuance, yusdToken). If these are compromised, the StabilityPool could be affected. But since the owner renounces ownership after setup, this is a known risk but not a vulnerability in the code itself.

5. **Scale Handling Leading to Fund Loss**: As mentioned in point 1, if the scale increments more than once, compounded deposits become zero. Since each scale multiplies by 1e9, after two scales, the user's deposit is divided by 1e18, which for most deposits would result in zero, effectively wiping out the deposit.

6. **Incorrect Collateral Handling**: If the whitelist is compromised or improperly managed, adding invalid collaterals could affect the system. But the addCollateralType function is only callable by the whitelist, which is supposed to be secure.

7. **Lack of Reentrancy Guards**: Although the code follows checks-effects-interactions, the absence of reentrancy guards on functions that make external calls (e.g., sending YETI) could be risky if the external contracts are malicious. However, given the use of SafeERC20 and checks, this might be mitigated.

The most severe issues are the compounded deposit calculation flaw and the scale handling leading to potential loss of user funds. These need to be highlighted as critical vulnerabilities.","```
None.
```",0.0
sYetiToken.sol,"//SPDX-License-Identifier: MIT
pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}

// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)
// modified by BoringCrypto for DictatorDAO


// Use effective yetibalance, which updates on rebase. Rebase occurs every 8 
// Each rebase increases the effective yetibalance by a certain amount of the total value
// of the contract, which is equal to the yusd balance + the last price which the buyback 
// was executed at, multiplied by the YETI balance. Then, a portion of the value, say 1/200
// of the total value of the contract is added to the effective yetibalance. Also updated on 
// mint and withdraw, because that is actual value that is added to the contract. 

contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    // Internal mapping to keep track of valid routers. Find the one with least slippage off chain
    // and do that one. 
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    /// @notice owner > balance mapping.
    mapping(address => User) public users;
    /// @notice owner > spender > allowance mapping.
    mapping(address => mapping(address => uint256)) public override allowance;
    /// @notice owner > nonce mapping. Used in `permit`.
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); // Moved down so other failed calls safe some gas
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; // Underflow is checked
                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; // Underflow is checked
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.
    /// @param to The address to move the tokens.
    /// @param shares of the tokens to move.
    /// @return (bool) Returns True if succeeded.
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.
    /// @param from Address to draw tokens from.
    /// @param to The address to move the tokens.
    /// @param shares The token shares to move.
    /// @return (bool) Returns True if succeeded.
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /// @notice Approves `amount` from sender to be spend by `spender`.
    /// @param spender Address of the party that can draw from msg.sender's account.
    /// @param amount The maximum collective amount that `spender` can draw.
    /// @return (bool) Returns True if approved.
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    // keccak256(""Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"");
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    /// @notice Approves `value` from `owner_` to be spend by `spender`.
    /// @param owner_ Address of the owner.
    /// @param spender The address of the spender that gets approved to draw from `owner_`.
    /// @param value The maximum collective amount that `spender` can draw.
    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18
    /// theoretically you can grow the amount/share ratio, but it's not practical and useless
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    /** 
     * Buyback function called by owner of function. Keeps track of the 
     */
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    /** 
     * Public function for doing buybacks, eligible every 169 hours. This is so that there are some guaranteed rewards to be distributed if the team multisig is lost.
     * Has a max amount of YUSD to sell at 5% of the YUSD in the contract, which should be enough to cover the amount. Uses the default router which has a time lock 
     * in order to activate. 
     * No YUSDToSell param since this just does 5% of the YUSD in the contract.
     */
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        // Get 5% of the YUSD in the contract
        // Always enough YUSD in the contract to cover the 5% of the YUSD in the contract
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    // Internal function calls the router function for buyback and emits event with amount of YETI bought and YUSD spent. 
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        // Checks internal mapping to see if router is valid
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        // amounts[0] is the amount of YUSD that was sold, and amounts[1] is the amount of YETI that was gained in return. So the price is amounts[0] / amounts[1]
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    // Rebase function for adding new value to the sYETI - YETI ratio. 
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns 
        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance

        // raw balance of the contract
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        // amount of YETI free / available to give out
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        // in YETI, amount that should be eligible to give out.
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        // in YETI, amount to rebase
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. 
        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        // rebase amount joins the effective supply. 
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        // update rebase time
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    // Sums YUSD balance + old price. 
    // Should take add the YUSD balance / last buyback price to get value of the YUSD in YETI 
    // added to the YETI balance of the contract. Essentially the amount it is eligible to give out.
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    // Sets new transfer ratio for rebasing
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    // TODO - add time delay for setting new valid router. 
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    // TODO - add time delay for invalidating router. 
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    // Safe divide
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",3595.0,338.0,"[H-02] Yeti token rebase checks the additional token amount incorrectly
function `rebuse`, `effectiveYetiTokenBalance`
`yetiToken.balance - effectiveYetiTokenBalance`
The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added toÂ effectiveYetiTokenBalanceÂ during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case.
The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total usersâ€™ claims. In other words, the contract will be in default if enough users claim after that.
â€¨
[M-01] WrongÂ `lastBuyBackPrice`
TheÂ `sYETIToken.lastBuyBackPrice`Â is set inÂ `buyBack`Â and hardcoded as:
â€œfunction buyBack(address routerAddress, uint256 YUSDToSell, uint256 YETIOutMin, address[] memory path) external onlyOwner â€œ
It divides the first and second returnÂ `amounts`Â of the swap, however, these amounts depend on the swapÂ pathÂ parameter that is used by the caller. If a swap path of length 3 is used, then this is obviously wrong. It also assumes that each router sorts the pairs the same way (which is true for Uniswap/Sushiswap).",2.0,"pragma solidity 0.6.12;

import ""./BoringCrypto/BoringMath.sol"";
import ""./BoringCrypto/BoringERC20.sol"";
import ""./BoringCrypto/Domain.sol"";
import ""./BoringCrypto/ERC20.sol"";
import ""./BoringCrypto/IERC20.sol"";
import ""./BoringCrypto/BoringOwnable.sol"";
import ""./IsYETIRouter.sol"";


interface IYETIToken is IERC20 {
    function sendToSYETI(address _sender, uint256 _amount) external;
    function transfer(address recipient, uint256 amount) external returns (bool);
}












contract sYETIToken is IERC20, Domain, BoringOwnable {
    using BoringMath for uint256;
    using BoringMath128 for uint128;
    using BoringERC20 for IERC20;

    string public constant symbol = ""sYETI"";
    string public constant name = ""Staked YETI Tokens"";
    uint8 public constant decimals = 18;
    uint256 public override totalSupply;
    uint256 private constant LOCK_TIME = 69 hours;
    uint256 public effectiveYetiTokenBalance;
    uint256 public lastBuybackTime;
    uint256 public lastBuybackPrice;
    uint256 public lastRebaseTime;
    uint256 public transferRatio; 
    IYETIToken public yetiToken;
    IERC20 public yusdToken;
    bool private addressesSet;


    
    
    mapping(address => bool) public validRouters;

    struct User {
        uint128 balance;
        uint128 lockedUntil;
    }

    
    mapping(address => User) public users;
    
    mapping(address => mapping(address => uint256)) public override allowance;
    
    mapping(address => uint256) public nonces;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);
    event Rebase(uint additionalYetiTokenBalance);

    function balanceOf(address user) public view override returns (uint256) {
        return users[user].balance;
    }

    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {
        require(!addressesSet, ""addresses already set"");
        yetiToken = _yeti;
        yusdToken = _yusd;
        addressesSet = true;
    }

    function _transfer(
        address from,
        address to,
        uint256 shares
    ) internal {
        User memory fromUser = users[from];
        require(block.timestamp >= fromUser.lockedUntil, ""Locked"");
        if (shares != 0) {
            require(fromUser.balance >= shares, ""Low balance"");
            if (from != to) {
                require(to != address(0), ""Zero address""); 
                User memory toUser = users[to];
                uint128 shares128 = shares.to128();
                users[from].balance = fromUser.balance - shares128; 
                users[to].balance = toUser.balance + shares128; 
            }
        }
        emit Transfer(from, to, shares);
    }

    function _useAllowance(address from, uint256 shares) internal {
        if (msg.sender == from) {
            return;
        }
        uint256 spenderAllowance = allowance[from][msg.sender];
        
        if (spenderAllowance != type(uint256).max) {
            require(spenderAllowance >= shares, ""Low allowance"");
            uint256 newAllowance = spenderAllowance - shares;
            allowance[from][msg.sender] = newAllowance; 
            emit Approval(from, msg.sender, newAllowance);
        }
    }

    
    
    
    
    function transfer(address to, uint256 shares) public returns (bool) {
        _transfer(msg.sender, to, shares);
        return true;
    }

    
    
    
    
    
    function transferFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _transfer(from, to, shares);
        return true;
    }

    
    
    
    
    function approve(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    
    
    function increaseAllowance(address spender, uint256 amount) public override returns (bool) {
        allowance[msg.sender][spender] += amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    
    function DOMAIN_SEPARATOR() external view returns (bytes32) {
        return _domainSeparator();
    }

    
    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;

    
    
    
    
    
    function permit(
        address owner_,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external override {
        require(owner_ != address(0), ""Zero owner"");
        require(block.timestamp < deadline, ""Expired"");
        require(
            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==
            owner_,
            ""Invalid Sig""
        );
        allowance[owner_][spender] = value;
        emit Approval(owner_, spender, value);
    }

    
    
    function mint(uint256 amount) public returns (bool) {
        User memory user = users[msg.sender];

        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / effectiveYetiTokenBalance;
        user.balance += shares.to128();
        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();
        users[msg.sender] = user;
        totalSupply += shares;

        yetiToken.sendToSYETI(msg.sender, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amount);

        emit Transfer(address(0), msg.sender, shares);
        return true;
    }

    function _burn(
        address from,
        address to,
        uint256 shares
    ) internal {
        require(to != address(0), ""Zero address"");
        User memory user = users[from];
        require(block.timestamp >= user.lockedUntil, ""Locked"");
        uint256 amount = (shares * effectiveYetiTokenBalance) / totalSupply;
        users[from].balance = user.balance.sub(shares.to128()); 
        totalSupply -= shares;

        yetiToken.transfer(to, amount);
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.sub(amount);

        emit Transfer(from, address(0), shares);
    }

    function burn(address to, uint256 shares) public returns (bool) {
        _burn(msg.sender, to, shares);
        return true;
    }

    function burnFrom(
        address from,
        address to,
        uint256 shares
    ) public returns (bool) {
        _useAllowance(from, shares);
        _burn(from, to, shares);
        return true;
    }

    
    function buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) external onlyOwner {
        require(_YUSDToSell != 0, ""Zero amount"");
        require(yusdToken.balanceOf(address(this)) >= _YUSDToSell, ""Not enough YUSD in contract"");
        _buyBack(_routerAddress, _YUSDToSell, _YETIOutMin);
    }

    
    function publicBuyBack(address _routerAddress) external {
        uint256 YUSDBalance = yusdToken.balanceOf(address(this));
        require(YUSDBalance != 0, ""No YUSD in contract"");
        require(lastBuybackTime + 169 hours < block.timestamp, ""Can only publicly buy back every 169 hours"");
        
        
        uint256 YUSDToSell = div(YUSDBalance.mul(5), 100);
        _buyBack(_routerAddress, YUSDToSell, 0);
    }

    
    function _buyBack(address _routerAddress, uint256 _YUSDToSell, uint256 _YETIOutMin) internal {
        
        require(validRouters[_routerAddress] == true, ""Invalid router passed in"");
        require(yusdToken.approve(_routerAddress, 0));
        require(yusdToken.increaseAllowance(_routerAddress, _YUSDToSell));
        lastBuybackTime = block.timestamp;
        uint256[] memory amounts = IsYETIRouter(_routerAddress).swap(_YUSDToSell, _YETIOutMin, address(this));
        
        lastBuybackPrice = div(amounts[0].mul(1e18), amounts[1]);
        emit BuyBackExecuted(_YUSDToSell, amounts[0], amounts[1]);
    }

    
    function rebase() external {
        require(block.timestamp >= lastRebaseTime + 8 hours, ""Can only rebase every 8 hours"");
        
        

        
        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  
        
        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); 
        
        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); 
        
        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); 
        
        
        if (amountYetiToRebase > adjustedYetiTokenBalance) {
            amountYetiToRebase = adjustedYetiTokenBalance;
        }
        
        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);
        
        lastRebaseTime = block.timestamp;
        emit Rebase(amountYetiToRebase);
    }

    
    
    
    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {
        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));
        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);
    }

    
    function setTransferRatio(uint256 newTransferRatio) external onlyOwner {
        require(newTransferRatio != 0, ""Zero transfer ratio"");
        require(newTransferRatio <= 1e18, ""Transfer ratio too high"");
        transferRatio = newTransferRatio;
    }
    
    
    function addValidRouter(address _routerAddress) external onlyOwner {
        require(_routerAddress != address(0), ""Invalid router address"");
        validRouters[_routerAddress] = true;
    }

    
    function removeValidRouter(address _routerAddress) external onlyOwner {
        validRouters[_routerAddress] = false;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {
        require(b != 0, ""BoringMath: Div By 0"");
        return a / b;
    }
}",2343.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Reentrancy in Buyback Function**  
   The `_buyBack` function performs an external call to a router (`IsYETIRouter(_routerAddress).swap`) before updating the `lastBuybackTime` state variable. A malicious router could reenter the contract (e.g., via `publicBuyBack`), bypassing the 169-hour lock period and draining YUSD funds.

2. **Division by Zero in Rebase**  
   The `rebase` function relies on `lastBuybackPrice`, which is initialized to zero. If `rebase` is called before any successful buyback, `_getValueOfContract` will attempt division by zero, reverting the transaction and halting rebase functionality.

3. **Uninitialized `transferRatio`**  
   The `transferRatio` variable defaults to zero. If the owner fails to initialize it via `setTransferRatio`, the `rebase` function will compute `amountYetiToRebase` as zero, rendering rebase ineffective until the ratio is set.

4. **Potential Overflow in `mint` Function**  
   When calculating `shares` in `mint`, the result could exceed `uint128` if `(amount * totalSupply) / effectiveYetiTokenBalance` is too large. This would cause a revert via `shares.to128()`, leading to a denial-of-service for large mints.

5. **Underflow in Rebase Adjusted Balance**  
   If the actual YETI balance (`yetiToken.balanceOf(address(this))`) falls below `effectiveYetiTokenBalance`, `adjustedYetiTokenBalance` underflows during `rebase`, causing the transaction to revert and preventing further rebases.

6. **Dependence on Router Security**  
   The contract trusts routers added by the owner. A malicious router could execute arbitrary code during swaps, manipulate prices, or enable reentrancy attacks, compromising funds.

7. **Lock Time Reset on Mint**  
   Each call to `mint` resets the userâ€™s `lockedUntil` timestamp, potentially extending lock periods unexpectedly if a user mints multiple times.

8. **ERC20 Compliance Risks**  
   The `approve` function does not mitigate the ERC20 allowance front-running vulnerability (though this is a known ERC20 limitation, not a contract-specific flaw).

9. **Centralization Risks**  
   The owner controls critical functions (e.g., setting routers, `transferRatio`), introducing trust assumptions. Malicious or compromised owner actions could drain funds or disrupt operations.","### **[H-02] Yeti token rebase checks the additional token amount incorrectly**

**Report Description**:  
The `rebase` function in the contract incorrectly calculates the additional token amount by using the entire balance (`yetiToken.balance`) instead of the Yeti tokens bought back from the market (`effectiveYetiTokenBalance`). This oversight allows the amount added to `effectiveYetiTokenBalance` during rebase to exceed the actual amount of Yeti tokens owned by the contract. This discrepancy can lead to a deficit in the contract's net worth, especially if the price of Yeti tokens increases. If enough users claim their tokens, the contract may default, as its net holdings will be less than the total usersâ€™ claims.

**Match in Response List**:  
Matches with the issue titled **""Underflow in Rebase Adjusted Balance""**.

**Validation**:  
**Partially Correct**. The response identifies the risk of underflow in `adjustedYetiTokenBalance` during rebase, which is related to the issue of incorrect token amount calculations. However, it misses the broader impact of the miscalculation on the contract's net worth and the potential for default due to insufficient token holdings. The response does not address the core issue of using the entire balance instead of the bought-back tokens, which is critical to understanding the vulnerability.

---

### **[M-01] Wrong `lastBuyBackPrice`**

**Report Description**:  
The `lastBuyBackPrice` is set in the `buyBack` function by dividing the first and second return `amounts` of the swap. However, this calculation assumes a swap path of length 2 and that all routers sort pairs the same way (e.g., Uniswap/Sushiswap). If a swap path of length 3 is used, the calculation becomes incorrect, leading to inaccurate pricing data. This could affect the contract's rebase functionality and other operations relying on `lastBuyBackPrice`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect `lastBuyBackPrice` calculation due to swap path assumptions. This is a critical oversight, as it directly impacts the contract's pricing logic and could lead to incorrect rebase calculations.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-02] Yeti token rebase checks the additional token amount incorrectly**

**Missed Issues from Issue Report**:  
- **[M-01] Wrong `lastBuyBackPrice`**

---

### **Analysis of Gaps**  
The response list covers some related issues, such as underflow in rebase calculations, but fails to address the core problem of incorrect token amount checks in the `rebase` function. Additionally, the issue with `lastBuyBackPrice` calculation is entirely missed, which is a significant oversight given its impact on the contract's functionality. The responses could be improved by addressing these specific vulnerabilities in more detail.",0,1,1,9,"Okay, I need to analyze this smart contract for vulnerabilities. Let's start by reading through the code carefully. The contract is for a staked YETI token, sYETI. It imports several BoringCrypto libraries, which I know are generally well-audited, but maybe there's something specific here. Let's look at each function and possible issues.

First, the contract uses Solidity 0.6.12. That's an older version, so maybe there are known vulnerabilities with that compiler. For example, the lack of built-in overflow checks, but they use BoringMath which has safe math functions. So that's probably handled, but still, using an older compiler could be a concern.

Looking at the variables: there's a LOCK_TIME of 69 hours for staking. The effectiveYetiTokenBalance is tracked separately. There are mappings for users, allowances, etc. The struct User has a balance and lockedUntil timestamp.

The setAddresses function is onlyOwner and can be called once. If not set properly, the contract could be stuck. But once set, addressesSet becomes true. So maybe no issue here, but depends on deployment.

In the _transfer function, they check if the sender's lockedUntil is passed. The balance is stored as uint128, which might be a problem if the total supply exceeds 2^128-1, but since decimals are 18, maybe not. But the _transfer uses to128() which could truncate if shares is larger than uint128 max. Wait, but shares is derived from user's balance which is a uint128. So maybe not. When they do users[from].balance = fromUser.balance - shares128; since fromUser.balance is a uint128, and shares128 is also uint128, subtraction should be safe because they check require(fromUser.balance >= shares). So that's okay.

In the permit function, they use ecrecover. The nonce is incremented after the signature is checked. But in the code, nonces[owner_]++ is inside the abi.encode, so the nonce used is the current one, and then incremented. That's correct because the require checks nonces[owner_]++ which would be pre-increment. Wait, no. The nonces[owner_] is used in the encode, then nonces[owner_] is incremented. So when someone signs a permit, they have to use the current nonce, and after execution, it's incremented. That's correct. So no replay attacks here.

Looking at the mint function: when totalSupply is zero, shares = amount. Otherwise, shares = (amount * totalSupply) / effectiveYetiTokenBalance. But effectiveYetiTokenBalance could be zero if not initialized. Wait, setAddresses must be called first. If effectiveYetiTokenBalance is zero and totalSupply is non-zero, then division by zero here. Wait, when totalSupply is non-zero, effectiveYetiTokenBalance must also be non-zero, because totalSupply is shares, and effectiveYetiTokenBalance is the underlying. So if totalSupply is non-zero, then effectiveYetiTokenBalance should be non-zero. But if for some reason effectiveYetiTokenBalance is zero and totalSupply is non-zero, this would cause a division by zero. How can that happen? Maybe during initialization. But setAddresses must be called before minting, so effectiveYetiTokenBalance starts at zero. If the first mint is called when totalSupply is zero, then shares = amount, and effectiveYetiTokenBalance is increased by amount. So the division only happens when totalSupply is non-zero, which would require effectiveYetiTokenBalance to be non-zero as well. So division by zero is prevented here.

In the burn function, when burning shares, the amount is (shares * effectiveYetiTokenBalance) / totalSupply. If totalSupply is zero, this would be a division by zero. But to burn shares, you must have shares. So if totalSupply is zero, there are no shares to burn. So that's safe.

The buyBack functions: publicBuyBack can be called by anyone, but only every 169 hours. It sells 5% of the YUSD balance. However, in _buyBack, they check validRouters[_routerAddress]. The owner can add or remove routers. If a malicious router is added by the owner, that could be a problem, but that's a trust issue. Also, in _buyBack, they call yusdToken.approve(_routerAddress, 0) and then increaseAllowance. But the approve function might fail if the current allowance isn't zero. For example, if the router was previously approved for some amount, setting it to zero first is safe. But using increaseAllowance might not be necessary; maybe they should use safeApprove or set it directly. Wait, ERC20's approve can have a front-running vulnerability, but here they first set to zero, then increase. So that's the safe pattern. But wait, the code does:

require(yusdToken.approve(_routerAddress, 0));

But approve returns a boolean. If the ERC20 doesn't return a boolean (like some old tokens), this would fail. But since yusdToken is an IERC20, which in Solidity 0.6.12, the compiler would check that the function exists. But if the token's approve doesn't return a bool, this would revert. However, the code uses BoringERC20 which might handle this. The import is using BoringERC20 for IERC20, which probably has safe wrappers. So maybe this is okay.

In the rebase function: it can be called every 8 hours. It calculates adjustedYetiTokenBalance as yetiTokenBalance.sub(effectiveYetiTokenBalance). Then valueOfContract is computed using _getValueOfContract, which adds the adjusted balance and the YUSD value converted via lastBuybackPrice. If lastBuybackPrice is zero, div would fail. But lastBuybackPrice is set during buyback. If no buyback happened before rebase, then lastBuybackPrice is zero, leading to a division by zero in _getValueOfContract. That's a problem. The function rebase() can be called before any buyBack is executed, which would make lastBuybackPrice zero, causing div(yusdTokenBalance.mul(1e18), 0) which would revert. So the rebase function would fail if called before any buyback. Therefore, the contract could be bricked until a buyback occurs. That's a vulnerability.

Another thing in rebase: transferRatio is a variable that's set by the owner. It's used to calculate amountYetiToRebase. If transferRatio is not set, it's initially zero. The setTransferRatio function requires newTransferRatio !=0 and <=1e18. But if the owner forgets to set it, the default value is zero, so the rebase would compute amountYetiToRebase as zero. So the rebase would do nothing until transferRatio is set. But the require in setTransferRatio ensures it can't be zero once set. However, initially, transferRatio is zero, so the first rebase would fail. Wait, no. The code in rebase uses transferRatio without checking if it's set. So if transferRatio is zero (initial value), then amountYetiToRebase would be zero, and effectiveYetiTokenBalance remains the same. So rebase would not do anything. But the require in setTransferRatio ensures that when the owner sets it, it can't be zero. However, if the owner never calls setTransferRatio, then transferRatio remains zero, and rebase does nothing. That's a possible issue if the owner neglects to initialize it.

The div function is a helper that does division, but in Solidity 0.6, division is already checked. Wait, no: in Solidity 0.6, division by zero would revert automatically. But the code uses BoringMath's div which has a require(b !=0). So maybe redundant, but safe.

Another issue: the ERC20 functions like approve and increaseAllowance don't follow the ERC20 standard correctly. The ERC20 standard specifies that when a user approves a spender, a third party can front-run the transaction and change the allowance. But the code here uses the standard approach, so that's not a vulnerability per se, just a known ERC20 behavior.

In the mint function, the user's lockedUntil is set to block.timestamp + LOCK_TIME. However, when transferring, it checks the sender's lockedUntil. But if someone mints and then transfers immediately, their lockedUntil would be in the future, so the transfer would fail. That's correct. So no issue here.

In the burn function, when burning, it checks the user's lockedUntil. So they can't burn during the lock period. That's correct.

The User struct uses uint128 for balance and lockedUntil. If the contract is supposed to handle large amounts, this could overflow. But since they use BoringMath's to128(), which would revert on overflow, that's handled. For example, shares.to128() would revert if shares exceeds uint128. But shares comes from user.balance which is a uint128, so when transferring, shares can't exceed the user's balance which is a uint128. So when minting, shares is calculated as (amount * totalSupply) / effectiveYetiTokenBalance. If that's larger than uint128, the to128() would revert. So possible DoS if the calculation results in a value larger than uint128. That's a potential vulnerability. For example, if someone mints a large amount leading to shares exceeding uint128.max, the transaction would revert. The contract may not handle very large values. This could be a problem if the total supply or effective balance is large enough.

Another issue: the ERC20 symbol and name are constants. If the contract needs to be upgraded or changed, it can't. But that's by design.

In the publicBuyBack function, YUSDToSell is 5% of the balance. But using div(YUSDBalance.mul(5), 100). Since 5/100 is 5%, but since it's integer division, if YUSDBalance.mul(5) is not a multiple of 100, it truncates. So there might be dust left. Not a security issue, but possibly a precision loss.

In the _buyBack function, after swapping, lastBuybackPrice is set as div(amounts[0].mul(1e18), amounts[1]). If amounts[1] is zero, this would divide by zero. But the swap function should return valid amounts. However, if the swap fails and returns zero, this could cause a division by zero. Depending on the router's implementation, if the swap returns zero for amounts[1], this would revert. So if the swap is unsuccessful, but the router still returns amounts, this could be a problem.

The validRouters mapping is controlled by the owner. If the owner adds a malicious router, then the buyback could be exploited. But that's an admin privilege risk, not a code vulnerability per se.

Reentrancy: The contract uses external calls in _buyBack (IsYETIRouter(_routerAddress).swap(...)). If the router is malicious, it could reenter the contract. However, the code follows checks-effects-interactions? Let's see: in _buyBack, the approval is done, then the swap is called, then lastBuybackTime and lastBuybackPrice are updated. So after the external call, state changes occur. This is a reentrancy risk. A malicious router could reenter the contract during the swap call. For example, during publicBuyBack, which is callable by anyone. If the router reenters, the state (like lastBuybackTime) hasn't been updated yet, so the reentrant call could allow multiple buybacks within the same period. For example, if during the swap call, the attacker reenters publicBuyBack, the lastBuybackTime is still the old value, so the require(lastBuybackTime + 169 hours < block.timestamp) would pass again. This would allow draining YUSD from the contract. This is a critical reentrancy vulnerability.

Another reentrancy point: when burning, the contract transfers yetiToken to the user. If yetiToken is a malicious contract that reenters, but the burn function updates the user's balance before the transfer (following checks-effects-interactions?), let's see. In _burn, they first update the user's balance and totalSupply, then call yetiToken.transfer(to, amount). So the state is updated before the external call. So reentrancy here would not affect the state. That's safe.

But in _buyBack, the external call is made before updating lastBuybackTime. So during the swap, the contract's state hasn't been updated. If the router is malicious and reenters publicBuyBack, it would pass the time check again. For example:

1. User calls publicBuyBack, which calls _buyBack.
2. Inside _buyBack, the router's swap is called.
3. The malicious swap function calls back into publicBuyBack.
4. At this point, lastBuybackTime hasn't been updated yet, so the require(lastBuybackTime + 169h < now) is still true (assuming 169h hasn't passed since the original lastBuybackTime).
5. The reentrant publicBuyBack would proceed, selling another 5% of YUSD.
6. This could be repeated multiple times in one transaction, draining the YUSD balance.

This is a serious reentrancy vulnerability. To fix this, the contract should update the state (like lastBuybackTime) before making the external call. But in the current code, lastBuybackTime is set after the swap. So that's a problem.

Another issue: in the mint function, the user's lockedUntil is set to block.timestamp + LOCK_TIME. If the user mints again, their lockedUntil is overwritten. So multiple mints would extend the lock time. But that's intentional, perhaps. However, if a user mints multiple times, each mint resets their lock time. So if they mint once, then again before the first lock expires, their lockedUntil is set to the new timestamp. This could be a feature, not a bug.

The effectiveYetiTokenBalance is updated in mint and burn. But during buyback, when YETI is bought back, does that affect effectiveYetiTokenBalance? The buyback function swaps YUSD for YETI, which is then held by the contract. However, effectiveYetiTokenBalance is not automatically increased. The YETI from buyback is part of the contract's balance, but effectiveYetiTokenBalance is only updated via mint, burn, or rebase. So during rebase, adjustedYetiTokenBalance is calculated as the current balance minus effectiveYetiTokenBalance. So the buyback increases the actual YETI balance, which would be considered in the rebase as part of adjustedYetiTokenBalance. So when rebase is called, the effective balance is increased by amountYetiToRebase, which is part of adjustedYetiTokenBalance. So the bought back YETI is only added to the effective balance during rebase. If rebase isn't called, the effective balance doesn't reflect the bought YETI. This could be a design choice, but if the rebase isn't called regularly, the effective balance doesn't include the bought YETI, leading to discrepancies between the actual balance and effective balance. This might cause issues in share calculations. For example, when burning, the amount is calculated based on effective balance, but if the actual balance is higher, the contract might have enough YETI, but the effective balance is lower, leading to underflow? Wait, when burning, effectiveYetiTokenBalance is subtracted by the amount. So if the actual YETI balance is higher than effectiveYetiTokenBalance, then burning could take more YETI than effective balance, leading to effective balance underflow. Wait no: when burning, the amount is (shares * effectiveYetiTokenBalance) / totalSupply. So the effectiveYetiTokenBalance is the denominator. If effective balance is lower than actual, then the amount to transfer is based on effective, not actual. So the contract could have more YETI than accounted for, leading to possible incorrect redemption amounts. But since the contract's actual YETI balance is tracked separately via effectiveYetiTokenBalance, which is updated during rebase, this could be intentional. However, this could be a centralization issue if the owner controls when rebase is called, affecting the effective balance and thus user's redemption amounts. If rebase isn't called, the bought back YETI isn't distributed to stakers. So users might not benefit from buybacks until a rebase. That's a potential issue if the rebase is not called regularly or is manipulated.

Another point: the transferRatio is used in rebase to determine how much of the adjusted balance to add to effective. If the transferRatio is set to a high value, like 1e18, then all adjusted balance is added. But if it's lower, only a portion is added. However, if the adjusted balance is negative (if effective is higher than actual), this could underflow. Wait, adjustedYetiTokenBalance is yetiTokenBalance.sub(effectiveYetiTokenBalance). If yetiTokenBalance < effective, adjusted is negative. But since these are unsigned integers, this would underflow, causing a revert. So if the actual balance is less than effective, then rebase would revert. Which could happen if YETI is withdrawn from the contract outside of the mint/burn functions. For example, if the owner transfers YETI out, then the actual balance is less than effective. Then, during rebase, adjustedYetiTokenBalance would underflow, causing the transaction to revert. So the rebase function would become unusable until the actual balance is restored. That's a possible vulnerability if the contract's YETI balance is manipulated.

Moreover, the contract's YETI balance can be increased via buybacks (swapping YUSD for YETI) which increases the actual balance. But if someone sends YETI directly to the contract, that increases the actual balance but not the effective. Then, during rebase, adjustedYetiTokenBalance is positive, and part of it is added to effective. So those YETI donations would be distributed to stakers via rebase. But if someone sends YETI without minting, that could dilute the value of existing shares. For example, if the contract receives YETI, and rebase is called, the effective balance increases, so each share is worth more YETI. Wait, no: when effective balance increases, the amount per share (effective / totalSupply) increases, so each share is worth more. So someone sending YETI to the contract would increase the value for all stakers. But if the YETI is obtained via buybacks (using YUSD from the contract's balance), that's part of the protocol. However, if arbitrary YETI is sent, it could be a way to donate to stakers. Not a vulnerability, but a possible unexpected behavior.

Another issue: in the mint function, yetiToken.sendToSYETI is called. If this function is supposed to transfer YETI from the user to the contract, but the implementation of sendToSYETI is not verified. If sendToSYETI doesn't actually transfer the tokens, then the mint function would credit shares without receiving YETI, leading to inflation. But since IYETIToken is an interface, the actual implementation is external. So if the YETI token has a faulty sendToSYETI function, this could be a problem. But that's outside the scope of this contract's code.

In summary, the vulnerabilities I can identify are:

1. **Reentrancy in BuyBack Function**: The external swap call in _buyBack is made before updating lastBuybackTime, allowing reentrant calls to publicBuyBack which bypass the time lock, leading to multiple buybacks in a single transaction and potential fund drainage.

2. **Division by Zero in Rebase**: If rebase is called before any buyback, lastBuybackPrice is zero, causing a division by zero in _getValueOfContract, which would revert the transaction and prevent rebasing.

3. **Uninitialized transferRatio**: If the owner does not set transferRatio via setTransferRatio, the initial value is zero, leading to rebase having no effect until it's set. However, the setTransferRatio function has a require that newTransferRatio is not zero, so as long as the owner sets it correctly, this is avoided. But if not, rebase does nothing.

4. **Potential Overflow in Mint Function's shares Calculation**: If (amount * totalSupply) / effectiveYetiTokenBalance exceeds uint128, the to128() conversion would revert, causing a DoS for large mints. This could limit the scalability of the contract.

5. **Underflow in Rebase Adjusted Balance**: If the actual YETI balance (yetiToken.balanceOf(address(this))) is less than effectiveYetiTokenBalance, adjustedYetiTokenBalance would underflow, causing the rebase function to revert. This could happen if YETI is removed from the contract outside of the burn function, making rebase unusable.

6. **Dependence on External Router Security**: The contract's safety relies on the validity of the routers added by the owner. If a malicious router is added, it could manipulate swap results or perform reentrancy attacks as discussed in point 1.

7. **Lock Time Reset on Mint**: Each mint resets the user's lockedUntil time, which might be unexpected if a user mints multiple times, extending their lock period each time.

These are the main vulnerabilities I can identify. Let me check if there are others.

Another thing: the ERC20 transfer and transferFrom functions return a boolean, but in Solidity 0.6.x, the functions must return bool. The code does return true, so that's correct.

In the approve function, there's a known issue with front-running, but that's part of the ERC20 standard, not a vulnerability in the code itself.

The event declarations (Transfer and Approval) are present, but in the code, the Transfer event is emitted in _transfer, burn, mint. So that's correct.

The BoringOwnable is used, which gives the owner significant power, like setting routers, transferRatio, etc. Centralization risks, but not a code vulnerability per se.

So the key vulnerabilities are the reentrancy in buyback, division by zero in rebase, potential underflow in rebase adjusted balance, and the mint function's possible DoS on uint128 overflow.","```
None.
```",0.0
PriceFeed.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";


/*
* PriceFeed for mainnet deployment, to be connected to Chainlink's live Collateral:USD aggregator reference
* contract, and a wrapper contract TellorCaller, which connects to TellorMaster contract.
*
* The PriceFeed uses Chainlink as primary oracle, and Tellor as fallback. It contains logic for
* switching oracles based on oracle failures, timeouts, and conditions for returning to the primary
* Chainlink oracle.
*/
contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  // Mainnet Chainlink aggregator
    ITellorCaller public tellorCaller;  // Wrapper contract that calls the Tellor system

    // Core Liquity contracts
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    // Use to convert a price answer to an 18-digit precision uint
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    // Maximum time period allowed since Chainlink's latest round data timestamp, beyond which Chainlink is considered frozen.
    uint constant public TIMEOUT = 14400;  // 4 hours: 60 * 60 * 4

    // Maximum deviation allowed between two consecutive Chainlink oracle prices. 18-digit precision.
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; // 50%

    /*
    * The maximum relative price difference between two oracle responses allowed in order for the PriceFeed
    * to return to using the Chainlink oracle. 18-digit precision.
    */
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; // 5%

    // The last good price seen from an oracle by Liquity
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    // The current status of the PricFeed, which determines the conditions for the next price fetch attempt
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    // --- Dependency setters ---

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        // Explicitly set initial system status
        status = Status.chainlinkWorking;

        // Get an initial price from Chainlink to serve as first reference for lastGoodPrice
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    // --- Functions ---

    /*
    * fetchPrice():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail,
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice() external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Tellor is frozen, switch to Tellor and return last good price
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                /*
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            // If Chainlink is working and Tellor is broken, remember Tellor is broken
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            // If Chainlink is working, return Chainlink current price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }


        // --- CASE 2: The system fetched last price from Tellor ---
        if (status == Status.usingTellorChainlinkUntrusted) {
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // Otherwise, use Tellor price
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                return _storeTellorPrice(tellorResponse);
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
        if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted,
            // return Chainlink price (no status change)
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    // --- Functions ---

    /*
    * fetchPrice_vce_v():
    * Returns the latest price obtained from the Oracle. Called by Liquity functions that require a current price.
    *
    * Also callable by anyone externally.
    *
    * Non-view function - it stores the last good price seen by Liquity.
    *
    * Uses a main oracle (Chainlink) and a fallback oracle (Tellor) in case Chainlink fails. If both fail, 
    * it uses the last good price seen by Liquity.
    *
    */
    function fetchPrice_v() view external override returns (uint) {
        // Get current and previous price data from Chainlink, and current price data from Tellor
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        // --- CASE 1: System fetched last price from Chainlink  ---
        if (status == Status.chainlinkWorking) {
            // If Chainlink is broken, try Tellor
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken then both oracles are untrusted, so return the last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                /*
                * If Tellor is only frozen but otherwise returning valid data, return the last good price.
                * Tellor may need to be tipped to return current data.
                */
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                // If Chainlink is broken and Tellor is working, switch to Tellor and return current Tellor price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink is frozen, try Tellor
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                // If Tellor is broken too, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                // If Tellor is frozen or working, remember Chainlink froze, and switch to Tellor
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, use it
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // If Chainlink price has changed by > 50% between two consecutive rounds, compare it to Tellor's price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                // If Tellor is broken, both oracles are untrusted, and return last good price
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                // If Tellor is frozen, switch to Tellor and return last good price 
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                /* 
                * If Tellor is live and both oracles have a similar price, conclude that Chainlink's large price deviation between
                * two consecutive rounds was likely a legitmate market price movement, and so continue using Chainlink 
                */
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                // If Tellor is live but the oracles differ too much in price, conclude that Chainlink's initial price deviation was
                // an oracle failure. Switch to Tellor, and use Tellor price
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            // If Chainlink is working, return Chainlink current price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        // --- CASE 2: The system fetched last price from Tellor --- 
        if (status == Status.usingTellorChainlinkUntrusted) { 
            // If both Tellor and Chainlink are live, unbroken, and reporting similar prices, switch back to Chainlink
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            /*
            * If Tellor is only frozen but otherwise returning valid data, just return the last good price.
            * Tellor may need to be tipped to return current data.
            */
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            // Otherwise, use Tellor price
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 3: Both oracles were untrusted at the last price fetch ---
        if (status == Status.bothOraclesUntrusted) {
            /*
            * If both oracles are now live, unbroken and similar price, we assume that they are reporting
            * accurately, and so we switch back to Chainlink.
            */
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            // Otherwise, return the last good price - both oracles are still untrusted (no status change)
            return lastGoodPrice;
        }

        // --- CASE 4: Using Tellor, and Chainlink is frozen ---
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                // If both Oracles are broken, return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If Chainlink is broken, remember it and switch to using Tellor
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // If Tellor is working, return Tellor current price
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                // if Chainlink is frozen and Tellor is broken, remember Tellor broke, and return last good price
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                // If both are frozen, just use lastGoodPrice
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                // if Chainlink is frozen and Tellor is working, keep using Tellor (no status change)
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            // if Chainlink is live and Tellor is broken, remember Tellor broke, and return Chainlink price
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             // If Chainlink is live and Tellor is frozen, just use last good price (no status change) since we have no basis for comparison
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            // If Chainlink is live and Tellor is working, compare prices. Switch to Chainlink
            // if prices are within 5%, and return Chainlink price.
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // Otherwise if Chainlink is live but price not within 5% of Tellor, distrust Chainlink, and return Tellor price
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        // --- CASE 5: Using Chainlink, Tellor is untrusted ---
         if (status == Status.usingChainlinkTellorUntrusted) {
            // If Chainlink breaks, now both oracles are untrusted
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // If Chainlink is frozen, return last good price (no status change)
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            // If Chainlink and Tellor are both live, unbroken and similar price, switch back to chainlinkWorking and return Chainlink price
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            // If Chainlink is live but deviated >50% from it's previous price and Tellor is still untrusted, switch 
            // to bothOraclesUntrusted and return last good price
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            // Otherwise if Chainlink is live and deviated <50% from it's previous price and Tellor is still untrusted, 
            // return Chainlink price (no status change)
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    // --- Helper functions ---

    /* Chainlink is considered broken if its current or previous round data is in any way bad. We check the previous round
    * for two reasons:
    *
    * 1) It is necessary data for the price deviation check in case 1,
    * and
    * 2) Chainlink is the PriceFeed's preferred primary oracle - having two consecutive valid round responses adds
    * peace of mind when using or returning to Chainlink.
    */
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid roundId that is 0
        if (_response.roundId == 0) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for non-positive price
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        /*
        * Use the larger price as the denominator:
        * - If price decreased, the percentage deviation is in relation to the the previous price.
        * - If price increased, the percentage deviation is in relation to the current price.
        */
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        // Return true if price has more than doubled, or more than halved.
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        // Check for response call reverted
        if (!_response.success) {return true;}
        // Check for an invalid timeStamp that is 0, or in the future
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        // Check for zero price
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        // Return false if either oracle is broken or frozen
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        // Get the relative price difference between the oracles. Use the lower price as the denominator, i.e. the reference for the calculation.
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        /*
        * Return true if the relative price difference is <= 3%: if so, we assume both oracles are probably reporting
        * the honest market price, as it is unlikely that both have been broken/hacked and are still in-sync.
        */
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        /*
        * Convert the price returned by the Chainlink oracle to an 18-digit decimal for use by Liquity.
        * At date of Liquity launch, Chainlink uses an 8-digit price, but we also handle the possibility of
        * future changes.
        *
        */
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            // Scale the returned price value down to Liquity's target precision
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            // Scale the returned price value up to Liquity's target precision
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    // --- Oracle response wrapper functions ---

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            // If call to Tellor succeeds, return the response and success = true
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            // If call to Tellor reverts, return a zero response with success = false
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        // First, try to get current decimal precision:
        try priceAggregator.decimals() returns (uint8 decimals) {
            // If call to Chainlink succeeds, record the current decimal precision
            chainlinkResponse.decimals = decimals;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }

        // Secondly, try to get latest price data:
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        /*
        * NOTE: Chainlink only offers a current decimals() value - there is no way to obtain the decimal precision used in a
        * previous round.  We assume the decimals used in the previous round are the same as the current round.
        */

        // Try to get the price data from the previous round:
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 /* startedAt */,
            uint256 timestamp,
            uint80 /* answeredInRound */
        )
        {
            // If call to Chainlink succeeds, return the response and success = true
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            // If call to Chainlink aggregator reverts, return a zero response with success = false
            return prevChainlinkResponse;
        }
    }
}",7613.0,799.0,"[M-02] Should check return data from Chainlink aggregators
Function `_getCurrentChainlinkResponse`, no checks on `lastRoundData`
The latestRoundData function in the contract PriceFeed.sol fetches the asset price from a Chainlink aggregator using the latestRoundData function. However, there are no checks on roundID.
Stale prices could put funds at risk. According to Chainlink's documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price fed to the PriceOracle. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations of the liquidity.",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IPriceFeed.sol"";
import ""./Interfaces/ITellorCaller.sol"";
import ""./Dependencies/AggregatorV3Interface.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/BaseMath.sol"";
import ""./Dependencies/LiquityMath.sol"";



contract PriceFeed is Ownable, CheckContract, BaseMath, IPriceFeed {
    using SafeMath for uint256;

    string constant public NAME = ""PriceFeed"";

    AggregatorV3Interface public priceAggregator;  
    ITellorCaller public tellorCaller;  

    
    address borrowerOperationsAddress;
    address troveManagerAddress;

    uint constant public ETHUSD_TELLOR_REQ_ID = 1;

    
    uint constant public TARGET_DIGITS = 18;
    uint constant public TELLOR_DIGITS = 6;

    
    uint constant public TIMEOUT = 14400;  

    
    uint constant public MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND =  5e17; 

    
    uint constant public MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES = 5e16; 

    
    uint public lastGoodPrice;

    struct ChainlinkResponse {
        uint80 roundId;
        int256 answer;
        uint256 timestamp;
        bool success;
        uint8 decimals;
    }

    struct TellorResponse {
        bool ifRetrieve;
        uint256 value;
        uint256 timestamp;
        bool success;
    }

    enum Status {
        chainlinkWorking,
        usingTellorChainlinkUntrusted,
        bothOraclesUntrusted,
        usingTellorChainlinkFrozen,
        usingChainlinkTellorUntrusted
    }

    
    Status public status;

    event LastGoodPriceUpdated(uint _lastGoodPrice);
    event PriceFeedStatusChanged(Status newStatus);

    

    function setAddresses(
        address _priceAggregatorAddress,
        address _tellorCallerAddress
    )
    external
    onlyOwner
    {
        checkContract(_priceAggregatorAddress);
        checkContract(_tellorCallerAddress);

        priceAggregator = AggregatorV3Interface(_priceAggregatorAddress);
        tellorCaller = ITellorCaller(_tellorCallerAddress);

        
        status = Status.chainlinkWorking;

        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);

        require(!_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse) && !_chainlinkIsFrozen(chainlinkResponse),
            ""PriceFeed: Chainlink must be working and current"");

        _storeChainlinkPrice(chainlinkResponse);

        _renounceOwnership();
    }

    

    
    function fetchPrice() external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkFrozen);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {
                    _changeStatus(Status.usingTellorChainlinkUntrusted);
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    return _storeChainlinkPrice(chainlinkResponse);
                }

                
                
                _changeStatus(Status.usingTellorChainlinkUntrusted);
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
            }

            
            return _storeChainlinkPrice(chainlinkResponse);
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.bothOraclesUntrusted);
                    return lastGoodPrice;
                }

                
                _changeStatus(Status.usingTellorChainlinkUntrusted);

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    _changeStatus(Status.usingChainlinkTellorUntrusted);
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                return _storeTellorPrice(tellorResponse);
            }

            
            if (_tellorIsBroken(tellorResponse)) {
                _changeStatus(Status.usingChainlinkTellorUntrusted);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            _changeStatus(Status.usingTellorChainlinkUntrusted);
            return _storeTellorPrice(tellorResponse);
        }

        
        if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                _changeStatus(Status.chainlinkWorking);
                return _storeChainlinkPrice(chainlinkResponse);
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                _changeStatus(Status.bothOraclesUntrusted);
                return lastGoodPrice;
            }

            
            
            return _storeChainlinkPrice(chainlinkResponse);
        }
    }
    
    

    
    function fetchPrice_v() view external override returns (uint) {
        
        ChainlinkResponse memory chainlinkResponse = _getCurrentChainlinkResponse();
        ChainlinkResponse memory prevChainlinkResponse = _getPrevChainlinkResponse(chainlinkResponse.roundId, chainlinkResponse.decimals);
        TellorResponse memory tellorResponse = _getCurrentTellorResponse();

        
        if (status == Status.chainlinkWorking) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice; 
                }
                
                if (_tellorIsFrozen(tellorResponse)) {
                    return lastGoodPrice;
                }
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {          
                
                if (_tellorIsBroken(tellorResponse)) {
                    return lastGoodPrice;     
                }

                
                
               
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                 if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;     
                }

                
                if (_tellorIsFrozen(tellorResponse)) { 
                    
                    return lastGoodPrice;
                }

                
                if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                    uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                    return scaledChainlinkPrice;
                }               

                
                
                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

             

            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }


        
        if (status == Status.usingTellorChainlinkUntrusted) { 
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            if (_tellorIsBroken(tellorResponse)) {
        
                return lastGoodPrice; 
            }

            
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}
            
            
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
        if (status == Status.bothOraclesUntrusted) {
            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            } 

            
            return lastGoodPrice;
        }

        
        if (status == Status.usingTellorChainlinkFrozen) {
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                

                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            if (_chainlinkIsFrozen(chainlinkResponse)) {
                
                if (_tellorIsBroken(tellorResponse)) {
                    
                    return lastGoodPrice;
                }

                
                if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

                
                uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
                return scaledTellorPrice;
            }

            
            if (_tellorIsBroken(tellorResponse)) {
               
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

             
            if (_tellorIsFrozen(tellorResponse)) {return lastGoodPrice;}

            
            
            if (_bothOraclesSimilarPrice(chainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
           
            uint scaledTellorPrice = _scaleTellorPriceByDigits(tellorResponse.value);
            return scaledTellorPrice;
        }

        
         if (status == Status.usingChainlinkTellorUntrusted) {
            
            if (_chainlinkIsBroken(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            if (_chainlinkIsFrozen(chainlinkResponse)) {
                return lastGoodPrice;
            }

            
            if (_bothOraclesLiveAndUnbrokenAndSimilarPrice(chainlinkResponse, prevChainlinkResponse, tellorResponse)) {
                
                uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
                return scaledChainlinkPrice;
            }

            
            
            if (_chainlinkPriceChangeAboveMax(chainlinkResponse, prevChainlinkResponse)) {
                
                return lastGoodPrice;
            }

            
            
            uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(chainlinkResponse.answer), chainlinkResponse.decimals);
            return scaledChainlinkPrice;
        }
    }
    

    
    function _chainlinkIsBroken(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal view returns (bool) {
        return _badChainlinkResponse(_currentResponse) || _badChainlinkResponse(_prevResponse);
    }

    function _badChainlinkResponse(ChainlinkResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.roundId == 0) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.answer <= 0) {return true;}

        return false;
    }

    function _chainlinkIsFrozen(ChainlinkResponse memory _response) internal view returns (bool) {
        return block.timestamp.sub(_response.timestamp) > TIMEOUT;
    }

    function _chainlinkPriceChangeAboveMax(ChainlinkResponse memory _currentResponse, ChainlinkResponse memory _prevResponse) internal pure returns (bool) {
        uint currentScaledPrice = _scaleChainlinkPriceByDigits(uint256(_currentResponse.answer), _currentResponse.decimals);
        uint prevScaledPrice = _scaleChainlinkPriceByDigits(uint256(_prevResponse.answer), _prevResponse.decimals);

        uint minPrice = LiquityMath._min(currentScaledPrice, prevScaledPrice);
        uint maxPrice = LiquityMath._max(currentScaledPrice, prevScaledPrice);

        
        uint percentDeviation = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(maxPrice);

        
        return percentDeviation > MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND;
    }

    function _tellorIsBroken(TellorResponse memory _response) internal view returns (bool) {
        
        if (!_response.success) {return true;}
        
        if (_response.timestamp == 0 || _response.timestamp > block.timestamp) {return true;}
        
        if (_response.value == 0) {return true;}

        return false;
    }

    function _tellorIsFrozen(TellorResponse  memory _tellorResponse) internal view returns (bool) {
        return block.timestamp.sub(_tellorResponse.timestamp) > TIMEOUT;
    }

    function _bothOraclesLiveAndUnbrokenAndSimilarPrice
    (
        ChainlinkResponse memory _chainlinkResponse,
        ChainlinkResponse memory _prevChainlinkResponse,
        TellorResponse memory _tellorResponse
    )
    internal
    view
    returns (bool)
    {
        
        if
        (
            _tellorIsBroken(_tellorResponse) ||
            _tellorIsFrozen(_tellorResponse) ||
            _chainlinkIsBroken(_chainlinkResponse, _prevChainlinkResponse) ||
            _chainlinkIsFrozen(_chainlinkResponse)
        )
        {
            return false;
        }

        return _bothOraclesSimilarPrice(_chainlinkResponse, _tellorResponse);
    }

    function _bothOraclesSimilarPrice( ChainlinkResponse memory _chainlinkResponse, TellorResponse memory _tellorResponse) internal pure returns (bool) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);

        
        uint minPrice = LiquityMath._min(scaledTellorPrice, scaledChainlinkPrice);
        uint maxPrice = LiquityMath._max(scaledTellorPrice, scaledChainlinkPrice);
        uint percentPriceDifference = maxPrice.sub(minPrice).mul(DECIMAL_PRECISION).div(minPrice);

        
        return percentPriceDifference <= MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES;
    }

    function _scaleChainlinkPriceByDigits(uint _price, uint _answerDigits) internal pure returns (uint) {
        
        uint price;
        if (_answerDigits >= TARGET_DIGITS) {
            
            price = _price.div(10 ** (_answerDigits - TARGET_DIGITS));
        }
        else if (_answerDigits < TARGET_DIGITS) {
            
            price = _price.mul(10 ** (TARGET_DIGITS - _answerDigits));
        }
        return price;
    }

    function _scaleTellorPriceByDigits(uint _price) internal pure returns (uint) {
        return _price.mul(10**(TARGET_DIGITS - TELLOR_DIGITS));
    }

    function _changeStatus(Status _status) internal {
        status = _status;
        emit PriceFeedStatusChanged(_status);
    }

    function _storePrice(uint _currentPrice) internal {
        lastGoodPrice = _currentPrice;
        emit LastGoodPriceUpdated(_currentPrice);
    }

    function _storeTellorPrice(TellorResponse memory _tellorResponse) internal returns (uint) {
        uint scaledTellorPrice = _scaleTellorPriceByDigits(_tellorResponse.value);
        _storePrice(scaledTellorPrice);

        return scaledTellorPrice;
    }

    function _storeChainlinkPrice(ChainlinkResponse memory _chainlinkResponse) internal returns (uint) {
        uint scaledChainlinkPrice = _scaleChainlinkPriceByDigits(uint256(_chainlinkResponse.answer), _chainlinkResponse.decimals);
        _storePrice(scaledChainlinkPrice);

        return scaledChainlinkPrice;
    }

    

    function _getCurrentTellorResponse() internal view returns (TellorResponse memory tellorResponse) {
        try tellorCaller.getTellorCurrentValue(ETHUSD_TELLOR_REQ_ID) returns
        (
            bool ifRetrieve,
            uint256 value,
            uint256 _timestampRetrieved
        )
        {
            
            tellorResponse.ifRetrieve = ifRetrieve;
            tellorResponse.value = value;
            tellorResponse.timestamp = _timestampRetrieved;
            tellorResponse.success = true;

            return (tellorResponse);
        }catch {
            
            return (tellorResponse);
        }
    }

    function _getCurrentChainlinkResponse() internal view returns (ChainlinkResponse memory chainlinkResponse) {
        
        try priceAggregator.decimals() returns (uint8 decimals) {
            
            chainlinkResponse.decimals = decimals;
        } catch {
            
            return chainlinkResponse;
        }

        
        try priceAggregator.latestRoundData() returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            chainlinkResponse.roundId = roundId;
            chainlinkResponse.answer = answer;
            chainlinkResponse.timestamp = timestamp;
            chainlinkResponse.success = true;
            return chainlinkResponse;
        } catch {
            
            return chainlinkResponse;
        }
    }

    function _getPrevChainlinkResponse(uint80 _currentRoundId, uint8 _currentDecimals) internal view returns (ChainlinkResponse memory prevChainlinkResponse) {
        

        
        try priceAggregator.getRoundData(_currentRoundId - 1) returns
        (
            uint80 roundId,
            int256 answer,
            uint256 ,
            uint256 timestamp,
            uint80 
        )
        {
            
            prevChainlinkResponse.roundId = roundId;
            prevChainlinkResponse.answer = answer;
            prevChainlinkResponse.timestamp = timestamp;
            prevChainlinkResponse.decimals = _currentDecimals;
            prevChainlinkResponse.success = true;
            return prevChainlinkResponse;
        } catch {
            
            return prevChainlinkResponse;
        }
    }
}",4598.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Previous Round Handling in Chainlink**  
   The contract retrieves the previous Chainlink round using `currentRoundId - 1`, assuming sequential round IDs. Chainlink aggregators may have non-sequential round IDs (e.g., due to protocol upgrades or multi-chain feeds), leading to incorrect historical price comparisons. This could result in invalid deviation checks and improper status transitions.

2. **Fixed Decimal Assumption for Tellor**  
   The contract hardcodes Tellor's price decimals as 6 (`TELLOR_DIGITS = 6`). If the Tellor feed's decimal precision changes, the scaling logic (`_scaleTellorPriceByDigits`) will produce incorrect price values, leading to systemic pricing errors.

3. **Initialization Failure with No Previous Chainlink Round**  
   During deployment via `setAddresses`, the contract checks the previous Chainlink round. If the current round is the first (e.g., round ID 1), fetching the previous round (ID 0) will fail, causing the setup to revert. This prevents contract initialization on feeds with no historical rounds.

4. **Unhandled Chainlink Round Data Validity**  
   The contract does not validate if the fetched Chainlink round (current or previous) is the **latest available** round. If the aggregator updates infrequently, stale data might be used for comparisons, causing false positives in deviation checks (`_chainlinkPriceChangeAboveMax`).

5. **Stale Price Fallback Without Recovery Mechanism**  
   When both oracles are untrusted (`Status.bothOraclesUntrusted`), the contract indefinitely returns `lastGoodPrice`. If oracles remain offline, the price becomes stale, risking financial miscalculations (e.g., undercollateralized loans) with no way to manually intervene (due to `_renounceOwnership`).

6. **Insufficient Oracle Correlation Checks**  
   The deviation thresholds (`MAX_PRICE_DEVIATION_FROM_PREVIOUS_ROUND` and `MAX_PRICE_DIFFERENCE_BETWEEN_ORACLES`) are hardcoded. If market volatility exceeds these thresholds, valid price changes may be misclassified as faults, causing unnecessary oracle fallbacks.

7. **Lack of Oracle Freshness Validation in Status Transitions**  
   When reverting to Chainlink (e.g., in `Status.usingTellorChainlinkUntrusted`), the contract checks if both oracles agree but does not revalidate Chainlink's freshness. This could allow stale Chainlink data to be accepted if Tellor is temporarily unavailable.","### **[M-02] Should check return data from Chainlink aggregators**

**Report Description**:  
The function `_getCurrentChainlinkResponse` in `PriceFeed.sol` fetches the asset price from a Chainlink aggregator using the `latestRoundData` function. However, it does not validate the `roundID` or other critical return values (e.g., `answeredInRound`, `timestamp`). According to Chainlink's documentation, this function may return stale or incorrect data (e.g., `0` for price) if no answer has been reached. This oversight could lead to stale or incorrect prices being fed into the system, potentially resulting in financial risks such as undercollateralized loans or incorrect liquidity calculations. The dependency on external Chainlink oracles introduces inherent risks, including outdated data due to oracle failures or maintenance issues.

**Match in Response List**:  
Matches with the issue titled **""Unhandled Chainlink Round Data Validity""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unvalidated Chainlink round data, which aligns with the core concern in the issue report. However, the response focuses on the **latest available round** and does not explicitly mention the risks associated with stale data (e.g., `roundID`, `answeredInRound`, or `timestamp` checks). While the response partially addresses the issue, it misses critical details about the specific return values that need validation, as highlighted in the issue report.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-02] Should check return data from Chainlink aggregators**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis of Gaps**  
The response list partially addresses the issue but does not fully capture the risks associated with unvalidated Chainlink return values, such as `roundID`, `answeredInRound`, and `timestamp`. These details are critical for ensuring the freshness and accuracy of oracle data, as highlighted in the issue report. A more comprehensive response would explicitly mention the need to validate these return values to mitigate the risks of stale or incorrect data.",0,1,0,7,"Okay, I need to analyze this smart contract for vulnerabilities. Let me start by reading through the code carefully. The contract is called PriceFeed and it's using both Chainlink and Tellor as oracles to fetch prices. The main function seems to be fetchPrice, which determines the current price based on these oracles and handles various failure scenarios.

First, I'll check for common vulnerabilities like reentrancy. But since this contract doesn't handle funds directly, maybe that's not an issue here. Next, look at the oracle integrations. Both Chainlink and Tellor are used, so maybe there are issues with how the data is validated.

Looking at the _getCurrentChainlinkResponse function, it calls latestRoundData. I remember that not checking for stale prices or incomplete rounds can be a problem. Wait, the code here does check the timestamp against block.timestamp in _chainlinkIsFrozen, which uses a TIMEOUT of 14400 seconds (4 hours). That's good, but maybe the timeout is too long? The problem is if the price is stale, but according to the contract's design, maybe that's intentional.

In the _chainlinkIsBroken function, they check if the response's timestamp is 0 or greater than block.timestamp. Also, they check if the answer is <=0. That seems okay. But what about if the round IDs are not incremental? For example, if the current round ID is not higher than the previous one, that could indicate a problem. But the code here compares the previous round by subtracting 1 from the current round ID. Wait, in _getPrevChainlinkResponse, they get the round data for _currentRoundId - 1. But Chainlink's round IDs might not always be sequential. Some feeds might have non-sequential round IDs, especially if there are multiple aggregators. So relying on currentRoundId -1 could fetch an incorrect or non-existent round. This is a potential vulnerability because it assumes that rounds are consecutive, which might not be the case. This could lead to using incorrect historical data.

Another thing: when scaling the Chainlink price, the code checks if the decimals are higher or lower than TARGET_DIGITS (18). For example, if the Chainlink feed has 8 decimals, it multiplies by 10^10 to get to 18. But if the feed's decimals could be more than 18, then dividing might result in a loss of precision. However, most Chainlink feeds have 8 decimals, so maybe this isn't an issue. But it's a potential point of failure if a feed with higher decimals is used.

Looking at Tellor integration: in _getCurrentTellorResponse, they call tellorCaller.getTellorCurrentValue. If this call fails, it returns a response with success=false. But if the Tellor call reverts, the try/catch will return a default-initialized TellorResponse where success is false. So that's handled, but maybe there's a scenario where the Tellor returns a value that's stale or incorrect, but passes the checks. For example, if Tellor's value is outdated but within the timeout, but the code relies on the timestamp check.

The status transitions: the contract has different statuses based on oracle reliability. For example, if Chainlink is broken, it switches to using Tellor. But if both oracles are untrusted, it uses the lastGoodPrice. However, if both oracles are providing bad data but not detected (e.g., manipulated prices), the system could keep using incorrect prices. But that's more of an oracle reliability issue rather than a contract vulnerability.

Another potential issue is the use of SafeMath. The contract uses SafeMath for uint256, which is good, but since Solidity 0.8.0, checked math is built-in. However, the contract is using 0.6.11, so SafeMath is necessary. The code seems to be using .mul and .div with SafeMath correctly.

In the setAddresses function, after setting up the oracles, it checks if Chainlink is working by calling _getCurrentChainlinkResponse and _getPrevChainlinkResponse. If either is broken or frozen, the function reverts. But during setup, if the previous round is invalid (e.g., because the current round is the first one), _getPrevChainlinkResponse might fail. For example, if the current round ID is 1, subtracting 1 gives 0, which may not exist. This could cause the initial setup to fail if there's no previous round, making the contract impossible to deploy in certain scenarios.

The TIMEOUT is set to 4 hours. If the price feed updates less frequently than this, the contract might consider the oracle frozen even when it's functioning normally. For example, if Chainlink's feed updates once a day, the contract would switch to Tellor after 4 hours, which might not be intended. However, this depends on the specific feed's expected update frequency.

In the _bothOraclesSimilarPrice function, the code calculates the percentage difference between Chainlink and Tellor prices. If the minimum price is zero, this would cause a division by zero. However, the checks in _tellorIsBroken and _chainlinkIsBroken should prevent zero prices from being considered valid, so maybe this isn't an issue. For example, TellorResponse.value is checked to be non-zero in _tellorIsBroken, and Chainlink's answer is checked to be positive in _badChainlinkResponse. So the minPrice should never be zero here.

Another thing: when scaling the Tellor price, it's multiplied by 10^(18-6) = 1e12. But if the Tellor value is not properly scaled, this could lead to incorrect prices. For example, if Tellor returns a value in USD with 8 decimals instead of 6, the scaling would be wrong. But the code assumes TELLOR_DIGITS is 6, which must match the actual Tellor feed's decimals. If the Tellor feed's decimals change, this would cause incorrect scaling. This is a dependency on external configuration, which could be a vulnerability if not properly maintained.

In fetchPrice, when the status is usingTellorChainlinkUntrusted, it checks if both oracles are live and unbroken. If so, it switches back to chainlinkWorking. However, if an attacker could manipulate one oracle's price to match the other's incorrect value, they could trick the contract into considering both oracles valid again. This is a possible oracle manipulation issue, but it's more about the security of the oracles themselves.

Also, the contract uses lastGoodPrice as a fallback. If both oracles are untrusted or broken, the contract will keep returning the last stored price, which could become outdated. This might lead to stale prices being used for critical functions like loans, leading to undercollateralization if the actual price changes significantly. However, the contract's design allows this as a last resort, so it's more of a systemic risk than a code vulnerability.

Potential vulnerabilities identified so far:

1. Incorrect handling of Chainlink round IDs by assuming they are sequential. Using currentRoundId -1 to get the previous round may not always work, leading to incorrect price comparisons.
2. Dependency on Tellor's response having exactly 6 decimals. If the Tellor feed's decimals change, the scaling would be incorrect.
3. During setup in setAddresses, if the previous Chainlink round does not exist (e.g., first round), the initial check would fail, preventing contract deployment.
4. The timeout duration might not suit the feed's update frequency, causing unnecessary status changes.
5. If both oracles are manipulated to provide similar incorrect prices, the contract might accept them as valid, leading to incorrect price updates.

Let me check each of these again.

For point 1: The code in _getPrevChainlinkResponse uses _currentRoundId -1. But Chainlink's rounds might not be incremented by 1 each time. For example, if there's a new round due to a Chainlink update, the round ID might jump by more than 1. Thus, fetching _currentRoundId -1 could get an older round than intended, or even a non-existent one. For example, if the current round is 100, the previous might be 99, but if the rounds are 100, 200, etc., then 100-1=99 would not exist, and the call would fail. In that case, _getPrevChainlinkResponse would return a failed response, and _chainlinkIsBroken would mark it as broken. But in the setAddresses function, during initialization, if the previous round is not available, the require statement would fail, making deployment impossible. However, in normal operation, if the current round is valid but the previous is not, the contract would consider Chainlink broken and switch to Tellor. This could be a problem if the previous round is not available, but the current is valid. So maybe the contract is too strict here, leading to unnecessary status changes.

For point 3: If during deployment, the current round is the first one (roundId=1), then trying to get roundId=0 would fail. The _getPrevChainlinkResponse would return a response where success is false. Then, in the setAddresses function, the require statement checks that Chainlink is not broken and not frozen. The _chainlinkIsBroken check would include checking the previous response (which failed), thus making the require statement fail. This would prevent the contract from being initialized if there's no previous round. This is a problem because some Chainlink feeds might start at round 1, and the initial setup would fail.

Other possible issues: The contract uses block.timestamp, which can be manipulated by miners to some extent, but for timeout checks (like 4 hours), this is generally considered acceptable.

Another thing: In the fetchPrice function, when the status is Status.chainlinkWorking, if Chainlink's price change is above the maximum allowed deviation, the code checks Tellor's status. If Tellor is not broken or frozen, and both oracles have similar prices, it uses Chainlink's price. Otherwise, it switches to Tellor. However, if an attacker can cause a large price deviation in Chainlink (e.g., through a flash crash), the contract might switch to Tellor, which could also be manipulated. This is more of an oracle reliability issue than a code vulnerability.

Potential vulnerabilities summary:

1. **Incorrect Previous Round Handling in Chainlink**: The contract assumes that the previous round ID is currentRoundId - 1, which may not be valid, leading to incorrect historical data checks.
2. **Reliance on Fixed Decimal Places for Tellor**: The contract scales Tellor's price assuming 6 decimals, which could be incorrect if the Tellor feed changes.
3. **Initialization Failure Due to Missing Previous Round**: During deployment, if Chainlink's current round is the first, the contract cannot be initialized.
4. **Stale Price Risk**: If both oracles fail, the contract uses the lastGoodPrice, which may become stale, affecting system solvency.
5. **Potential Division by Zero in Price Comparison**: Although checks exist, if both oracles return the minimum possible price, a division by zero could occur in _bothOraclesSimilarPrice. Wait, the code uses LiquityMath._min and _max. If minPrice is zero, the division would fail. However, _tellorIsBroken checks if value == 0, and _chainlinkIsBroken checks if answer <=0, so in normal operation, minPrice should be at least 1 wei. So maybe this is not an issue.

I need to list all the vulnerabilities without considering mitigations. So from the above, the main ones are:

- Incorrect handling of Chainlink's previous round ID by assuming sequential rounds.
- Tellor's decimal assumption could be incorrect if the feed changes.
- Initialization failure when the first round of Chainlink is used, preventing contract deployment.
- Using lastGoodPrice when both oracles are down could lead to stale prices, but this is part of the design.

Wait, maybe the first three are actual vulnerabilities. The last one is more of a design choice. The initialization failure is a vulnerability because it could prevent the contract from being deployed if the Chainlink feed doesn't have a previous round. For example, newly deployed Chainlink aggregators start with round 1, so the initial setup would fail.

So the list would be:

1. **Incorrect Previous Round Handling in Chainlink**: The contract retrieves the previous Chainlink round by subtracting 1 from the current round ID, which may not be valid if rounds are not sequential. This can lead to incorrect price comparisons and improper status transitions.

2. **Tellor Decimal Assumption Risk**: The contract assumes Tellor's price feed uses 6 decimals, hardcoded as TELLOR_DIGITS. If the Tellor feed's decimal count changes, the scaled price will be incorrect, leading to erroneous price data.

3. **Initialization Vulnerability with Chainlink's First Round**: During contract setup via setAddresses, if the Chainlink aggregator's current round is the first (e.g., roundId=1), attempting to fetch the previous round (roundId=0) will fail. This causes the initial check to fail, preventing contract deployment or initialization.

4. **Potential Stale Price from LastGoodPrice**: While not a code vulnerability per se, relying on lastGoodPrice when both oracles are untrusted can result in using outdated prices, posing a systemic risk if the price isn't updated.

Wait, the question says ""list all vulnerabilities in the following smart contract, no need for Mitigation"". So maybe the last point is a design flaw but not necessarily a vulnerability. The main code vulnerabilities are the first three.

Another possible issue: The function _getPrevChainlinkResponse uses getRoundData with _currentRoundId -1, but if the aggregator skips rounds (like some do for various reasons), this would get an older round, not necessarily the immediate previous one. This can cause the contract to compare the current price with a much older price, leading to incorrect deviation checks.

Yes, that's part of point 1.

Another vulnerability: Reentrancy in fetchPrice? The function is external and returns a price, but doesn't make external calls except to the oracles (Chainlink and Tellor), which are view functions. So no reentrancy risk here.

What about the use of block.timestamp? It's used for checking timeouts, which is okay since the TIMEOUT is 4 hours, and minor miner manipulation is acceptable.

So the final list of vulnerabilities:

1. **Incorrect Previous Round Handling in Chainlink**: The contract assumes that the previous round ID is current round ID minus one, which may not be valid if rounds are not sequential. This can result in incorrect historical data comparison and improper status changes.

2. **Fixed Decimal Assumption for Tellor**: The contract scales Tellor's price based on a hardcoded 6 decimal places. If the Tellor feed's decimal count changes, this would lead to incorrect price scaling and mispricing.

3. **Initialization Failure with No Previous Chainlink Round**: During deployment, if the Chainlink aggregator's current round is the first, fetching the previous round (ID 0) will fail, causing the contract setup to revert and preventing deployment.

4. **Unchecked Stale Price Fallback**: When both oracles are deemed untrusted, the contract indefinitely returns the last stored good price, which may become stale, potentially leading to incorrect financial calculations reliant on the price feed.

Wait, the fourth point is part of the design, but if the contract doesn't have a mechanism to recover or alert when both oracles fail, relying on lastGoodPrice indefinitely could be a vulnerability. However, the question is about code vulnerabilities, not design choices. Maybe this is a vulnerability because the system depends on the oracles being functional, and if they both fail, the contract doesn't have a way to update the price anymore.

But according to the problem statement, we should list all vulnerabilities. If the lastGoodPrice is used indefinitely without any way to update, that's a potential issue. However, once the oracles recover, the status could change. For example, if both start working again, the fetchPrice function would detect that and update the price. So maybe the stale price is temporary. However, if both oracles remain broken, the lastGoodPrice will be stuck. This is a risk, but perhaps it's considered a known limitation rather than a vulnerability. The problem is whether it's a vulnerability in the code.

Alternatively, the contract's logic may allow the price to be updated again if the oracles come back online, so the lastGoodPrice is only a temporary fallback. Therefore, this might not be a code vulnerability but a known behavior.

So focusing on code-specific issues, the main ones are the first three points.","```
None.
```",0.0
ActivePool.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";

/*
 * The Active Pool holds the all collateral and YUSD debt (but not YUSD tokens) for all active troves.
 *
 * When a trove is liquidated, its collateral and YUSD debt are transferred from the Active Pool, to either the
 * Stability Pool, the Default Pool, or both, depending on the liquidation conditions.
 *
 */
contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    // deposited collateral tracker. Colls is always the whitelist list of all collateral tokens. Amounts 
    newColls internal poolColl;

    // YUSD Debt tracker. Tracker of all debt in the system. 
    uint256 internal YUSDDebt;

    // --- Events ---

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    // --- Contract setters ---

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    // --- Internal Functions ---

    // --- Getters for public variables. Required by IPool interface ---

    /*
    * Returns the collateralBalance for a given collateral
    *
    * Returns the amount of a given collateral in state. Not necessarily the contract's actual balance.
    */
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    /*
    * Returns all collateral balances in state. Not necessarily the contract's actual balances.
    */
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    // returns the VC value of a given collateralAddress in this contract
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    /*
    * Returns the VC of the contract
    *
    * Not necessarily equal to the the contract's raw VC balance - Collateral can be forcibly sent to contracts.
    *
    * Computed when called by taking the collateral balances and
    * multiplying them by the corresponding price and ratio and then summing that
    */
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    // Debt that this pool holds. 
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    // --- Pool functionality ---

    // Internal function to send collateral to a different pool. 
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool. 
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); // reverts if send fails
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    // Returns true if all payments were successfully sent. Must be called by borrower operations, trove manager, or stability pool.
    // This function als ounwraps the collaterals and sends them to _to, if they are wrapped assets. If collect rewards is set to true,
    // It also harvests rewards on the user's behalf. 
    // _from is where the reward balance is, _to is where to send the tokens. 
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                // Collects rewards automatically for that amount and unwraps for the original borrower. 
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); // reverts if send fails
            }
        }
        return true;
    }

    // Function for sending single collateral. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); // reverts if send fails
        return true;
    }

    // Function for sending single collateral and unwrapping. Currently only used by borrower operations unlever up functionality
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            // Collects rewards automatically for that amount and unwraps for the original borrower. 
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); // reverts if send fails
        }
        return true;
    }

    // View function that returns if the contract transferring to needs to have its balances updated. 
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    // Increases the YUSD Debt of this pool. 
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // Decreases the YUSD Debt of this pool. 
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    // --- 'require' functions ---

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    // should be called by BorrowerOperations or DefaultPool
    // __after__ collateral is transferred to this contract.
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    // Adds collateral type from whitelist. 
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2716.0,304.0,"[M-03] Unwhitelisted token can cause disaster
Contract instability and financial loss. This will happen if one of the allowed contract calls sendCollaterals with non whitelisted token (may happen with user input on allowed contract)
â€¨â€¨[M-04] Out of gas.
There is no upper limit onÂ `poolColl.tokens[]`, it increments each time when a new collateral is added. Eventually, as the count of collateral increases, gas cost of smart contract calls will raise and that there is no implemented function to reduce the array size.
Impact: For every callÂ `getVC()`Â function which computed contain the VC value of a given collateralAddress is listed inÂ `poolColl.tokens[]`Â array, the gas consumption can be more expensive each time that a new collateral address is appended to the array, until reaching an ""Out of Gas"" error or a ""Block Gas Limit"" in the worst scenario.",2.0,"pragma solidity 0.6.11;

import './Interfaces/IActivePool.sol';
import ""./Interfaces/IWhitelist.sol"";
import './Interfaces/IERC20.sol';
import ""./Interfaces/IWAsset.sol"";
import ""./Dependencies/SafeMath.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Dependencies/YetiCustomBase.sol"";
import ""./Dependencies/SafeERC20.sol"";


contract ActivePool is Ownable, CheckContract, IActivePool, YetiCustomBase {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    bytes32 constant public NAME = ""ActivePool"";

    address internal borrowerOperationsAddress;
    address internal troveManagerAddress;
    address internal stabilityPoolAddress;
    address internal defaultPoolAddress;
    address internal troveManagerLiquidationsAddress;
    address internal troveManagerRedemptionsAddress;
    address internal collSurplusPoolAddress;

    
    
    newColls internal poolColl;

    
    uint256 internal YUSDDebt;

    

    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);
    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolYUSDDebtUpdated(uint _YUSDDebt);
    event ActivePoolBalanceUpdated(address _collateral, uint _amount);
    event ActivePoolBalancesUpdated(address[] _collaterals, uint256[] _amounts);
    event CollateralsSent(address[] _collaterals, uint256[] _amounts, address _to);

    

    function setAddresses(
        address _borrowerOperationsAddress,
        address _troveManagerAddress,
        address _stabilityPoolAddress,
        address _defaultPoolAddress,
        address _whitelistAddress,
        address _troveManagerLiquidationsAddress,
        address _troveManagerRedemptionsAddress,
        address _collSurplusPoolAddress
    )
        external
        onlyOwner
    {
        checkContract(_borrowerOperationsAddress);
        checkContract(_troveManagerAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_whitelistAddress);
        checkContract(_troveManagerLiquidationsAddress);
        checkContract(_troveManagerRedemptionsAddress);
        checkContract(_collSurplusPoolAddress);

        borrowerOperationsAddress = _borrowerOperationsAddress;
        troveManagerAddress = _troveManagerAddress;
        stabilityPoolAddress = _stabilityPoolAddress;
        defaultPoolAddress = _defaultPoolAddress;
        whitelist = IWhitelist(_whitelistAddress);
        troveManagerLiquidationsAddress = _troveManagerLiquidationsAddress;
        troveManagerRedemptionsAddress = _troveManagerRedemptionsAddress;
        collSurplusPoolAddress = _collSurplusPoolAddress;

        emit BorrowerOperationsAddressChanged(_borrowerOperationsAddress);
        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit WhitelistAddressChanged(_whitelistAddress);

        _renounceOwnership();
    }

    

    

    
    function getCollateral(address _collateral) public view override returns (uint) {
        return poolColl.amounts[whitelist.getIndex(_collateral)];
    }

    
    function getAllCollateral() public view override returns (address[] memory, uint256[] memory) {
        return (poolColl.tokens, poolColl.amounts);
    }

    
    function getCollateralVC(address _collateral) external view override returns (uint) {
        return whitelist.getValueVC(_collateral, getCollateral(_collateral));
    }


    
    function getVC() external view override returns (uint totalVC) {
        uint len = poolColl.tokens.length;
        for (uint256 i; i < len; ++i) {
            address collateral = poolColl.tokens[i];
            uint amount = poolColl.amounts[i];

            uint collateralVC = whitelist.getValueVC(collateral, amount);

            totalVC = totalVC.add(collateralVC);
        }
    }


    
    function getYUSDDebt() external view override returns (uint) {
        return YUSDDebt;
    }

    

    
    function _sendCollateral(address _to, address _collateral, uint _amount) internal {
        uint index = whitelist.getIndex(_collateral);
        poolColl.amounts[index] = poolColl.amounts[index].sub(_amount);
        IERC20(_collateral).safeTransfer(_to, _amount);

        emit ActivePoolBalanceUpdated(_collateral, _amount);
        emit CollateralSent(_collateral, _to, _amount);
    }

    
    function sendCollaterals(address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 len = _tokens.length;
        require(len == _amounts.length, ""AP:Lengths"");
        uint256 thisAmount;
        for (uint256 i; i < len; ++i) {
            thisAmount = _amounts[i];
            if (thisAmount != 0) {
                _sendCollateral(_to, _tokens[i], thisAmount); 
            }
        }

        if (_needsUpdateCollateral(_to)) {
            ICollateralReceiver(_to).receiveCollateral(_tokens, _amounts);
        }

        emit CollateralsSent(_tokens, _amounts, _to);
        
        return true;
    }

    
    
    
    
    function sendCollateralsUnwrap(address _from, address _to, address[] calldata _tokens, uint[] calldata _amounts) external override returns (bool) {
        _requireCallerIsBOorTroveMorTMLorSP();
        uint256 tokensLen = _tokens.length;
        require(tokensLen == _amounts.length, ""AP:Lengths"");
        for (uint256 i; i < tokensLen; ++i) {
            if (whitelist.isWrapped(_tokens[i])) {
                
                IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
            } else {
                _sendCollateral(_to, _tokens[i], _amounts[i]); 
            }
        }
        return true;
    }

    
    function sendSingleCollateral(address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        _sendCollateral(_to, _token, _amount); 
        return true;
    }

    
    function sendSingleCollateralUnwrap(address _from, address _to, address _token, uint256 _amount) external override returns (bool) {
        _requireCallerIsBorrowerOperations();
        if (whitelist.isWrapped(_token)) {
            
            IWAsset(_token).unwrapFor(_from, _to, _amount);
        } else {
            _sendCollateral(_to, _token, _amount); 
        }
        return true;
    }

    
    function _needsUpdateCollateral(address _contractAddress) internal view returns (bool) {
        return ((_contractAddress == defaultPoolAddress) || (_contractAddress == stabilityPoolAddress) || (_contractAddress == collSurplusPoolAddress));
    }

    
    function increaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveM();
        YUSDDebt  = YUSDDebt.add(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    
    function decreaseYUSDDebt(uint _amount) external override {
        _requireCallerIsBOorTroveMorSP();
        YUSDDebt = YUSDDebt.sub(_amount);
        emit ActivePoolYUSDDebtUpdated(YUSDDebt);
    }

    

    function _requireCallerIsBOorTroveMorTMLorSP() internal view {
        if (
            msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerLiquidationsAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperationsOrDefaultPool() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != defaultPoolAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBorrowerOperations() internal view {
        if (msg.sender != borrowerOperationsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveMorSP() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress &&
            msg.sender != stabilityPoolAddress &&
            msg.sender != troveManagerRedemptionsAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsBOorTroveM() internal view {
        if (msg.sender != borrowerOperationsAddress &&
            msg.sender != troveManagerAddress) {
                _revertWrongFuncCaller();
            }
    }

    function _requireCallerIsWhitelist() internal view {
        if (msg.sender != address(whitelist)) {
            _revertWrongFuncCaller();
        }
    }

    function _revertWrongFuncCaller() internal view {
        revert(""AP: External caller not allowed"");
    }

    
    
    function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
        _requireCallerIsBorrowerOperationsOrDefaultPool();
        poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
        emit ActivePoolBalancesUpdated(_tokens, _amounts);
    }

    
    function addCollateralType(address _collateral) external override {
        _requireCallerIsWhitelist();
        poolColl.tokens.push(_collateral);
        poolColl.amounts.push(0);
    }

}",2101.0,0,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Accounting for Unwrapped Collateral**  
   - **Description**: The `sendCollateralsUnwrap` and `sendSingleCollateralUnwrap` functions call `IWAsset.unwrapFor` but do not deduct the unwrapped token amount from the ActivePool's internal balances (`poolColl.amounts`). This results in the ActivePool's records overstating its wrapped token balances, enabling potential fund duplication or loss.  
   - **Impact**: Severe mismatch between actual and recorded token balances, leading to possible fund drainage or incorrect collateral accounting.

2. **Missing Array Length Validation in `receiveCollateral`**  
   - **Description**: The `receiveCollateral` function does not validate that the `_tokens` and `_amounts` arrays have equal lengths. If trusted contracts pass mismatched arrays, the internal `_leftSumColls` function may process data incorrectly, causing runtime errors or accounting corruption.  
   - **Impact**: Potential incorrect collateral tracking or contract reverts due to invalid array operations.

3. **Duplicate Collateral Entries via `addCollateralType`**  
   - **Description**: The `addCollateralType` function allows the same collateral address to be added multiple times to `poolColl.tokens`, creating duplicate entries. This could lead to redundant tracking of the same collateral and errors in balance summation or collateral management.  
   - **Impact**: Inaccurate collateral reporting and potential overflow/underflow during balance updates.

4. **Unchecked Return Value for `IWAsset.unwrapFor`**  
   - **Description**: The contract assumes `IWAsset.unwrapFor` always succeeds without checking its return value (if any). If the function fails (e.g., due to insufficient balance), the ActivePool proceeds without reverting, potentially leaving operations in an inconsistent state.  
   - **Impact**: Silent failures during unwrapping, leading to incomplete transactions or state inconsistencies.

5. **Denial-of-Service via Removed Collateral in Whitelist**  
   - **Description**: If a collateral is removed from the whitelist but remains in `poolColl.tokens`, calls to `getCollateral` (which relies on `whitelist.getIndex`) may revert. This can disrupt functions dependent on collateral data.  
   - **Impact**: Temporary or permanent DoS for functions relying on collateral queries.

6. **Centralized Control During Initialization**  
   - **Description**: The `setAddresses` function permanently renounces ownership, making the contract immutable after setup. Incorrect initial configurations (e.g., wrong contract addresses) cannot be fixed, posing a systemic risk.  
   - **Impact**: Immutable contract state leading to irrecoverable errors if initial setup is flawed.","### **[M-03] Unwhitelisted token can cause disaster**

**Report Description**:  
The issue arises when an unwhitelisted token is used in the `sendCollaterals` function, potentially due to user input on an allowed contract. This can lead to contract instability and financial loss, as the system is not designed to handle non-whitelisted tokens.

**Match in Response List**:  
Matches with the issue titled **""Denial-of-Service via Removed Collateral in Whitelist""**.

**Validation**:  
**Partially Correct**. The response identifies a related issue involving the whitelist, specifically the removal of collateral from the whitelist causing potential DoS. However, it does not directly address the risk of unwhitelisted tokens being used in `sendCollaterals`, which is the core concern of the reported issue. The response partially covers the whitelist-related risk but misses the specific scenario described in the report.

---

### **[M-04] Out of gas**

**Report Description**:  
The `poolColl.tokens[]` array has no upper limit and grows each time a new collateral is added. As the array size increases, the gas cost of smart contract calls, particularly the `getVC()` function, rises. This can eventually lead to an ""Out of Gas"" error or exceed the block gas limit, making the contract unusable.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unbounded array growth in `poolColl.tokens[]` or the associated gas cost escalation. This is a critical oversight, as the issue poses a significant risk to contract functionality and scalability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-03] Unwhitelisted token can cause disaster**

**Missed Issues from Issue Report**:  
- **[M-04] Out of gas**

---

### **Analysis of Gaps**  
The response list fails to address the **out-of-gas issue** ([M-04]), which is a significant vulnerability due to unbounded array growth. While the **whitelist-related issue** ([M-03]) is partially covered, the specific risk of unwhitelisted tokens causing instability is not fully addressed. The response list could be improved by including explicit checks for array size limits and handling of unwhitelisted tokens in critical functions.",0,1,1,6,"Okay, let me try to analyze this smart contract for vulnerabilities. So, the contract is called ActivePool and it's written in Solidity 0.6.11. First, I should check for common issues like reentrancy, access control problems, integer overflows/underflows, etc. 

Looking at the imports, they're using SafeMath and SafeERC20, which is good. That should handle overflows and safe token transfers. The contract inherits from Ownable, CheckContract, IActivePool, and YetiCustomBase. There's a lot of external interfaces here, so dependencies might matter, but since we can't see those, maybe focus on the code given.

Starting with the setAddresses function. It's external and onlyOwner, and calls checkContract on each address. Then it renounces ownership by calling _renounceOwnership(). So after deployment, the owner can't change any addresses. That's good because it prevents later changes, but if any addresses are set incorrectly, they can't be fixed. So maybe a centralization risk if setup is wrong, but once set, it's immutable.

Next, looking at the functions that transfer collateral. The _sendCollateral function uses SafeMath's sub and safeTransfer. The sendCollaterals function is external and calls _sendCollateral in a loop. It checks the caller via _requireCallerIsBOorTroveMorTMLorSP(). So only specific contracts can call this. Let me check what those addresses are. The modifiers check if the msg.sender is one of borrowerOperationsAddress, troveManagerAddress, stabilityPoolAddress, troveManagerLiquidationsAddress, or troveManagerRedemptionsAddress. So access control here seems properly restricted.

Wait, but in sendCollaterals, after sending the collateral, there's a check if _needsUpdateCollateral(_to) which calls receiveCollateral on the _to address. The _needsUpdateCollateral checks if _to is defaultPool, stabilityPool, or collSurplusPool. So when sending to these contracts, it triggers their receiveCollateral function. But if any of these contracts have a malicious receiveCollateral function, could that cause issues? But since the addresses are set during setup and renounced, maybe not. But if those contracts have vulnerabilities, that's a different issue.

Looking at sendCollateralsUnwrap, which handles wrapped assets. It calls IWAsset's unwrapFor. The parameters are passed from the caller, so need to check if the tokens and amounts are validated. The function checks the caller via the same _requireCallerIsBOorTroveMorTMLorSP(), so only allowed contracts can call it. But what if the _from address is arbitrary? Since unwrapFor is called with _from, does that allow anyone to unwrap tokens on behalf of others? Wait, the function is called by allowed contracts, so maybe they ensure that _from is the correct user. But if not properly validated, maybe there's an issue here. For example, if a malicious user can get their address passed as _from, allowing unwrapping without permission. But since the caller is a trusted contract, maybe that's handled elsewhere. Still, it's a potential area to check.

In the receiveCollateral function, it's called by BorrowerOperations or DefaultPool. It updates poolColl.amounts by _leftSumColls, which probably adds the amounts. But how is _leftSumColls implemented? Since it's not in the code, but the name suggests it's summing the collateral amounts. If there's a mismatch in the lengths of tokens and amounts arrays, could that cause issues? The function requires that the caller is BorrowerOperations or DefaultPool, which are trusted, so maybe not. But if the external function passes incorrect arrays, perhaps leading to incorrect accounting. However, since the code isn't provided for _leftSumColls, it's hard to tell. But assuming it's correctly implemented, maybe not an issue here.

Another thing: the function addCollateralType is external and can be called by the whitelist. So if the whitelist is compromised, someone could add a malicious collateral type. But the whitelist is set during setup, and if it's a correct contract, this is okay. But if the whitelist has a vulnerability, that could affect this contract. However, that's a dependency issue.

Looking at the modifiers: functions like increaseYUSDDebt and decreaseYUSDDebt have specific access controls. For example, increaseYUSDDebt requires caller to be BO or TroveM. Decrease requires BO, TroveM, or SP. So access control is properly enforced here.

Reentrancy: Since the contract uses SafeERC20's safeTransfer, which calls external contracts. So when sending collateral (ERC20 tokens), if the token is malicious and calls back into the contract, could that cause reentrancy? Let's see. The _sendCollateral function first subtracts the amount from poolColl.amounts, then does the transfer. So the state is updated before the external call, which follows the checks-effects-interactions pattern. Therefore, reentrancy here should not be a problem. Because the state is changed before the transfer, even if the token calls back into the contract, the poolColl.amounts would already be reduced. So that's safe.

Another potential issue: In sendCollaterals, the code loops through the tokens and amounts, and for each, calls _sendCollateral. However, if one of the tokens is a contract that reverts on transfer (e.g., due to insufficient balance), the entire transaction would fail. But since the ActivePool is supposed to hold the collateral, if it doesn't have enough balance, that's a problem. But the _sendCollateral uses SafeMath's sub, which would revert if the pool doesn't have enough. So that's handled.

Wait, but in sendCollaterals, the code does a loop for each token and amount. For each, it checks if thisAmount != 0. If it is zero, skips. Then calls _sendCollateral. But what if the ActivePool's balance for a token is less than the amount being sent? Then the sub in _sendCollateral would revert. So the function expects that the caller ensures the amounts are valid. But since the callers are trusted contracts (BO, TroveManager, etc.), perhaps they ensure that the amounts are correct. So maybe not a vulnerability here.

What about the function sendCollateralsUnwrap? It handles wrapped tokens by calling unwrapFor. The parameters here are _from and _to. The function is called by trusted contracts, but if the _from address is not properly validated, it might allow unwrapping tokens on behalf of others. For example, if the trusted contract passes a wrong _from address, the unwrap could transfer tokens that don't belong to the caller. However, this would be a problem in the caller's logic, not the ActivePool itself. So as long as the trusted contracts (like BorrowerOperations) correctly handle _from, this is okay. But if a trusted contract is compromised, then this could be an issue.

Another thing: the ActivePool holds collateral and YUSD debt. The functions that modify YUSDDebt (increase and decrease) are protected, so only allowed contracts can change it. So that's okay.

Possible vulnerabilities I can think of:

1. Centralization Risk: Once the ownership is renounced, no changes can be made. If there's a bug in the contract, it can't be fixed. But this is by design, so not a vulnerability per se.

2. Front-running or Race Conditions: Not obvious here. The functions are protected and state changes happen before external calls.

3. Incorrect Collateral Accounting: If the _leftSumColls function has a bug, but since it's not shown, maybe not. However, in receiveCollateral, when adding collateral, if the array lengths don't match, could there be an issue? For example, if _tokens and _amounts have different lengths. The function receiveCollateral is called by BorrowerOperations or DefaultPool, which are trusted, so they should ensure the arrays are correct. But the function itself doesn't check the lengths. So if a malicious or faulty caller sends arrays of different lengths, it could cause incorrect accounting. For example, in receiveCollateral, if _tokens.length != _amounts.length, then _leftSumColls might process them incorrectly. But since receiveCollateral is only called by trusted contracts, maybe they ensure the arrays are correct. However, the function doesn't have a check, so if those contracts have a bug, it could propagate here. So this is a possible vulnerability: lack of input validation in receiveCollateral for array length consistency.

Wait, in the sendCollaterals function, there's a check: require(len == _amounts.length, ""AP:Lengths""). So the external sendCollaterals checks the lengths. But receiveCollateral is called via the function receiveCollateral, which is external. Let me check the code:

function receiveCollateral(address[] calldata _tokens, uint[] calldata _amounts) external override {
    _requireCallerIsBorrowerOperationsOrDefaultPool();
    poolColl.amounts = _leftSumColls(poolColl, _tokens, _amounts);
    emit ActivePoolBalancesUpdated(_tokens, _amounts);
}

Here, it doesn't check that _tokens and _amounts have the same length. If they don't, then _leftSumColls might process them incorrectly. If _leftSumColls assumes they are the same length, but they aren't, this could lead to out-of-bounds access or incorrect summing. For example, if _tokens is longer than _amounts, then when iterating, some tokens would have no corresponding amount. Depending on how _leftSumColls handles it, this could cause underflow in SafeMath (if accessing _amounts[i] where i >= _amounts.length) or other errors. So this is a possible vulnerability because the function doesn't validate that _tokens and _amounts arrays are of the same length. Since receiveCollateral can be called by BorrowerOperations or DefaultPool, which are supposed to be trusted, but if they pass incorrect arrays, it would break the accounting in ActivePool. Therefore, the ActivePool should validate that the lengths match in receiveCollateral. The absence of this check is a vulnerability.

Another thing: in the addCollateralType function, when a new collateral is added, it's pushed to poolColl.tokens and poolColl.amounts. However, there's no check for duplicates. So if the same collateral is added multiple times, it would appear multiple times in the tokens array, leading to incorrect accounting. The whitelist is supposed to manage this, but if the whitelist allows adding the same collateral multiple times, this function would push duplicates. So the addCollateralType function should check if the collateral already exists in poolColl.tokens. Otherwise, duplicates could lead to multiple entries for the same collateral, which would cause functions like getAllCollateral to return incorrect data and other functions to process the same collateral multiple times. So this is another vulnerability: allowing duplicate collateral entries.

Also, in the getCollateral function, it uses whitelist.getIndex(_collateral). If the collateral isn't in the whitelist, getIndex might revert or return an incorrect index. But since addCollateralType is called via the whitelist (only whitelist can call addCollateralType), then poolColl.tokens should only contain whitelisted collaterals. However, if a collateral is removed from the whitelist, but still exists in poolColl.tokens, then getIndex might fail. But the code for the whitelist isn't provided, so it's hard to say. However, the getCollateral function relies on the whitelist's getIndex, which could revert if the collateral is not found, leading to a DoS. For example, if a collateral is removed from the whitelist but is still present in poolColl.tokens, then trying to getCollateral for that token would call getIndex, which might revert. So if the whitelist's getIndex function reverts when the collateral is not found, then any function that calls getCollateral (like getCollateralVC) would revert when the collateral is not in the whitelist. But since the ActivePool should only contain collaterals that are in the whitelist (since addCollateralType is called by the whitelist), this might not be an issue. However, if the whitelist can remove collaterals, and the ActivePool still has a balance for a removed collateral, then functions accessing it would revert. That's a potential DoS. But again, since the whitelist is supposed to manage this, maybe it's handled. However, in the current code, there's no handling for that scenario.

Another possible issue is in the sendCollateralsUnwrap function. It loops through each token and checks if it's wrapped. If it is, it calls unwrapFor. But for each token, it's possible that the token is not actually a wrapped asset (i.e., isWrapped returns false), but the code still proceeds to call IWAsset's unwrapFor. However, since whitelist.isWrapped is checked, which presumably returns true only for wrapped assets, this should be safe. But if the whitelist returns an incorrect value, then it could call unwrapFor on a non-wrapped token, which would cause a revert. However, the whitelist is a trusted contract, so this is more of a dependency issue.

Let me summarize the possible vulnerabilities:

1. **Lack of Input Validation in receiveCollateral**: The receiveCollateral function does not check if the _tokens and _amounts arrays have the same length. If a trusted contract (BorrowerOperations or DefaultPool) passes arrays of different lengths, this could lead to incorrect accounting or runtime errors in _leftSumColls.

2. **Duplicate Collateral Entries**: The addCollateralType function does not check if a collateral type already exists in poolColl.tokens. This could allow duplicate entries if the whitelist calls addCollateralType multiple times for the same collateral, leading to incorrect accounting and potential overflows or underflows when managing amounts.

3. **Potential DoS if Collateral Removed from Whitelist**: If a collateral is removed from the whitelist but still exists in ActivePool's poolColl.tokens, any function that calls getCollateral (which uses whitelist.getIndex) could revert if the whitelist's getIndex function reverts for non-existent collaterals. This could cause Denial-of-Service for functions relying on getCollateral.

4. **Unchecked Return Value from IWAsset.unwrapFor**: The sendCollateralsUnwrap and sendSingleCollateralUnwrap functions assume that the unwrapFor call is successful. However, if the underlying unwrapFor function fails (e.g., due to insufficient balance or other reasons), the transaction would revert. However, since the code uses SafeERC20's safeTransfer and other checks, this is more of an expected behavior than a vulnerability.

Wait, the code for sendCollateralsUnwrap uses IWAsset's unwrapFor, but doesn't check if the call was successful. Since unwrapFor is an external call, if it returns a boolean but the code doesn't check it, that could lead to failed unwraps going unnoticed. But looking at the code:

In sendCollateralsUnwrap, for each token, if it's wrapped, it does:

IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);

If unwrapFor is implemented with a function that returns a boolean (success/failure), then not checking the return value could mean that even if the unwrap fails, the code proceeds. However, in Solidity, when you call a function of an interface without specifying how to handle the return value, it will revert only if the function is marked as returning a value and it's not handled. Since the code here uses IWAsset, which is an interface, if the actual unwrapFor function has a return value (like a bool), then this call would revert because Solidity expects the return data to be present. However, if the unwrapFor function doesn't return a value, then it's okay. So the code here assumes that unwrapFor doesn't return a value, which is possible. But if the IWAsset's unwrapFor is supposed to return a bool (like ERC20's transfer), then this code would have a problem. Since the interface isn't provided, we can't be sure. The import is from ""./Interfaces/IWAsset.sol"", but we don't have that code. If the unwrapFor function is supposed to return a bool, then not checking it could lead to silent failures. For example, if unwrapping fails but the code proceeds, leading to loss of funds. Therefore, if the IWAsset's unwrapFor returns a success bool, then this code is vulnerable because it doesn't check the return value, leading to possible silent failures. This is similar to the common ERC20 transfer issue where the return value isn't checked. However, the code uses SafeERC20's safeTransfer which does check the return value. But for unwrapFor, since it's a custom function, the code may not check it. So if unwrapFor returns a bool, this is a vulnerability. If not, then it's not. Since the code isn't provided, but given that it's an interface, this is a potential vulnerability.

Another possible issue: In sendCollateralsUnwrap, after unwrapping, it's possible that the unwrapped token is not the same as the collateral. For example, if a wrapped token's unwrapFor function sends a different token, but the ActivePool's accounting is not updated. However, this would depend on the implementation of IWAsset. Assuming that unwrapping a wrapped token gives the underlying collateral, which is tracked by the ActivePool, but the ActivePool might not be tracking the unwrapped collateral. Wait, but when unwrapping, the wrapped token is sent to the ActivePool, and then unwrapped, which would burn the wrapped token and release the underlying. But in this code, the ActivePool is sending the wrapped token via _sendCollateral, but in sendCollateralsUnwrap, if the token is wrapped, it calls unwrapFor, which presumably converts the wrapped token to the underlying and sends it to _to. However, the ActivePool's balance for the wrapped token is reduced by _amounts[i], but if unwrapping requires that the ActivePool holds the wrapped tokens, then this is okay. But how does the unwrapFor function work? If the ActivePool is the one holding the wrapped tokens, then when it calls unwrapFor, it would need to have the tokens. But in the code, the _sendCollateral is not called for wrapped tokens in sendCollateralsUnwrap; instead, the unwrapFor is called directly. Wait, looking at sendCollateralsUnwrap:

In the loop:

if (whitelist.isWrapped(_tokens[i])) {
    // unwrapFor is called here
    IWAsset(_tokens[i]).unwrapFor(_from, _to, _amounts[i]);
} else {
    _sendCollateral(_to, _tokens[i], _amounts[i]); 
}

But in this case, the ActivePool must hold the wrapped tokens. But the code doesn't subtract the wrapped tokens from poolColl.amounts. Wait, that's a problem! Because when the ActivePool sends a wrapped token via unwrapFor, it should deduct the amount from its own balance. However, in this code path, the code does not call _sendCollateral for wrapped tokens. Instead, it directly calls unwrapFor. So the ActivePool's balance for the wrapped token is not reduced, but the unwrapFor is transferring the wrapped token out. This is incorrect. Because the ActivePool's accounting (poolColl.amounts) for the wrapped token would still reflect that it has the tokens, even though they've been unwrapped and sent out. This leads to an inconsistency in the accounting.

Wait, let me clarify. The sendCollateralsUnwrap function is supposed to send collateral, either by transferring it directly or unwrapping it. For wrapped tokens, the code calls unwrapFor, which presumably burns the wrapped tokens and releases the underlying. But in the code above, when the token is wrapped, the code does not call _sendCollateral. So the ActivePool's balance for the wrapped token is not reduced. Therefore, the ActivePool's records would show that it still holds the wrapped tokens, but in reality, they have been unwrapped and sent out. This is a critical accounting error. The ActivePool's poolColl.amounts for the wrapped token should be decreased by _amounts[i], but it's not happening here. 

For example, suppose the ActivePool has 100 WETH (wrapped ETH). When sendCollateralsUnwrap is called with WETH, the code calls unwrapFor, which converts WETH to ETH and sends it to _to. However, the ActivePool's WETH balance (poolColl.amounts[index]) is not reduced. So the ActivePool still thinks it has 100 WETH, but actually, some of it has been unwrapped and sent out. This would lead to an overcounting of the wrapped tokens in the ActivePool, allowing further unauthorized transfers or incorrect accounting.

This is a major vulnerability. The code for sendCollateralsUnwrap and sendSingleCollateralUnwrap does not deduct the wrapped token amount from the ActivePool's balances when unwrapping. So the ActivePool's internal accounting (poolColl.amounts) is not updated, leading to discrepancies between the actual token balance and the recorded balance.

So that's another critical vulnerability. The ActivePool's balances for wrapped tokens are not being updated when they are unwrapped and sent out, leading to incorrect accounting and possible fund loss or duplication.

Another thing to check: the _sendCollateral function subtracts the amount from poolColl.amounts and transfers it. But in the case of unwrapping, this subtraction is not done. So the ActivePool's records for wrapped tokens are incorrect.

So to recap, when sending a wrapped token via sendCollateralsUnwrap, the code calls unwrapFor but does not subtract the amount from the ActivePool's balance. Therefore, the ActivePool's poolColl.amounts for that wrapped token remains the same, even though the tokens have been unwrapped and sent out. This means that the ActivePool's accounting is wrong, and subsequent operations may use incorrect balances, leading to potential theft or loss of funds.

That's a severe vulnerability. For example, if the ActivePool has 100 WETH, and someone calls sendCollateralsUnwrap to send 50 WETH, unwrapping to ETH and sending to _to. The code would unwrap 50 WETH to ETH, but the ActivePool's WETH balance would still be 100. Then, the ActivePool could be used to send another 100 WETH, even though only 50 were actually present (since 50 were unwrapped and sent out). This would allow draining of the contract.

Therefore, the main vulnerabilities I can identify are:

1. **Incorrect Accounting for Unwrapped Collateral**: When unwrapping wrapped tokens, the ActivePool's internal balances (poolColl.amounts) are not updated, leading to discrepancies between actual and recorded balances.

2. **Lack of Input Validation in receiveCollateral**: Missing check for equal array lengths of _tokens and _amounts, leading to potential incorrect accounting if trusted contracts pass invalid data.

3. **Duplicate Collateral Entries**: The addCollateralType function allows adding the same collateral multiple times, leading to duplicated entries and accounting errors.

4. **Unchecked Return Value for unwrapFor Calls**: If IWAsset's unwrapFor returns a success boolean and it's not checked, failed unwraps could go unnoticed.

5. **Potential DoS via Removed Collateral**: If collaterals are removed from the whitelist but remain in the ActivePool, functions using getCollateral could revert.

Out of these, the first one (incorrect accounting when unwrapping) is the most critical. The others vary in severity but are significant.","```
None.
```",0.0
BorrowerOperations.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";

/** 
 * BorrowerOperations is the contract that handles most of external facing trove activities that 
 * a user would make with their own trove, like opening, closing, adjusting, etc. 
 */

contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    // --- Connected contract declarations ---

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    // A doubly linked list of Troves, sorted by their collateral ratios
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    /* --- Variable container structs  ---

    Used to hold, return and assign variables inside a function, in order to avoid the error:
    ""CompilerError: Stack too deep"". */
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    // --- Dependency setters ---

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        // This makes impossible to open a trove with zero withdrawn YUSD
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    // --- Borrower Trove Operations ---


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        // transfer collateral into ActivePool
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    // amounts should be a uint array giving the amount of each collateral
    // to be transferred in in order of the current whitelist
    // Should be called _after_ collateral has been already sent to the active pool
    // Should confirm _colls, is valid collateral prior to calling this
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        // For every collateral type in, calculate the VC and get the variable fee
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            // when not in recovery mode, add in the 0.5% fee
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, // here it is just VC in, which is always larger than YUSD amount
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        // Add in variable fee. Always present, even in recovery mode.
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        // Adds total fees to netDebt
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee

        _requireAtLeastMinNetDebt(vars.netDebt);
        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.
        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase
            _requireNewTCRisAboveCCR(newTCR);
        }

        // Set the trove struct's properties
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        // Move the YUSD gas compensation to the Gas Pool
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    // add collateral to trove. Calls _adjustTrove with correct params. 
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        // check that all _collsIn collateral types are in the whitelist and no duplicates
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. 
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. 
    // Calls _adjustTrove with correct params. 
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        // check that all _collsIn collateral types are in the whitelist
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut
        _requireNoDuplicateColls(_collsOut);

        // pull in deposit collateral
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    /*
     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.
     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in
     *
     * Should be called after the collsIn has been sent to ActivePool
     */
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.
                params._maxFeePercentage
            );
            // passed in max fee minus actual fee percent applied so far
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee
        }


        // get current portfolio in trove
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        // current VC based on current portfolio and latest prices
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        // get new portfolio in trove after changes. Will error if invalid changes:
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        // new VC based on new portfolio and latest prices
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, // with variableYUSDFee already added. 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        // Check the adjustment satisfies all conditions for the current system mode
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        // Re-insert trove in to the sorted list
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        // Use the unmodified _YUSDChange here, as we don't send the fee to the user
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        // transfer withdrawn collateral to msg.sender from ActivePool
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    /** 
     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the 
     * collateral to the owner, and repaying the debt.
     */
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); // should get the latest VC
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        // Send the collateral back to the user
        // Also sends the rewards
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    /**
     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode
     */
    function claimCollateral() external override {
        // send collateral from CollSurplus Pool to owner
        collSurplusPool.claimColl(msg.sender);
    }

    // --- Helper functions ---

    /** 
     * Gets the variable deposit fee from the whitelist calculation. Multiplies the 
     * fee by the vc of the collateral.
     */
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        // active pool total VC at current state.
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        // active pool total VC post adding and removing all collaterals
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            // VC value of collateral of this type inputted
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            // total value in VC of this collateral in active pool (post adding input)
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); // cap at 1%
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    // Transfer in collateral and send to ActivePool
    // (where collateral is held)
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    /**
     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.
     */
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        // Send fee to sYETI contract
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    // Update trove's coll and debt based on whether they increase or decrease
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { // if debt increase, increase by both amounts
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { // otherwise increase by opposite subtraction
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made
    // this function will error if trying to deposit a collateral that is not in the whitelist
    // or trying to withdraw more collateral of any type that is not in the trove
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        // Initial Colls + Input Colls
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    // Moves the YUSD around based on whether it is an increase or decrease in debt.
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    // Burn the specified amount of YUSD from _account and decreases the total active debt
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    // --- 'Require' wrapper functions ---

    /* Checks that:
     * 1. _colls contains no duplicates
     * 2. All elements of _colls are active collateral on the whitelist
     */
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        /*
         *In Recovery Mode, only allow:
         *
         * - Pure collateral top-up
         * - Pure debt repayment
         * - Collateral top-up with debt repayment
         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).
         *
         * In Normal Mode, ensure:
         *
         * - The new ICR is above MCR
         * - The adjustment won't pull the TCR below CCR
         */
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            // if Normal Mode
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    // checks lengths are all good and that all passed in routers are valid routers
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    // requires that avax indices are in order
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    // --- ICR and TCR getters ---

    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",9859.0,1116.0,"[M-05] Reentrancy in contracts/BorrowerOperations.sol

Submitted by heiho1, also found by jayjonah8
Impact

There are several potential re-entrant functions in contracts/BorrowerOperations.sol:
=> Function addColl() on line 346 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _adjustTrove() which potentially impacts user debt, collateral top-ups or withdrawals.
Same applies to
-- withdrawColl() on line 373 -- withdrawYUSD() on line 389 -- repayYUSD() on line 406 -- adjustTrove() on line 420
=> Function openTrove() on line 207 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes _openTroveInternal() which potentially impacts trove creation, YUSD withdrawals and YUSD gas compensation.
=> Function closeTrove() on line 628 is potentially re-entrant as it is external but has no re-entrancy guard declared. This function invokes troveManagerCached.r",1.0,"pragma solidity 0.6.11;

import ""./Interfaces/IBorrowerOperations.sol"";
import ""./Interfaces/ITroveManager.sol"";
import ""./Interfaces/IYUSDToken.sol"";
import ""./Interfaces/ICollSurplusPool.sol"";
import ""./Interfaces/ISortedTroves.sol"";
import ""./Interfaces/ISYETI.sol"";
import ""./Interfaces/IWhitelist.sol"";
import ""./Interfaces/IYetiRouter.sol"";
import ""./Dependencies/LiquityBase.sol"";
import ""./Dependencies/Ownable.sol"";
import ""./Dependencies/CheckContract.sol"";
import ""./Interfaces/IERC20.sol"";



contract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations {
    string public constant NAME = ""BorrowerOperations"";

    

    ITroveManager public troveManager;

    address stabilityPoolAddress;

    address gasPoolAddress;

    ICollSurplusPool collSurplusPool;

    ISYETI public sYETI;
    address public sYETIAddress;

    IYUSDToken public yusdToken;

    uint public constant BOOTSTRAP_PERIOD = 14 days;
    uint deploymentTime;

    
    ISortedTroves public sortedTroves;

    struct CollateralData {
        address collateral;
        uint256 amount;
    }

    struct DepositFeeCalc {
        uint256 collateralYUSDFee;
        uint256 activePoolCollateralVC;
        uint256 collateralInputVC;
        uint256 activePoolTotalVC;
        address token;
    }

    
    struct AdjustTrove_Params {
        address[] _collsIn;
        uint256[] _amountsIn;
        address[] _collsOut;
        uint256[] _amountsOut;
        uint256 _YUSDChange;
        bool _isDebtIncrease;
        address _upperHint;
        address _lowerHint;
        uint256 _maxFeePercentage;
    }

    struct LocalVariables_adjustTrove {
        uint256 netDebtChange;
        bool isCollIncrease;
        uint256 collChange;
        uint256 currVC;
        uint256 newVC;
        uint256 debt;
        address[] currAssets;
        uint256[] currAmounts;
        address[] newAssets;
        uint256[] newAmounts;
        uint256 oldICR;
        uint256 newICR;
        uint256 newTCR;
        uint256 YUSDFee;
        uint256 variableYUSDFee;
        uint256 newDebt;
        uint256 VCin;
        uint256 VCout;
        uint256 maxFeePercentageFactor;
    }

    struct LocalVariables_openTrove {
        address[] collaterals;
        uint256[] prices;
        uint256 YUSDFee;
        uint256 netDebt;
        uint256 compositeDebt;
        uint256 ICR;
        uint256 arrayIndex;
        address collAddress;
        uint256 VC;
    }

    struct openTroveRouter_params {
        uint[] finalRoutedAmounts;
        uint i;
        uint j;
        uint avaxSent;
    }

    struct ContractsCache {
        ITroveManager troveManager;
        IActivePool activePool;
        IYUSDToken yusdToken;
    }

    enum BorrowerOperation {
        openTrove,
        closeTrove,
        adjustTrove
    }

    event TroveManagerAddressChanged(address _newTroveManagerAddress);
    event ActivePoolAddressChanged(address _activePoolAddress);
    event DefaultPoolAddressChanged(address _defaultPoolAddress);
    event StabilityPoolAddressChanged(address _stabilityPoolAddress);
    event GasPoolAddressChanged(address _gasPoolAddress);
    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);
    event PriceFeedAddressChanged(address _newPriceFeedAddress);
    event SortedTrovesAddressChanged(address _sortedTrovesAddress);
    event YUSDTokenAddressChanged(address _yusdTokenAddress);
    event SYETIAddressChanged(address _sYETIAddress);

    event TroveCreated(address indexed _borrower, uint256 arrayIndex);
    event TroveUpdated(
        address indexed _borrower,
        uint256 _debt,
        address[] _tokens,
        uint256[] _amounts,
        BorrowerOperation operation
    );
    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);

    

    function setAddresses(
        address _troveManagerAddress,
        address _activePoolAddress,
        address _defaultPoolAddress,
        address _stabilityPoolAddress,
        address _gasPoolAddress,
        address _collSurplusPoolAddress,
        address _sortedTrovesAddress,
        address _yusdTokenAddress,
        address _sYETIAddress,
        address _whitelistAddress
    ) external override onlyOwner {
        
        assert(MIN_NET_DEBT > 0);

        deploymentTime = block.timestamp;

        checkContract(_troveManagerAddress);
        checkContract(_activePoolAddress);
        checkContract(_defaultPoolAddress);
        checkContract(_stabilityPoolAddress);
        checkContract(_gasPoolAddress);
        checkContract(_collSurplusPoolAddress);
        checkContract(_sortedTrovesAddress);
        checkContract(_yusdTokenAddress);
        checkContract(_sYETIAddress);
        checkContract(_whitelistAddress);

        troveManager = ITroveManager(_troveManagerAddress);
        activePool = IActivePool(_activePoolAddress);
        defaultPool = IDefaultPool(_defaultPoolAddress);
        whitelist = IWhitelist(_whitelistAddress);
        stabilityPoolAddress = _stabilityPoolAddress;
        gasPoolAddress = _gasPoolAddress;
        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);
        sortedTroves = ISortedTroves(_sortedTrovesAddress);
        yusdToken = IYUSDToken(_yusdTokenAddress);
        sYETIAddress = _sYETIAddress;

        emit TroveManagerAddressChanged(_troveManagerAddress);
        emit ActivePoolAddressChanged(_activePoolAddress);
        emit DefaultPoolAddressChanged(_defaultPoolAddress);
        emit StabilityPoolAddressChanged(_stabilityPoolAddress);
        emit GasPoolAddressChanged(_gasPoolAddress);
        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);
        emit SortedTrovesAddressChanged(_sortedTrovesAddress);
        emit YUSDTokenAddressChanged(_yusdTokenAddress);
        emit SYETIAddressChanged(_sYETIAddress);

        _renounceOwnership();
    }

    


    function openTrove(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) external override {
        require(_colls.length == _amounts.length, ""BOps: colls and amounts length mismatch"");
        require(_colls.length != 0, ""BOps: No input collateral"");
        _requireValidDepositCollateral(_colls);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts),
            ""BOps: Transfer collateral into ActivePool failed""
        );

        _openTroveInternal(
            msg.sender,
            _maxFeePercentage,
            _YUSDAmount,
            _upperHint,
            _lowerHint,
            _colls,
            _amounts
        );
    }

    
    
    
    
    function _openTroveInternal(
        address _troveOwner,
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal {
        LocalVariables_openTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);

        _requireValidMaxFeePercentage(_maxFeePercentage, isRecoveryMode);
        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);

        vars.YUSDFee;

        vars.netDebt = _YUSDAmount;

        
        vars.VC = _getVC(_colls, _amounts);

        if (!isRecoveryMode) {
            
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                _YUSDAmount,
                vars.VC, 
                _maxFeePercentage
            );
            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));
        }


        
        vars.YUSDFee = vars.YUSDFee.add(
            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)
        );

        
        vars.netDebt = vars.netDebt.add(vars.YUSDFee); 

        _requireAtLeastMinNetDebt(vars.netDebt);
        
        
        vars.compositeDebt = _getCompositeDebt(vars.netDebt);
        assert(vars.compositeDebt > 0);

        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);
        if (isRecoveryMode) {
            _requireICRisAboveCCR(vars.ICR);
        } else {
            _requireICRisAboveMCR(vars.ICR);
            uint256 newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); 
            _requireNewTCRisAboveCCR(newTCR);
        }

        
        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);

        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);
        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);

        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);

        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);

        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);
        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);
        emit TroveCreated(_troveOwner, vars.arrayIndex);

        contractsCache.activePool.receiveCollateral(_colls, _amounts);

        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            _troveOwner,
            _YUSDAmount,
            vars.netDebt
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            gasPoolAddress,
            YUSD_GAS_COMPENSATION,
            YUSD_GAS_COMPENSATION
        );

        emit TroveUpdated(
            _troveOwner,
            vars.compositeDebt,
            _colls,
            _amounts,
            BorrowerOperation.openTrove
        );
        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);
    }


    
    function addColl(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address _upperHint,
        address _lowerHint, 
        uint256 _maxFeePercentage
    ) external override {
        AdjustTrove_Params memory params;
        params._collsIn = _collsIn;
        params._amountsIn = _amountsIn;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._maxFeePercentage = _maxFeePercentage;

        
        _requireValidDepositCollateral(params._collsIn);
        require(_collsIn.length == _amountsIn.length);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );
        _adjustTrove(params);
    }

    
    function withdrawColl(
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._collsOut = _collsOut;
        params._amountsOut = _amountsOut;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        _adjustTrove(params);
    }

    
    
    function withdrawYUSD(
        uint256 _maxFeePercentage,
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._maxFeePercentage = _maxFeePercentage;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = true;
        _adjustTrove(params);
    }

    
    
    function repayYUSD(
        uint256 _YUSDAmount,
        address _upperHint,
        address _lowerHint
    ) external override {
        AdjustTrove_Params memory params;
        params._YUSDChange = _YUSDAmount;
        params._upperHint = _upperHint;
        params._lowerHint = _lowerHint;
        params._isDebtIncrease = false;
        _adjustTrove(params);
    }

    
    function adjustTrove(
        address[] memory _collsIn,
        uint256[] memory _amountsIn,
        address[] memory _collsOut,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        address _upperHint,
        address _lowerHint,
        uint256 _maxFeePercentage
    ) external override {

        
        _requireValidDepositCollateral(_collsIn);
        require(_collsIn.length == _amountsIn.length);
        require(_collsOut.length == _amountsOut.length);
        _requireNoOverlapColls(_collsIn, _collsOut); 
        _requireNoDuplicateColls(_collsOut);

        
        require(
            _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn),
            ""BOps: Failed to transfer collateral into active pool""
        );

        AdjustTrove_Params memory params = AdjustTrove_Params(
            _collsIn,
            _amountsIn,
            _collsOut,
            _amountsOut,
            _YUSDChange,
            _isDebtIncrease,
            _upperHint,
            _lowerHint,
            _maxFeePercentage
        );

        _adjustTrove(params);
    }


    
    function _adjustTrove(AdjustTrove_Params memory params) internal {
        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);
        LocalVariables_adjustTrove memory vars;

        bool isRecoveryMode = _checkRecoveryMode();

        if (params._isDebtIncrease) {
            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);
            _requireNonZeroDebtChange(params._YUSDChange);
        }

        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);
        _requireTroveisActive(contractsCache.troveManager, msg.sender);

        contractsCache.troveManager.applyPendingRewards(msg.sender);
        vars.netDebtChange = params._YUSDChange;

        vars.VCin = _getVC(params._collsIn, params._amountsIn);
        vars.VCout = _getVC(params._collsOut, params._amountsOut);

        if (params._isDebtIncrease) {
            vars.maxFeePercentageFactor = _max(vars.VCin, params._YUSDChange);
        } else {
            vars.maxFeePercentageFactor = vars.VCin;
        }
        

        
        if (params._isDebtIncrease && !isRecoveryMode) {
            vars.YUSDFee = _triggerBorrowingFee(
                contractsCache.troveManager,
                contractsCache.yusdToken,
                params._YUSDChange,
                vars.maxFeePercentageFactor, 
                params._maxFeePercentage
            );
            
            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); 
            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); 
        }


        
        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);
        
        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);

        
        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(
            vars.currAssets,
            vars.currAmounts,
            params._collsIn,
            params._amountsIn,
            params._collsOut,
            params._amountsOut
        );
        
        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);

        vars.isCollIncrease = vars.newVC > vars.currVC;
        vars.collChange = 0;
        if (vars.isCollIncrease) {
            vars.collChange = (vars.newVC).sub(vars.currVC);
        } else {
            vars.collChange = (vars.currVC).sub(vars.newVC);
        }

        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);

        vars.variableYUSDFee = _getTotalVariableDepositFee(
                params._collsIn,
                params._amountsIn,
                vars.VCin,
                vars.VCout,
                vars.maxFeePercentageFactor,
                params._maxFeePercentage,
                contractsCache
        );

        
        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);

        vars.debt = vars.debt.add(vars.variableYUSDFee); 

        vars.newICR = _getNewICRFromTroveChange(vars.newVC,
            vars.debt, 
            vars.netDebtChange,
            params._isDebtIncrease 
        );

        
        _requireValidAdjustmentInCurrentMode(
            isRecoveryMode,
            params._amountsOut,
            params._isDebtIncrease,
            vars
        );

        
        if (!params._isDebtIncrease && params._YUSDChange > 0) {
            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));
            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);
            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);
        }

        if (params._collsIn.length > 0) {
            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);
        }

        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(
            contractsCache.troveManager,
            msg.sender,
            vars.newAssets,
            vars.newAmounts,
            vars.newVC,
            vars.netDebtChange,
            params._isDebtIncrease, 
            vars.variableYUSDFee
        );

        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);

        
        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);

        emit TroveUpdated(
            msg.sender,
            vars.newDebt,
            vars.newAssets,
            vars.newAmounts,
            BorrowerOperation.adjustTrove
        );
        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);

        
        _moveYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
            msg.sender,
            params._YUSDChange,
            params._isDebtIncrease,
            vars.netDebtChange
        );

        
        _withdrawYUSD(
            contractsCache.activePool,
            contractsCache.yusdToken,
                msg.sender,
            0,
            vars.variableYUSDFee
        );

        
        activePool.sendCollateralsUnwrap(msg.sender, params._collsOut, params._amountsOut, true);
    }

    
    function closeTrove() external override {
        ITroveManager troveManagerCached = troveManager;
        IActivePool activePoolCached = activePool;
        IYUSDToken yusdTokenCached = yusdToken;

        _requireTroveisActive(troveManagerCached, msg.sender);
        _requireNotInRecoveryMode();

        troveManagerCached.applyPendingRewards(msg.sender);

        uint256 troveVC = troveManagerCached.getTroveVC(msg.sender); 
        (address[] memory colls, uint256[] memory amounts) = troveManagerCached.getTroveColls(
            msg.sender
        );
        uint256 debt = troveManagerCached.getTroveDebt(msg.sender);

        _requireSufficientYUSDBalance(yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));

        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);
        _requireNewTCRisAboveCCR(newTCR);

        troveManagerCached.removeStake(msg.sender);
        troveManagerCached.closeTrove(msg.sender);

        address[] memory finalColls;
        uint256[] memory finalAmounts;

        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);

        
        _repayYUSD(activePoolCached, yusdTokenCached, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));
        _repayYUSD(activePoolCached, yusdTokenCached, gasPoolAddress, YUSD_GAS_COMPENSATION);

        
        
        activePoolCached.sendCollateralsUnwrap(msg.sender, colls, amounts, true);
    }

    
    function claimCollateral() external override {
        
        collSurplusPool.claimColl(msg.sender);
    }

    

    
    function _getTotalVariableDepositFee(
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        uint256 _VCin,
        uint256 _VCout,
        uint256 _maxFeePercentageFactor, 
        uint256 _maxFeePercentage,
        ContractsCache memory _contractsCache
    ) internal returns (uint256 YUSDFee) {
        if (_VCin == 0) {
            return 0;
        }
        DepositFeeCalc memory vars;
        
        vars.activePoolTotalVC = _contractsCache.activePool.getVC();
        
        uint256 activePoolVCPost = vars.activePoolTotalVC.add(_VCin).sub(_VCout);
        uint256 whitelistFee;

        for (uint256 i = 0; i < _tokensIn.length; i++) {
            vars.token = _tokensIn[i];
            
            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);

            
            vars.activePoolCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token);

            
            whitelistFee = 
                    whitelist.getFeeAndUpdate(
                        vars.token,
                        vars.collateralInputVC,
                        vars.activePoolCollateralVC, 
                        vars.activePoolTotalVC,
                        activePoolVCPost
                    );
            if (_isBeforeFeeBootstrapPeriod()) {
                whitelistFee = _min(whitelistFee, 1e16); 
            } 
            vars.collateralYUSDFee = vars.collateralInputVC
                .mul(whitelistFee).div(1e18);

            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);
        }
        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);
        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);
        return YUSDFee;
    }

    
    
    function _transferCollateralsIntoActivePool(
        address _from,
        address[] memory _colls,
        uint256[] memory _amounts
    ) internal returns (bool) {
        uint256 len = _amounts.length;
        for (uint256 i = 0; i < len; i++) {
            address collAddress = _colls[i];
            uint256 amount = _amounts[i];
            IERC20 coll = IERC20(collAddress);

            bool transferredToActivePool = coll.transferFrom(_from, address(activePool), amount);
            if (!transferredToActivePool) {
                return false;
            }
        }
        return true;
    }

    
    function _triggerBorrowingFee(
        ITroveManager _troveManager,
        IYUSDToken _yusdToken,
        uint256 _YUSDAmount,
        uint256 _maxFeePercentageFactor,
        uint256 _maxFeePercentage
    ) internal returns (uint256) {
        _troveManager.decayBaseRateFromBorrowing(); 
        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);

        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);

        
        _yusdToken.mint(sYETIAddress, YUSDFee);
        return YUSDFee;
    }

    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {
        
        _yusdToken.mint(sYETIAddress, _YUSDFee);
    }

    
    function _updateTroveFromAdjustment(
        ITroveManager _troveManager,
        address _borrower,
        address[] memory _finalColls,
        uint256[] memory _finalAmounts,
        uint256 _newVC,
        uint256 _debtChange,
        bool _isDebtIncrease, 
        uint256 _variableYUSDFee
    ) internal returns (uint256, uint256) {
        uint256 newDebt;
        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);
        if (_isDebtIncrease) { 
           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));
        } else {
            if (_debtChange > _variableYUSDFee) { 
                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange.sub(_variableYUSDFee));
            } else { 
                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee.sub(_debtChange));
            }
        }

        return (_newVC, newDebt);
    }

    
    
    
    function _getNewPortfolio(
        address[] memory _initialTokens,
        uint256[] memory _initialAmounts,
        address[] memory _tokensIn,
        uint256[] memory _amountsIn,
        address[] memory _tokensOut,
        uint256[] memory _amountsOut
    ) internal view returns (address[] memory finalColls, uint256[] memory finalAmounts) {
        _requireValidDepositCollateral(_tokensIn);

        
        newColls memory cumulativeIn = _sumColls(
            _initialTokens,
            _initialAmounts,
            _tokensIn,
            _amountsIn
        );

        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);
        return (newPortfolio.tokens, newPortfolio.amounts);
    }

    
    function _moveYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _YUSDChange,
        bool _isDebtIncrease,
        uint256 _netDebtChange
    ) internal {
        if (_isDebtIncrease) {
            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);
        } else {
            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);
        }
    }

    
    function _withdrawYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSDAmount,
        uint256 _netDebtIncrease
    ) internal {
        _activePool.increaseYUSDDebt(_netDebtIncrease);
        _yusdToken.mint(_account, _YUSDAmount);
    }

    
    function _repayYUSD(
        IActivePool _activePool,
        IYUSDToken _yusdToken,
        address _account,
        uint256 _YUSD
    ) internal {
        _activePool.decreaseYUSDDebt(_YUSD);
        _yusdToken.burn(_account, _YUSD);
    }

    

    
    function _requireValidDepositCollateral(address[] memory _colls) internal view {
        _requireNoDuplicateColls(_colls);
        for (uint256 i = 0; i < _colls.length; i++) {
            require(whitelist.getIsActive(_colls[i]), ""BOps: Collateral not in whitelist"");
        }
    }

    function _requireNonZeroAdjustment(
        uint256[] memory _amountsIn,
        uint256[] memory _amountsOut,
        uint256 _YUSDChange
    ) internal pure {
        require(
            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,
            ""BorrowerOps: There must be either a collateral change or a debt change""
        );
    }

    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {
        for (uint256 i = 0; i < arr.length; i++) {
            if (arr[i] != 0) {
                return true;
            }
        }
        return false;
    }

    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {
        return block.timestamp < deploymentTime.add(BOOTSTRAP_PERIOD);
    }

    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status == 1, ""BorrowerOps: Trove does not exist or is closed"");
    }

    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {
        uint256 status = _troveManager.getTroveStatus(_borrower);
        require(status != 1, ""BorrowerOps: Trove is active"");
    }

    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {
        require(_YUSDChange > 0, ""BorrowerOps: Debt increase requires non-zero debtChange"");
    }

    function _requireNoOverlapColls(address[] memory _colls1, address[] memory _colls2)
        internal
        pure
    {
        for (uint256 i = 0; i < _colls1.length; i++) {
            for (uint256 j = 0; j < _colls2.length; j++) {
                require(_colls1[i] != _colls2[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }


    function _requireNoDuplicateColls(address[] memory _colls) internal pure {
        for (uint256 i = 0; i < _colls.length; i++) {
            for (uint256 j = i + 1; j < _colls.length; j++) {
                require(_colls[i] != _colls[j], ""BorrowerOps: Collateral passed in overlaps"");
            }
        }
    }

    function _requireNotInRecoveryMode() internal view {
        require(!_checkRecoveryMode(), ""BorrowerOps: Operation not permitted during Recovery Mode"");
    }

    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {
        require(
            !_arrayIsNonzero(_amountOut),
            ""BorrowerOps: Collateral withdrawal not permitted Recovery Mode""
        );
    }

    function _requireValidAdjustmentInCurrentMode(
        bool _isRecoveryMode,
        uint256[] memory _collWithdrawal,
        bool _isDebtIncrease,
        LocalVariables_adjustTrove memory _vars
    ) internal view {
        
        if (_isRecoveryMode) {
            _requireNoCollWithdrawal(_collWithdrawal);
            if (_isDebtIncrease) {
                _requireICRisAboveCCR(_vars.newICR);
                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);
            }
        } else {
            
            _requireICRisAboveMCR(_vars.newICR);
            _vars.newTCR = _getNewTCRFromTroveChange(
                _vars.collChange,
                _vars.isCollIncrease,
                _vars.netDebtChange,
                _isDebtIncrease
            );
            _requireNewTCRisAboveCCR(_vars.newTCR);
        }
    }

    function _requireICRisAboveMCR(uint256 _newICR) internal pure {
        require(
            _newICR >= MCR,
            ""BorrowerOps: An operation that would result in ICR < MCR is not permitted""
        );
    }

    function _requireICRisAboveCCR(uint256 _newICR) internal pure {
        require(_newICR >= CCR, ""BorrowerOps: Operation must leave trove with ICR >= CCR"");
    }

    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {
        require(
            _newICR >= _oldICR,
            ""BorrowerOps: Cannot decrease your Trove's ICR in Recovery Mode""
        );
    }

    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {
        require(
            _newTCR >= CCR,
            ""BorrowerOps: An operation that would result in TCR < CCR is not permitted""
        );
    }

    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {
        require(
            _netDebt >= MIN_NET_DEBT,
            ""BorrowerOps: Trove's net debt must be greater than minimum""
        );
    }

    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {
        require(
            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),
            ""BorrowerOps: Amount repaid must not be larger than the Trove's debt""
        );
    }

    function _requireSufficientYUSDBalance(
        IYUSDToken _yusdToken,
        address _borrower,
        uint256 _debtRepayment
    ) internal view {
        require(
            _yusdToken.balanceOf(_borrower) >= _debtRepayment,
            ""BorrowerOps: Caller doesnt have enough YUSD to make repayment""
        );
    }

    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)
        internal
        pure
    {
        if (_isRecoveryMode) {
            require(
                _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must less than or equal to 100%""
            );
        } else {
            require(
                _maxFeePercentage >= BORROWING_FEE_FLOOR && _maxFeePercentage <= DECIMAL_PRECISION,
                ""Max fee percentage must be between 0.5% and 100%""
            );
        }
    }

    
    function _requireValidRouterParams(
        address[] memory _finalRoutedColls,
        uint[] memory _amounts,
        uint[] memory _minSwapAmounts,
        IYetiRouter[] memory _routers) internal view {
        require(_finalRoutedColls.length == _amounts.length);
        require(_amounts.length == _routers.length);
        require(_amounts.length == _minSwapAmounts.length);
        for (uint i = 0; i < _routers.length; i++) {
            require(whitelist.isValidRouter(address(_routers[i])));
        }
    }

    
    function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {
        for (uint i = 0; i < _indices.length - 1; i++) {
            require(_indices[i] < _indices[i + 1]);
        }
    }


    

    
    function _getNewICRFromTroveChange(
        uint256 _newVC,
        uint256 _debt,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal pure returns (uint256) {
        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);

        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);
        return newICR;
    }

    function _getNewTCRFromTroveChange(
        uint256 _collChange,
        bool _isCollIncrease,
        uint256 _debtChange,
        bool _isDebtIncrease
    ) internal view returns (uint256) {
        uint256 totalColl = getEntireSystemColl();
        uint256 totalDebt = getEntireSystemDebt();

        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);
        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);

        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);
        return newTCR;
    }

    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {
        return _getCompositeDebt(_debt);
    }

    function _max(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a > _b ? _a : _b;
    }

    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {
        return _a < _b ? _a : _b;
    }
}",8265.0,0,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Non-compliant ERC20 Token Handling**: The contract uses `transferFrom` which may fail for tokens that do not return a boolean (e.g., older ERC20 implementations). This can cause transactions to revert when interacting with such tokens, leading to failed deposits or collateral transfers.

2. **Reentrancy Risk During Collateral Withdrawal**: The contract sends collateral to users via external calls (e.g., `activePool.sendCollateralsUnwrap`) after updating state. If collateral tokens implement callbacks (e.g., ERC777), a malicious actor could re-enter the contract, potentially manipulating state before completion.

3. **Fee-on-Transfer Token Accounting Issues**: The contract assumes that transferred collateral amounts match the specified `_amountsIn`. Tokens with fee-on-transfer mechanics would result in discrepancies between recorded and actual balances, leading to undercollateralized positions.

4. **Incorrect Slippage Handling in Adjustments**: When adjusting troves, the contract relies on real-time price feeds but lacks explicit user-defined slippage protection. Sudden price changes between transaction submission and execution could lead to unintended collateral/debt changes.

5. **Division by Zero in Fee Calculation**: In rare cases where `_maxFeePercentageFactor` is zero (e.g., if both `VCin` and `YUSDChange` are zero during debt increase), division operations could fail, though other checks likely prevent this scenario.

6. **Dependency on External Contract Integrity**: The contract's functionality heavily depends on correctly configured external contracts (e.g., `troveManager`, `activePool`). Any vulnerabilities or misconfigurations in these dependencies could compromise the entire system.

7. **Lack of Bootstrap Period Enforcement**: The `_getTotalVariableDepositFee` caps fees during the bootstrap period, but improper whitelist configuration could allow lower fees, potentially bypassing intended safeguards.

8. **No Check for Active Pool Balance Consistency**: The contract does not verify that collateral balances in the active pool match the expected amounts after transfers, risking accounting inaccuracies if tokens have non-standard behavior.

9. **Ownership Renouncement Irreversibility**: Once `setAddresses` is called, ownership is renounced, making it impossible to rectify any misconfigured addresses, potentially rendering the contract unusable.

10. **Insufficient Validation of Collateral Withdrawal Value**: The contract allows withdrawing collateral based on the current value without explicit user confirmation of the value change, relying solely on real-time price feeds which could be manipulated or outdated.","---

**[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Report Description**:  
The issue identifies multiple functions in `BorrowerOperations.sol` that are potentially re-entrant due to the lack of reentrancy guards. These functions include `addColl()`, `withdrawColl()`, `withdrawYUSD()`, `repayYUSD()`, `adjustTrove()`, `openTrove()`, and `closeTrove()`. Each of these functions is external and interacts with other internal functions that modify critical state variables such as user debt, collateral balances, and trove creation. The absence of reentrancy guards makes the contract vulnerable to reentrancy attacks, where malicious actors could exploit these functions to manipulate state variables before the completion of the original transaction.

**Match in Response List**:  
Matches with the issue titled **""Reentrancy Risk During Collateral Withdrawal""**.

**Validation**:  
**Partially Correct**. The response correctly identifies the risk of reentrancy during collateral withdrawal, which aligns with the issue reported. However, the response focuses narrowly on collateral withdrawal (`activePool.sendCollateralsUnwrap`) and does not address the broader scope of reentrancy risks in other functions such as `addColl()`, `withdrawYUSD()`, `repayYUSD()`, `adjustTrove()`, `openTrove()`, and `closeTrove()`. While the response correctly highlights the risk of callbacks in ERC777 tokens, it misses the critical detail that the issue extends to multiple functions and state modifications. Therefore, the response is partially correct but insufficient in fully addressing the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-05] Reentrancy in contracts/BorrowerOperations.sol**

**Missed Issues from Issue Report**:  
- *None*

---",0,1,0,10,"Okay, I need to analyze the given smart contract code and list all the vulnerabilities. Let me start by reading through the code carefully. 

First, the contract is BorrowerOperations, which is part of a lending system. It allows users to open, adjust, and close troves (similar to positions) with multiple collaterals. Let's look for common vulnerabilities like reentrancy, arithmetic issues, access control, etc.

Looking at the functions, there's a lot of interaction with external contracts via interfaces. The setAddresses function sets various addresses and renounces ownership. Once ownership is renounced, no further changes can be made. Wait, but setAddresses is external and onlyOwner, and after setting addresses, it calls _renounceOwnership(). So after deployment, the owner is renounced, which is good, but if any of the addresses are set incorrectly, they can't be fixed. That's a risk if there's a mistake in initial setup.

Next, the openTrove function transfers collaterals into the active pool. It uses _transferCollateralsIntoActivePool, which loops through each collateral and transfers using transferFrom. If any transfer fails, it returns false. But the require statement checks that it returns true. So that's okay. But I should check if there are any issues with ERC20 approvals or if some tokens don't return a boolean, but since it's using IERC20, which is standard, maybe not. However, some old tokens like USDT don't return a boolean on transferFrom. If any of the collateral tokens are such, this could fail. That's a potential issue.

In _openTroveInternal, there's a call to _triggerBorrowingFee which mints YUSDFee to sYETIAddress. Then there's a deposit fee calculation. The fees are added to the debt. Wait, if the system mints YUSD as fees, but then adds that to the netDebt, could there be an inflation issue? Also, the fees are calculated based on the _maxFeePercentage. The _getTotalVariableDepositFee function might have issues. Let's check that function.

In _getTotalVariableDepositFee, there's a loop over the tokensIn. For each token, it calculates a fee based on the whitelist.getFeeAndUpdate. Then sums up the YUSDFee. The _requireUserAcceptsFee checks if YUSDFee is acceptable based on _maxFeePercentageFactor and _maxFeePercentage. However, if the sum of fees from multiple collaterals exceeds the max allowed, the transaction should revert. But maybe if the individual fees are each under the max, but together they exceed? Wait, no, because the _maxFeePercentage is applied to the sum. Let me see: YUSDFee is the total from all collaterals. Then _maxFeePercentageFactor is the max between VCin and YUSDChange. Then YUSDFee must be <= (maxFeePercentageFactor * maxFeePercentage)/DECIMAL_PRECISION. That seems correct.

Reentrancy: The contract uses Checks-Effects-Interactions pattern? Let's see in adjustTrove. After applying pending rewards, it updates the trove, then moves YUSD, and sends collaterals out. The sending of collaterals is done via activePool.sendCollateralsUnwrap, which could potentially call back into the contract. If the collateral is a malicious contract, maybe reentrancy is possible here. Since the state changes (like updating the trove) are done before sending the collateral, maybe it's safe. But if the sendCollateralsUnwrap is external and does a callback, could a reentrant call modify the state? For example, during a collateral withdrawal, if the token is malicious, transferring could re-enter. But the state has already been updated, so maybe it's okay. But this is a common pitfall. Need to check if external calls are done after all state changes.

In the adjustTrove function, after updating the trove's collaterals and debt, it calls activePool.sendCollateralsUnwrap. If that function transfers the collateral tokens to the user, and if those tokens have a callback (like ERC777), the user could re-enter the contract. However, since the trove's state has already been updated, maybe the reentrancy can't affect it. But maybe there's a way to exploit it. For example, if during the send, the user opens another trove or adjusts again. But given the checks in place (like _requireTroveisActive), maybe not. Still, it's a potential risk if not properly guarded.

Another thing: The contract uses SafeMath? The code has .sub and .add methods, which suggests that they are using SafeMath for uint256. But in Solidity 0.6.x, those aren't automatically checked unless using a library. The code imports LiquityBase, which might include SafeMath. Let me check. The code includes dependencies, but if LiquityBase uses SafeMath, then arithmetic operations are safe. If not, there could be underflow/overflow issues. Assuming that the code uses SafeMath correctly, maybe that's covered.

In the _adjustTrove function, the code computes vars.newVC as the VC of the new collaterals. Then calculates newICR. If the newVC is zero and debt is non-zero, the ICR would be zero, which would fail the require checks. But the code requires that in normal mode, the ICR is above MCR, so that would revert. So maybe that's handled.

Another issue: The contract allows multiple collaterals, but when adding or removing collaterals, there's a check for duplicates. The _requireNoDuplicateColls function ensures that in the input arrays, there are no duplicates. However, when combining collsIn and collsOut, is there a check that the user isn't trying to add and remove the same collateral in the same transaction? For example, in adjustTrove, the user could have collsIn and collsOut containing the same token. The _requireNoOverlapColls checks for overlap between _collsIn and _collsOut. So that's prevented. So that's handled.

What about the function _getNewPortfolio? It sums the initial collaterals with collsIn and subtracts collsOut. If a collateral is in both initial and collsOut, it's subtracted. But how is the subtraction handled? For example, if the user has 5 ETH, and withdraws 3 ETH, that's okay. But if they try to withdraw more than they have, the subtraction would underflow. The code uses SafeMath, so that would revert. So that's safe.

In the _triggerBorrowingFee function, it mints YUSD to sYETIAddress. But if sYETIAddress is a contract that doesn't handle YUSD tokens, that could lock fees. But that's an external issue, not a vulnerability in this contract.

The closeTrove function allows a user to close their trove. It checks that the user has enough YUSD to repay the debt minus gas compensation. Then it sends the remaining collaterals to the user. However, if the system is in recovery mode, this function can't be called. But during normal operation, if the TCR is above CCR, it's allowed. The function repays the debt and sends collaterals. If the user's balance is insufficient, the repayYUSD would fail. But the code checks _requireSufficientYUSDBalance before, so that's handled.

Another possible issue: The deployment time is set in setAddresses, which can only be called once by the owner before ownership is renounced. If the deployment time is incorrectly set, the bootstrap period would be miscalculated. However, once setAddresses is called, deploymentTime is block.timestamp, which should be correct.

In _getTotalVariableDepositFee, during the bootstrap period, the fee is capped at 1e16 (1%). But if the whitelist.getFeeAndUpdate returns a higher fee, it's capped. That's intentional, so no issue there.

Now, looking for access control issues. All the main functions (openTrove, adjustTrove, etc.) are external and can be called by any user, which is correct. The setAddresses is onlyOwner, and ownership is renounced after, so that's okay.

Potential front-running: Users might have their transactions front-run, but that's a general issue in Ethereum, not specific to this contract.

Another thing: In the adjustTrove function, if the user is decreasing debt, the code checks that the debt repayment is valid. But when repaying, the code calls _repayYUSD, which burns the YUSD from the user. However, if the user's balance is not enough, the function would revert. The code has _requireSufficientYUSDBalance, which should prevent this.

Check for division precision: In some calculations, like vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC), if VC is zero, this would cause a division by zero. But VC is the sum of the value of collaterals, which is checked to be non-zero when opening a trove. So maybe in adjustTrove, if VCin is zero (no collsIn), then _maxFeePercentageFactor would be YUSDChange. But if YUSDChange is also zero, then division by zero could happen. Wait, in adjustTrove, when params._isDebtIncrease is true, vars.maxFeePercentageFactor is max(vars.VCin, params._YUSDChange). If both are zero, then _maxFeePercentageFactor is zero. Then when calculating _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)), this would be division by zero. But when can vars.maxFeePercentageFactor be zero? Only if both VCin and YUSDChange are zero. But if it's a debt increase, YUSDChange must be non-zero (due to _requireNonZeroDebtChange). So in that case, if YUSDChange is non-zero, then vars.maxFeePercentageFactor is max(0, YUSDChange) = YUSDChange, which is non-zero. So division by zero is avoided. 

What about in the case of adding collateral without changing debt? Then in adjustTrove, if _YUSDChange is zero (no debt change), and VCin is positive (since adding collateral), then vars.maxFeePercentageFactor is VCin. If VCin is zero (but that's impossible because adding collateral would have amountsIn), then maybe not. So division by zero seems to be prevented.

Another possible issue: In the _openTroveInternal function, if the system is in recovery mode, the code skips the borrowing fee. However, during recovery mode, certain operations are restricted. But this seems correct as per the checks.

In the _triggerDepositFee function, it mints YUSDFee to sYETIAddress. If the sYETI contract isn't expecting to receive YUSD, this could cause issues. But that's an integration issue rather than a vulnerability in this contract.

Check for proper event emissions: Events are emitted after state changes, which is good for tracking.

Now, considering all these points, the vulnerabilities I can identify are:

1. **Incorrect ERC20 Transfer Handling**: The contract uses IERC20's transferFrom, which might fail for tokens that don't return a boolean (e.g., old ERC20 implementations). This could cause the transfer to revert, which is handled by the require statement, but if a collateral token is such a non-compliant token, the system won't be able to handle it, leading to failed transactions.

2. **Reentrancy in Collateral Withdrawal**: When sending collateral back to the user via activePool.sendCollateralsUnwrap, if the collateral token is an ERC777 or similar with callbacks, a malicious user could re-enter the contract. However, since the state is updated before the external call, this might not allow for harmful reentrancy. But without a reentrancy guard, there's a potential risk if other functions can be called in a harmful way during the callback.

3. **Bootstrap Period Fee Cap Bypass**: The _getTotalVariableDepositFee function caps the fee during the bootstrap period to 1%. However, if the whitelist returns a fee lower than 1%, it uses that. But if the whitelist is compromised or incorrectly configured, it might allow lower fees during the bootstrap period. But that's more of a configuration issue.

4. **Dependency on External Contracts**: The contract relies on several external contracts (e.g., troveManager, activePool) being properly configured. If these contracts have vulnerabilities, they could affect this contract. But that's outside the scope of this contract's vulnerabilities.

5. **Possible Division by Zero in Fee Calculation**: As discussed earlier, in some edge cases where _maxFeePercentageFactor is zero, division could fail. But the conditions to reach that state seem impossible due to other checks in the code.

6. **Lack of Slippage Protection in adjustTrove**: When adjusting the trove, the user specifies collsOut and amountsOut, but there's no check that the actual value of the withdrawn collateral matches expectations. For example, if the collateral's value drops between the transaction's signing and execution, the user might withdraw more value than intended. However, the code checks the VC (value in collateral) which is based on the current price, so this is handled by the system's price feed. But if the price feed is outdated or manipulated, this could be an issue (though that's a different component's problem).

7. **No Check for Active Pool's Collateral Balance**: When transferring collaterals into the active pool, the code assumes the transfer is successful. The require statement checks the return value of _transferCollateralsIntoActivePool, which in turn checks each transfer's success. However, if the active pool's balance isn't properly updated or if tokens have fees on transfer, the actual received amount could be less than expected, leading to discrepancies. For example, if a token charges a transfer fee, the active pool's balance increases less than the amount specified, causing inconsistencies in the system's accounting.

8. **Incorrect Handling of Fee-on-Transfer Tokens**: If any of the collateral tokens implement a fee-on-transfer mechanism, the actual amount received by the active pool would be less than the _amountsIn[i] specified. This would cause the system to overestimate the collateral held, leading to potential undercollateralization of loans. The current code does not account for such tokens, assuming that the transferred amount is exactly as specified.

9. **Liquidation and Recovery Mode Assumptions**: The contract relies on the troveManager to handle recovery mode correctly. If there's a miscalculation in the system's total collateral or debt, it could affect whether the contract correctly enters or exits recovery mode, leading to improper operation of functions restricted to certain modes.

10. **Lack of Check for Contract Existence When Setting Addresses**: The setAddresses function uses checkContract, which presumably checks that the address is a contract. However, if any of these addresses are incorrect (e.g., a contract that doesn't implement the required interface), the system could become non-functional. Once ownership is renounced, this can't be fixed. However, this is a deployment risk rather than a code vulnerability.

After considering these points, the main vulnerabilities are:

- Handling of non-compliant ERC20 tokens (no return value).
- Potential reentrancy during collateral withdrawal.
- Fee-on-transfer tokens causing accounting discrepancies.
- Lack of slippage protection in adjustTrove (though mitigated by price feeds).
- Dependence on external contracts' correctness.

But according to the problem statement, I should list all vulnerabilities without mitigation. So I'll list them as follows.","```
None.
```",0.0
ThreePieceWiseLinearPriceCurve.sol,"// SPDX-License-Identifier: UNLICENSED

pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";

/** 
 * This contract is used to calculate the variable fee for an input of tokens. 
 * Uses three linear piecewise functions to calculate the fee, and the average 
 * of the system collateralization by that asset before and after the tx. 
 */
contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    /** 
     * f1 = m1 * x + b1
     * f1 meets f2 at cutoff1, which is defined by that intersection point and slope m2
     * f2 meets f3 at cutoff2, which is defined by that intersection point and slope m3
     * Everything in terms of actual * 1e18, scaled by 1e18 because can't do percentages
     * Decimal precision = 1e18
     */

    /** 
     * Function for setting slopes and intercepts of linear functions used for fee calculations. 
     */
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        // b2 = _m1.mul(_cutoff1).div(1e18).add(_b1).sub(_m2.mul(_cutoff1).div(1e18));
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        // b3 = _m2.mul(_cutoff2).div(1e18).add(b2).sub(_m3.mul(_cutoff2).div(1e18));
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; // Cap in VC terms of max of this asset. dollarCap = 0 means no cap. No cap.
        decayTime = 5 days;
    }

    // Set the whitelist address so that the fee can only be updated by whitelistAddress
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    // Set the decay time in seconds
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    // Gets the fee cap and time currently. Used for setting new values for next price curve. 
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    // Function for setting the old price curve's last fee cap / value to the new fee cap / value. 
    // Called only by whitelist. 
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     * @param _collateralVCInput is how much collateral is being input by the user into the system
     * @param _totalCollateralVCBalance is how much collateral is in the system
     * @param _totalVCBalancePost is how much VC the system for all collaterals after all adjustments (additions, subtractions)
     */
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    // Called only by whitelist. Updates the last fee time and last fee percent
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        // If dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    /** 
     * Function for getting the fee for a particular collateral type based on percent of YUSD backed
     * by this asset. 
     */
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        // percent of all VC backed by this collateral * 1e18
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { // use function 1
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { // use function 2
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            // return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
        } else { // use function 3
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            // return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        // Decay within bounds of decay time, then decay the fee. 
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            // If it has been longer than decay time, then reset fee to 0.
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",2218.0,197.0,"[M-07] Cannot use most piecewise linear functions with current implementation
TheÂ `adjustParamsÂ function` uses three functionsÂ `f1`, `f2`, `f3`Â whereÂ `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but usesÂ unsigned integersÂ for this, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.
â€¨
[M-08] Wrong comment inÂ `getFee()`
TheÂ function `getFee`Â comment states that the total + the input must be less than the cap:
â€œIf dollarCap == 0, then it is not capped. Otherwise,Â then the total + the total inputÂ must be less than the cap.â€
The code only checks if the input is less than the cap.â€¨â€¨â€¨[M-09] Fee not decayed if pastÂ decayTime
TheÂ function `calculateDecayedFee`Â function is supposed to decay theÂ `lastFeePercent`Â over time. This is correctly done in theÂ `decay > 0` && `decay < decayTime`Â case, but for theÂ `decay > decayTime`Â case it does not decay at all but should set it to 0 instead..",3.0,"pragma solidity 0.6.11;

import ""../Interfaces/IPriceCurve.sol"";
import ""../Dependencies/SafeMath.sol"";
import ""../Dependencies/Ownable.sol"";


contract ThreePieceWiseLinearPriceCurve is IPriceCurve, Ownable {
    using SafeMath for uint256;

    string name;
    uint256 m1;
    uint256 b1;
    uint256 cutoff1;
    uint256 m2;
    uint256 b2;
    bool b2Negative;
    uint256 cutoff2;
    uint256 m3;
    uint256 b3;
    bool b3Negative;
    uint256 decayTime;

    uint lastFeeTime;
    uint lastFeePercent;
    uint dollarCap;
    address whitelistAddress;
    bool private addressesSet;

    

    
    function adjustParams(string memory _name, uint256 _m1, uint256 _b1, uint256 _m2, uint256 _cutoff1, uint256 _m3, uint256 _cutoff2, uint _dollarCap) external onlyOwner {
        require(_cutoff1 <= _cutoff2, ""Cutoffs must be increasing"");
        name = _name;
        m1 = _m1;
        b1 = _b1;
        m2 = _m2;
        uint256 m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1);
        uint256 m2Val = _m2.mul(_cutoff1).div(1e18);
        if (m2Val > m1Val) {
            b2Negative = true;
            b2 = m2Val.sub(m1Val);
        } else {
            b2 = m1Val.sub(m2Val);
        }
        
        cutoff1 = _cutoff1;
        m3 = _m3;
        m2Val = _m2.mul(_cutoff2).div(1e18).add(b2);
        uint256 m3Val = _m3.mul(_cutoff2).div(1e18);
        if (m3Val > m2Val) {
            b3Negative = true;
            b3 = m3Val.sub(m2Val);
        } else {
            b3 = m2Val.sub(m3Val);
        }
        
        cutoff2 = _cutoff2;
        dollarCap = _dollarCap; 
        decayTime = 5 days;
    }

    
    function setAddresses(address _whitelistAddress) external override onlyOwner {
        require(!addressesSet, ""addresses already set"");
        whitelistAddress = _whitelistAddress;
        addressesSet = true;
    }

    
    function setDecayTime(uint _decayTime) external override onlyOwner {
        decayTime = _decayTime;
    }

    
    function getFeeCapAndTime() external override view returns (uint256, uint256) {
        return (lastFeePercent, lastFeeTime);
    }

    
    
    function setFeeCapAndTime(uint256 _lastFeePercent, uint256 _lastFeeTime) external override {
        require(msg.sender == whitelistAddress, ""caller must be whitelist"");
        lastFeePercent = _lastFeePercent;
        lastFeeTime = _lastFeeTime;
    }

    
    function getFee(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external view returns (uint256 fee) {
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }

        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        return feeCalculated;
    }

    
    function getFeeAndUpdate(uint256 _collateralVCInput, uint256 _totalCollateralVCBalance, uint256 _totalVCBalancePre, uint256 _totalVCBalancePost) override external returns (uint256) {
        require(msg.sender == whitelistAddress, ""Only whitelist can update fee"");
        
        uint256 cachedDollarCap = dollarCap;
        if (cachedDollarCap != 0) {
            require(_totalCollateralVCBalance.add(_collateralVCInput) <= cachedDollarCap, ""Collateral input exceeds cap"");
        }
        uint feePre = _getFeePoint(_totalCollateralVCBalance, _totalVCBalancePre);
        uint feePost = _getFeePoint(_totalCollateralVCBalance.add(_collateralVCInput), _totalVCBalancePost);

        uint decayedLastFee = calculateDecayedFee();
        uint feeCalculated = _max((feePre.add(feePost)).div(2), decayedLastFee);

        lastFeeTime = block.timestamp;
        lastFeePercent = feeCalculated;
        return feeCalculated;
    }

    
    function _getFeePoint(uint256 _collateralVCBalance, uint256 _totalVCBalance) internal view returns (uint256 fee) {
        if (_totalVCBalance == 0) {
            return 0;
        }
        
        uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
        require(percentBacked <= 1e18, ""percent backed out of bounds"");

        if (percentBacked <= cutoff1) { 
            return _min(m1.mul(percentBacked).div(1e18).add(b1), 1e18);
        } else if (percentBacked <= cutoff2) { 
            if (b2Negative) {
                return _min(m2.mul(percentBacked).div(1e18).sub(b2), 1e18);
            } else {
                return _min(m2.mul(percentBacked).div(1e18).add(b2), 1e18);
            }
            
        } else { 
            if (b3Negative) {
                return _min(m3.mul(percentBacked).div(1e18).sub(b3), 1e18);
            } else {
                return _min(m3.mul(percentBacked).div(1e18).add(b3), 1e18);
            }
            
        }
    }

    function calculateDecayedFee() public override view returns (uint256 fee) {
        uint256 decay = block.timestamp.sub(lastFeeTime);
        
        uint256 cachedDecayTime = decayTime;
        if (decay <= cachedDecayTime) {
            fee = lastFeePercent.sub(lastFeePercent.mul(decay).div(cachedDecayTime));
        } else {
            
            fee = 0;
        }
    }

    function _min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? b : a;
    }

    function _max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a <= b ? b : a;
    }
}",1536.0,0,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Single-Use `setAddresses` Leading to Immutable Whitelist**  
   The `setAddresses` function can only be called once, permanently fixing the `whitelistAddress`. If the whitelist is compromised or needs an update, the contract cannot recover, leading to a permanent security risk.

2. **Division by Zero in `calculateDecayedFee`**  
   If `decayTime` is set to zero via `setDecayTime`, the calculation `lastFeePercent.mul(decay).div(cachedDecayTime)` will cause a division by zero, reverting transactions that call `getFee` or `getFeeAndUpdate`.

3. **Underflow in Fee Segments 2 and 3**  
   Parameters set in `adjustParams` (e.g., `m2`, `b2`, `b2Negative` or `m3`, `b3`, `b3Negative`) may cause subtraction underflow in `_getFeePoint` when calculating fees for the second or third segments. For example, if `m2 * percentBacked / 1e18 < b2` and `b2Negative` is `true`, `SafeMath.sub` reverts, leading to denial of service.

4. **Uninitialized Contract State**  
   Critical parameters (`m1`, `b1`, `cutoff1`, etc.) are not initialized in the constructor. If `adjustParams` is not called after deployment, default zero values are used, resulting in incorrect fee calculations (e.g., zero fees) and potential protocol malfunction.

5. **Precision Loss in Fee Averaging**  
   The average of `feePre` and `feePost` is computed using integer division (`(feePre + feePost).div(2)`), truncating fractional values. This may result in underestimated fees, especially for odd sums.

6. **Lack of Validation in `adjustParams`**  
   The `adjustParams` function does not ensure that parameters (e.g., `m2`, `b2`, `m3`, `b3`) are set to avoid underflow/overflow in fee calculations. For instance, setting `b2 > m1Val` when `b2Negative` is `true` can lead to invalid fee ranges.","### **Output**

---

**[M-07] Cannot use most piecewise linear functions with current implementation**

**Report Description**:  
The `adjustParams` function uses three functions `f1`, `f2`, `f3` where `y_i = f_i(x_i)`. It computes the y-axis intersect (`b2 = f_2(0)`, `b3 = f_3(0)`) for each of these but uses unsigned integers, which means these values cannot become negative. This rules out a whole class of functions, usually the ones that are desirable.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unsigned integers preventing the use of negative y-axis intersects in piecewise linear functions. This is a significant limitation in the implementation of `adjustParams` that is entirely missed.

---

**[M-08] Wrong comment in `getFee()`**

**Report Description**:  
The function `getFee` comment states that the total + the input must be less than the cap:  
â€œIf dollarCap == 0, then it is not capped. Otherwise, then the total + the total input must be less than the cap.â€  
The code only checks if the input is less than the cap.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the discrepancy between the comment and the actual implementation in `getFee`. This is a documentation issue that could lead to misunderstandings or misuse of the function.

---

**[M-09] Fee not decayed if past decayTime**

**Report Description**:  
The function `calculateDecayedFee` is supposed to decay the `lastFeePercent` over time. This is correctly done in the `decay > 0` && `decay < decayTime` case, but for the `decay > decayTime` case, it does not decay at all but should set it to 0 instead.

**Match in Response List**:  
Matches with the issue titled **""Division by Zero in `calculateDecayedFee`""**.

**Validation**:  
**Partially Correct**. The response identifies a vulnerability in `calculateDecayedFee` (division by zero) but does not address the issue of incorrect fee decay behavior when `decay > decayTime`. The response partially overlaps with the issue but misses the core problem of improper fee decay logic.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-09] Fee not decayed if past decayTime**

**Missed Issues from Issue Report**:  
- **[M-07] Cannot use most piecewise linear functions with current implementation**  
- **[M-08] Wrong comment in `getFee()`**

---

### **Analysis**  
The `response_list` partially addresses one issue ([M-09]) but misses the other two issues entirely ([M-07] and [M-08]). The response list focuses on vulnerabilities like division by zero, underflow, and uninitialized state but does not cover limitations in function implementation or documentation discrepancies. This indicates gaps in the response list's coverage of the issues reported.",0,1,2,6,"Okay, let's take a look at this smart contract and try to figure out what vulnerabilities it might have. I'm not an expert, but I'll try to think through each part step by step.

First, the contract is called ThreePieceWiseLinearPriceCurve and it's Ownable. It imports SafeMath and some interfaces. So maybe some math-related issues? Since they're using SafeMath, maybe overflows are handled, but maybe there's something else.

Looking at the state variables, there's a name, various m1, b1, cutoff1, etc., and some flags like b2Negative and b3Negative. There's also a decayTime, lastFeeTime, lastFeePercent, dollarCap, whitelistAddress, and addressesSet. The addressesSet is a boolean that's initialized to false, I guess. The adjustParams function is only callable by the owner, which sets parameters for the price curve. Then there's setAddresses which can only be called once because addressesSet is checked.

Starting with the adjustParams function. It takes a bunch of parameters and does some calculations. The first thing is the require statement that _cutoff1 <= _cutoff2. That's good. Then setting the name and other variables. Then calculating m1Val and m2Val. Wait, m1Val is _m1 * _cutoff1 / 1e18 + _b1. Then m2Val is _m2 * _cutoff1 / 1e18. Then it checks if m2Val > m1Val. If so, b2Negative is true and b2 is m2Val - m1Val. Else, b2 is m1Val - m2Val. But wait, why? Because when they use b2 later, if b2Negative is true, they subtract b2, else add. So this is setting up the parameters for the piecewise function. But maybe there's an issue here if m1Val and m2Val are not properly calculated. Also, using SafeMath for these operations, so maybe no overflow here.

Then for m3, similar steps. But let's check if all these variables are properly initialized. For example, when m3Val is calculated, they use _m3 * _cutoff2 / 1e18. Then compare m2Val (which is _m2 * _cutoff2 / 1e18 + b2). Wait, but in adjustParams, after cutoff1 is set, they compute m2Val as _m2 * _cutoff2 (wait, no, the code says _cutoff2 here? Let me check. 

Wait, no. Let me look again. After cutoff1 is set, m3 is assigned _m3. Then m2Val is calculated as _m2.mul(_cutoff2).div(1e18).add(b2). Then m3Val is _m3.mul(_cutoff2).div(1e18). Then compare m3Val and m2Val. So for the third segment, the cutoff is _cutoff2. So that's the second cutoff. So the code for adjustParams seems to be setting up three linear pieces with cutoffs at cutoff1 and cutoff2. 

But in the _getFeePoint function, when percentBacked is <= cutoff1, it uses m1 and b1. Between cutoff1 and cutoff2, it uses m2 and b2 with the negative flag. Above cutoff2, uses m3 and b3 with the negative flag. So if the parameters are set incorrectly, maybe there's a miscalculation here. But the adjustParams function is supposed to ensure continuity. Wait, but the way they set b2 and b3 is by ensuring that at the cutoff points, the values match. For example, at cutoff1, the first segment's value is m1*cutoff1 + b1, and the second segment starts at m2*cutoff1 + b2 (if b2 is added) or subtracted. Wait, the code in adjustParams seems to compute m1Val (value at cutoff1 for the first segment) and m2Val (value at cutoff1 for the second segment). Then sets b2 as the difference so that when the second segment is evaluated at cutoff1, it's either m2*cutoff1 + b2 (if m2Val < m1Val, so b2 is m1Val - m2Val), making the second segment's value at cutoff1 m2*cutoff1 + (m1Val - m2Val) = m1Val. So that's correct for continuity. Similarly for cutoff2, m2Val is m2*cutoff2 + b2 (since the second segment is m2*x + b2) and m3Val is m3*cutoff2. Then b3 is set as the difference between these two. Wait, no: in adjustParams, after cutoff2 is set, m2Val is computed as _m2 (which is m2) multiplied by cutoff2, divided by 1e18, and added to b2. Then m3Val is m3 multiplied by cutoff2 divided by 1e18. Then if m3Val > m2Val, b3Negative is true and b3 is m3Val - m2Val. Otherwise, b3 is m2Val - m3Val. Wait, this would make the third segment at cutoff2 be m3*cutoff2/1e18 + b3 (if b3Negative is false) or m3*cutoff2/1e18 - b3 (if true). But the way b3 is calculated: if m3Val > m2Val, then the third segment at cutoff2 would be m3*cutoff2/1e18 - (m3Val - m2Val) = m2Val. Which is the value of the second segment at cutoff2. So this ensures continuity. So the parameters are set correctly for continuity. So maybe there's no issue here.

Now looking at the getFee function. It calls _getFeePoint for pre and post, averages them, and takes the max between that average and decayedLastFee. But how is the average calculated? (feePre + feePost) / 2. But division in Solidity truncates. So if feePre + feePost is odd, the division would lose precision. But since these are fees, maybe that's acceptable. However, if high precision is required, this could be a problem.

Another thing: in getFee, there's a check if dollarCap is not zero, then require that _totalCollateralVCBalance + _collateralVCInput <= cachedDollarCap. But the cachedDollarCap is set as dollarCap. However, since this is a view function, dollarCap could be changed by the owner after this check. But since the function is view, it's just reading the current state, so if the owner changes dollarCap after this check, it could affect subsequent calls, but that's intended. So maybe not an issue here. However, in the getFeeAndUpdate function, which is not a view function, the same check is performed. So if during the execution of getFeeAndUpdate, the dollarCap is changed, but since they cache it first (cachedDollarCap = dollarCap), they use the current value. So that's okay.

In the getFee function, when they calculate _collateralVCBalance.add(_collateralVCInput), but if this addition overflows, SafeMath would catch it. So that's handled.

In the _getFeePoint function, they compute percentBacked as _collateralVCBalance.mul(1e18).div(_totalVCBalance). If _totalVCBalance is zero, they return 0. But what if _totalVCBalance is zero and _collateralVCBalance is not zero? Then the require would fail, but in that case, the code returns 0 before that. Wait, no: if _totalVCBalance is zero, the code returns 0. But if _totalVCBalance is zero and _collateralVCBalance is non-zero, then in the next lines, percentBacked would be (_collateralVCBalance * 1e18) / 0, which would revert. But the code first checks if _totalVCBalance == 0, returns 0. So even if _collateralVCBalance is non-zero, the function returns 0. But that's a possible division by zero if _totalVCBalance is zero and _collateralVCBalance is non-zero? Wait, no, because if _totalVCBalance is zero, the first condition returns 0, so the division is skipped. So that's safe.

Wait, let's look again: 

function _getFeePoint(...) returns (uint256 fee) {
    if (_totalVCBalance == 0) {
        return 0;
    }
    uint256 percentBacked = _collateralVCBalance.mul(1e18).div(_totalVCBalance);
    require(percentBacked <= 1e18, ""..."");
    ...
}

So if _totalVCBalance is zero, return 0. Otherwise, compute percentBacked. So division by zero is avoided here. So that's okay.

But what if _totalVCBalance is very small? Like, if it's 1, then percentBacked could be up to _collateralVCBalance * 1e18. If _collateralVCBalance is large, this could overflow. But since SafeMath is used, the multiplication would revert on overflow. So that's a possible issue if inputs can be manipulated to cause an overflow here. But since _collateralVCBalance and _totalVCBalance are provided as parameters, maybe the caller is responsible for ensuring they are valid. However, if the inputs can be controlled by an attacker, they might cause a revert. But this function is called in getFee and getFeeAndUpdate, which are external functions. The parameters to these functions are provided by the caller (the whitelist address in getFeeAndUpdate), so if the whitelist is trusted, maybe it's not an issue. But if not, it could be a way to cause a denial of service.

Another point: the setAddresses function can only be called once because addressesSet is checked. But the Ownable's owner could potentially change, and if the original owner called setAddresses, a new owner can't call it again. But maybe that's intended. But if the whitelistAddress needs to be updated, this could be a problem. Since there's no way to reset addressesSet, once set, the whitelistAddress can't be changed. So if the whitelist gets compromised or needs to be updated, the contract can't adjust. That's a potential issue. It's a single-point-of-failure if the whitelist is fixed forever.

The calculateDecayedFee function computes decay as block.timestamp.sub(lastFeeTime). If decay is more than decayTime, returns 0. Otherwise, subtracts lastFeePercent * decay / decayTime from lastFeePercent. But if decayTime is zero, this would cause a division by zero. However, decayTime is set in adjustParams to 5 days initially, and can be changed via setDecayTime by the owner. If the owner sets decayTime to zero, then calculateDecayedFee would revert. So the owner could set decayTime to zero, causing any call to calculateDecayedFee to fail, which is used in getFee and getFeeAndUpdate. That's a possible vulnerability. The setDecayTime function doesn't have a check to ensure decayTime is non-zero. So the owner could set it to zero, leading to division by zero in calculateDecayedFee.

Another issue: the calculateDecayedFee function uses block.timestamp, which can be manipulated by miners to some extent, but since it's just a decay over time, maybe the effect is minimal. But it's a general consideration, though not necessarily a vulnerability here.

In the getFee function, the line return feeCalculated; which is the result of _max((feePre + feePost)/2, decayedLastFee). But since feePre and feePost are computed based on the current parameters, and decayedLastFee is based on time, maybe there's a logic error here. For example, if the feePre and feePost average is lower than the decayed fee, it would take the higher value (since _max takes the larger). Wait, no: _max(a, b) returns the larger of the two. So if decayedLastFee is larger, it would take that. The idea is that the fee can't be lower than the decayed fee. So that's intended. But maybe there's a miscalculation here. Not sure.

In the getFeeAndUpdate function, after calculating feeCalculated, it sets lastFeeTime to block.timestamp and lastFeePercent to feeCalculated. But if the call to getFeeAndUpdate is front-run, the values could be updated before the transaction is processed, leading to possible issues. But since the function is only callable by the whitelist address, which is supposed to be a trusted contract, maybe that's acceptable. However, if the whitelist is compromised, this could be a problem.

Another possible issue is reentrancy. The getFeeAndUpdate function updates the state after calculations. But since it doesn't make any external calls before updating the state, there's no reentrancy risk here. All external calls are done via the whitelist, but the function requires that the caller is the whitelistAddress. So no reentrancy from this function.

In the adjustParams function, when setting b2 and b3, the code uses m2Val and m1Val. Suppose m2Val is 5 and m1Val is 3. Then b2 would be 5 - 3 = 2, and b2Negative is true. Then in _getFeePoint, when using the second segment, it's m2 * percentBacked / 1e18 - b2. But wait, m2Val was _m2 * cutoff1 / 1e18. But m2 is set to _m2. So at cutoff1, the value of the second segment would be (m2 * cutoff1 / 1e18) - (m2Val - m1Val). Wait, m2Val here is _m2 * cutoff1 / 1e18. So (m2 * cutoff1 / 1e18) would be m2Val. Subtract (m2Val - m1Val) gives m1Val. Which is the value of the first segment at cutoff1. So that's correct for continuity. So maybe no issue here.

Another thing: the adjustParams function doesn't check if the slopes (m1, m2, m3) are set correctly. For example, if m1 is very large, causing the fee to exceed 1e18 (since the _min function is used to cap it at 1e18). But since the _min is applied, maybe that's okay. But if the parameters are set in a way that the fee is miscalculated, that's up to the owner. The code doesn't validate that m1, m2, m3 are within certain ranges. So if the owner sets them incorrectly, the fees could be wrong. But since the function is onlyOwner, it's a trust issue.

Another possible issue is that the adjustParams function allows the owner to set any parameters, which could be used to manipulate fees. For example, setting m1 to a very high value to make fees spike. But since it's onlyOwner, that's a centralization risk rather than a vulnerability in the code itself.

Looking at the calculateDecayedFee function: if lastFeeTime is in the future (which shouldn't happen), then block.timestamp.sub(lastFeeTime) would underflow. But lastFeeTime is set to block.timestamp in getFeeAndUpdate, so it should never be in the future. However, if someone could manipulate the block timestamp (which is not possible beyond a small margin), but in practice, lastFeeTime is set to the current block's timestamp when updating, so this shouldn't happen.

Another thing: the SafeMath usage. The contract uses SafeMath for uint256, so all arithmetic operations are checked for overflow/underflow. But are there any places where SafeMath is not used? Let's check:

In adjustParams, when calculating m1Val = _m1.mul(_cutoff1).div(1e18).add(_b1); â€” using SafeMath. Similarly for m2Val. The same applies to other calculations. The code uses .mul, .add, .sub etc., which are SafeMath functions. So overflow/underflow is handled.

In _getFeePoint, percentBacked is computed with mul and div, using SafeMath. The subsequent calculations for the fee also use .mul and .div with SafeMath. So those are safe.

In calculateDecayedFee, decay is block.timestamp.sub(lastFeeTime), using SafeMath. Then lastFeePercent.mul(decay).div(cachedDecayTime). So division here could truncate, but that's intended.

Another possible issue: in the setFeeCapAndTime function, which is external, the require statement checks that msg.sender == whitelistAddress. So only the whitelist can set the fee cap and time. But if the whitelist is compromised, this could be a problem. However, that's a trust issue with the whitelist, not a code vulnerability.

Now, looking for other common vulnerabilities:

- Access control issues: The adjustParams, setAddresses, setDecayTime are onlyOwner. The setFeeCapAndTime is only whitelist. The getFeeAndUpdate is only whitelist. So functions are properly protected.

- Uninitialized variables: The state variables are initialized when adjustParams is called. However, if adjustParams is not called before other functions, variables like m1, b1, etc., could be zero. For example, if getFee is called before adjustParams, the calculations might use default zero values, leading to incorrect fees. But since the owner needs to call adjustParams to set up the parameters, this is a deployment consideration rather than a code issue. However, the code does not enforce that adjustParams has been called before other functions. So if the contract is used without initializing parameters via adjustParams, it could behave unexpectedly.

- Integer division precision: As mentioned earlier, division truncates, which could lead to loss of precision. For example, (feePre + feePost) / 2 truncates. If feePre and feePost are both odd, this would lose 0.5. But since fees are in percentages scaled by 1e18, maybe this is acceptable. But if precision is important, using a weighted average differently could be better.

- Front-running: Since the owner can adjust parameters at any time, an attacker could front-run transactions to manipulate fees. For example, if the owner changes parameters right before a user's transaction, the fee calculation would be affected. But this is a centralization risk, not a code vulnerability.

- Whitelist single point of failure: The whitelistAddress can only be set once. If it's compromised, there's no way to change it. The setAddresses function can only be called once. So if the whitelist is set incorrectly, it's permanent. This is a vulnerability because it can't be recovered from if the initial setup is wrong.

- Decay time can be set to zero by owner, leading to division by zero in calculateDecayedFee. As mentioned earlier, if decayTime is zero, the calculation would revert. The owner could accidentally or maliciously set decayTime to zero, causing functions that call calculateDecayedFee (getFee, getFeeAndUpdate) to fail. This is a vulnerability.

- Use of deprecated Solidity version: The pragma is 0.6.11, which is not the latest, but that's a choice. However, versions prior to 0.8.0 don't have built-in overflow checks, but this contract uses SafeMath, so that's handled. The main issue is potential compiler bugs, but that's not a contract vulnerability per se.

- The adjustParams function allows the owner to set arbitrary parameters, including cutoffs. If cutoff1 is set higher than cutoff2, the require statement prevents that. But if they are set equal, that's allowed, but then the middle segment (between cutoff1 and cutoff2) would not exist. So if cutoff1 equals cutoff2, the code would treat percentBacked <= cutoff1 as first segment, <= cutoff2 (which is equal) as second segment, and else third. But since cutoff1 == cutoff2, the second segment would only include percentBacked == cutoff1, and the rest go to third. Not sure if that's intended, but the require statement allows cutoff1 <= cutoff2, including equality.

- The name variable is set in adjustParams, which is onlyOwner. Not a security issue, but maybe a metadata issue.

Another possible issue: the getFee function is a view function, but it calls calculateDecayedFee, which uses block.timestamp. So the fee returned by getFee depends on the current time, which is correct. But since it's a view function, it can't update the state. However, in getFeeAndUpdate, the state is updated. So if someone calls getFee, it returns the current decayed fee, but if they don't call getFeeAndUpdate, the lastFeePercent and lastFeeTime remain the same. This could lead to discrepancies if the fee is supposed to be updated on each call, but maybe the design is that only certain calls (via whitelist) update the fee. For example, if the system relies on the whitelist to call getFeeAndUpdate regularly, otherwise the decayed fee isn't captured. But this is a design choice rather than a vulnerability.

Also, in calculateDecayedFee, the decay is calculated as time since lastFeeTime. If the fee is supposed to decay over time, but the whitelist doesn't call getFeeAndUpdate for a long time, the stored lastFeePercent and lastFeeTime would not reflect the current decayed fee. However, when a new fee is calculated via getFeeAndUpdate, it takes the max between the current average and the decayed fee. So even if the whitelist doesn't call it frequently, the decayed fee would be applied when they do call it. But if the whitelist never calls it, the decayed fee could reach zero, and the next fee would be based on current parameters. So that's a design consideration.

Another possible problem: the _collateralVCInput is added to _totalCollateralVCBalance in getFee. If _collateralVCInput is very large, it could cause an overflow. But since SafeMath is used, this would revert. But the function is called by the whitelist, so inputs should be validated there.

So summarizing the potential vulnerabilities:

1. **Single-Use setAddresses**: The setAddresses function can only be called once. If the whitelistAddress is incorrect or compromised, there's no way to update it, leading to a permanent vulnerability.

2. **Division by Zero in calculateDecayedFee**: If the owner sets decayTime to zero via setDecayTime, the calculateDecayedFee function will revert due to division by zero, causing getFee and getFeeAndUpdate to fail.

3. **Uninitialized Parameters**: If adjustParams is not called before other functions, the contract may use default zero values for parameters (like m1, b1, etc.), leading to incorrect fee calculations. However, since adjustParams is onlyOwner, it's up to the owner to initialize correctly.

4. **Precision Loss in Fee Calculation**: The averaging of feePre and feePost uses integer division, which truncates, leading to possible loss of precision. This might result in slightly lower fees than intended.

5. **Dependence on Trusted Whitelist**: The contract relies on the whitelistAddress to call certain functions correctly. If the whitelist is malicious or compromised, it could set incorrect fee caps or manipulate fees. However, this is a design choice rather than a code vulnerability.

6. **Incorrect Parameter Settings**: The owner can set parameters that cause unintended fee calculations, such as negative slopes leading to negative fees. However, the _min function caps fees at 1e18, but if b2Negative or b3Negative are set such that the fee becomes negative, the _min function would return 0 (since the result would underflow). Wait, in the code, when using SafeMath, if b2Negative is true, the code does m2.mul(percentBacked).div(1e18).sub(b2). However, if b2 is larger than m2.mul(percentBacked).div(1e18), this subtraction would underflow, causing a revert. So if the parameters are set such that the fee could be negative, the function would revert. But the code has a require(percentBacked <= 1e18), which is checked after percentBacked is calculated. Wait, no: percentBacked is computed as _collateralVCBalance.mul(1e18).div(_totalVCBalance). Since _collateralVCBalance can be up to _totalVCBalance (if _totalVCBalance is not zero), percentBacked is <= 1e18. So when using the segments:

In the first segment (<= cutoff1), the fee is m1 * percentBacked / 1e18 + b1. Since m1 and b1 can be set by the owner, this could be a value exceeding 1e18, but then the _min caps it at 1e18. Similarly for other segments. However, in the second and third segments, if b2Negative is true, the code subtracts b2. But if m2 * percentBacked / 1e18 < b2, this would underflow. For example, if m2 is 0 and b2 is positive, then in the second segment, it would be 0 - b2, which underflows. This would cause the transaction to revert. So if the owner sets parameters that result in underflow in the fee calculation, the contract would become unusable. This is a vulnerability because the owner could set invalid parameters (e.g., m2=0, b2=1e18, b2Negative=true), leading to a revert when computing the fee. Therefore, the adjustParams function doesn't validate that the parameters avoid underflow in fee calculations.

So this is a critical vulnerability: the contract allows the owner to set parameters that can cause underflow in fee calculations, leading to reverts and denial of service.

Another example: suppose in adjustParams, m2 is set to a very small value, and b2 is larger than m2 * percentBacked / 1e18 for some percentBacked values. Then when the code subtracts b2, it underflows. Therefore, the adjustParams function should ensure that for the ranges in each segment, the fee calculation doesn't underflow. But currently, it does not. So this is a vulnerability.

So adding this to the list:

7. **Potential Underflow in Fee Calculation**: If the parameters (m2, b2, b2Negative or m3, b3, b3Negative) are set such that subtracting b2 or b3 from the product results in a negative value, the SafeMath subtraction will revert, causing the fee calculation to fail and potentially leading to denial of service. The adjustParams function does not validate that these parameters are set to prevent underflow in the respective segments.

Other possible issues:

- **Lack of Event Logging**: Important state changes (like adjusting parameters, setting addresses, etc.) do not emit events, making it difficult to track changes off-chain. However, this is not a vulnerability per se but a best practice issue.

- **Insufficient Validation in adjustParams**: The adjustParams function does not validate that m1, m2, m3 are non-zero or within reasonable ranges. This could lead to incorrect fee calculations if set improperly.

But focusing on actual vulnerabilities rather than best practices, the main ones are:

1. Single-use setAddresses leading to immutable whitelist.

2. Division by zero if decayTime is set to zero.

3. Potential underflow in fee calculation due to unsafe parameters.

4. Uninitialized parameters if adjustParams isn't called.

But the question is to list vulnerabilities without mitigation, so I need to list all the actual code vulnerabilities, not deployment issues.

So the final list would include:

- Division by zero in calculateDecayedFee when decayTime is zero.

- Single-use whitelist address that cannot be updated.

- Potential underflow in fee calculation (segments 2 and 3) due to unsafe parameters.

- Uninitialized parameters if adjustParams is not called before usage.

Wait, but uninitialized parameters are more of a deployment issue. The code doesn't enforce that adjustParams has been called. So if someone deploys the contract and doesn't call adjustParams, the variables (m1, b1, etc.) would be zero, leading to incorrect fee calculations. But the code allows it, so it's a vulnerability only if the contract is used without proper initialization.

So depending on the context, that's a vulnerability. For example, if the contract is deployed and functions are called before adjustParams, then _getFeePoint could return wrong fees.

But since adjustParams is onlyOwner, it's up to the owner to call it. However, there's no require in the functions that check if the parameters are initialized. For example, getFee and getFeeAndUpdate do not check if the parameters (like cutoff1, cutoff2) have been set. If adjustParams was never called, cutoff1 and cutoff2 would be zero. Then, in _getFeePoint, percentBacked is compared to cutoff1 (0) and cutoff2 (0). So all percentBacked values would go to the third segment (since cutoff1 is 0, cutoff2 is 0, and percentBacked is <=1e18). But in that case, the third segment's calculation would use m3 and b3, which are also zero. So fees would be zero. But maybe that's not intended. So the contract could be functioning with default zero parameters, leading to zero fees. If the system relies on fees being non-zero, this is a vulnerability. So the adjustParams should have a require that the parameters are set correctly, but in the current code, it's possible to not call adjustParams, leading to zero fees.

But adjustParams is external and onlyOwner, so the owner must call it. But if they forget, the contract is broken. So this is a vulnerability due to uninitialized state.

So summarizing, the vulnerabilities are:

1. **Single-Use setAddresses**: The whitelist address cannot be changed once set, leading to immutability and potential compromise.

2. **Division by Zero in Decay Calculation**: If decayTime is set to zero, calculateDecayedFee will revert due to division by zero.

3. **Underflow in Fee Calculation**: Improper parameter settings in adjustParams can lead to underflow in fee calculations, causing transactions to revert.

4. **Uninitialized Contract State**: If adjustParams is not called after deployment, the contract uses default zero parameters, leading to incorrect fee calculations.

5. **Precision Loss in Average Fee Calculation**: The average of feePre and feePost is truncated, potentially leading to lower fees than intended.

6. **Incorrect Parameter Validation in adjustParams**: The function allows setting parameters that can cause fee calculations to underflow or overflow (though SafeMath prevents overflow, underflow is possible in subtractions).

So these are the vulnerabilities I can identify.","```
None.
```",0.0
,,,,,,,,2,7,,,0,6,4,46,,,
