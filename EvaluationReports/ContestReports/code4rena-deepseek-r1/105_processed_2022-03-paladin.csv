nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
HolyPaladinToken.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";

/** @title Holy Paladin Token (hPAL) contract  */
/// @author Paladin
contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    /** @notice Seconds in a Week */
    uint256 public constant WEEK = 604800;
    /** @notice Seconds in a Month */
    uint256 public constant MONTH = 2629800;
    /** @notice 1e18 scale */
    uint256 public constant UNIT = 1e18;
    /** @notice Max BPS value (100%) */
    uint256 public constant MAX_BPS = 10000;
    /** @notice Seconds in a Year */
    uint256 public constant ONE_YEAR = 31557600;

    /** @notice  Period to wait before unstaking tokens  */
    uint256 public constant COOLDOWN_PERIOD = 864000; // 10 days
    /** @notice  Duration of the unstaking period
    After that period, unstaking cooldown is expired  */
    uint256 public constant UNSTAKE_PERIOD = 432000; // 5 days

    /** @notice Period to unlock/re-lock tokens without possibility of punishement   */
    uint256 public constant UNLOCK_DELAY = 1209600; // 2 weeks

    /** @notice Minimum duration of a Lock  */
    uint256 public constant MIN_LOCK_DURATION = 7889400; // 3 months
    /** @notice Maximum duration of a Lock  */
    uint256 public constant MAX_LOCK_DURATION = 63115200; // 2 years

    /** @notice Address of the PAL token  */
    IERC20 public immutable pal;

    /** @notice Struct of the Lock of an user  */
    struct UserLock {
        // Amount of locked balance
        uint128 amount; // safe because PAL max supply is 10M tokens
        // Start of the Lock
        uint48 startTimestamp;
        // Duration of the Lock
        uint48 duration;
        // BlockNumber for the Lock
        uint32 fromBlock; // because we want to search by block number
    }

    /** @notice Array of all user Locks, ordered from oldest to newest  */
    mapping(address => UserLock[]) public userLocks;

    /** @notice Struct trancking the total amount locked  */
    struct TotalLock {
        // Total locked Supply
        uint224 total;
        // BlockNumber for the last update
        uint32 fromBlock;
    }

    /** @notice Current Total locked Supply  */
    uint256 public currentTotalLocked;
    /** @notice List of TotalLocks, ordered from oldest to newest  */
    TotalLock[] public totalLocks;

    /** @notice User Cooldowns  */
    mapping(address => uint256) public cooldowns;

    /** @notice Checkpoints for users votes  */
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    /** @notice Checkpoints for users Delegates  */
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    /** @notice mapping tracking the Delegator for each Delegatee  */
    mapping(address => address) public delegates;

    /** @notice List of Vote checkpoints for each user  */
    mapping(address => Checkpoint[]) public checkpoints;

    /** @notice List of Delegate checkpoints for each user  */
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    /** @notice Ratio (in BPS) of locked balance applied of penalty for each week over lock end  */
    uint256 public kickRatioPerWeek = 1000;

    /** @notice Ratio of bonus votes applied on user locked balance  */
    uint256 public bonusLockVoteRatio = 0.5e18;

    /** @notice Allow emergency withdraws  */
    bool public emergency = false;

    /** @notice Address of the vault holding the PAL rewards  */
    address public immutable rewardsVault;

    /** @notice Global reward index  */
    uint256 public rewardIndex;
    /** @notice Timstamp of last update for global reward index  */
    uint256 public lastRewardUpdate;

    /** @notice Amount of rewards distriubted per second at the start  */
    uint256 public immutable startDropPerSecond;
    /** @notice Amount of rewards distributed per second at the end of the decrease duration  */
    uint256 public endDropPerSecond;
    /** @notice Current amount of rewards distriubted per second  */
    uint256 public currentDropPerSecond;
    /** @notice Timestamp of last update for currentDropPerSecond  */
    uint256 public lastDropUpdate;
    /** @notice Duration (in seconds) of the DropPerSecond decrease period  */
    uint256 public immutable dropDecreaseDuration;
    /** @notice Timestamp: start of the DropPerSecond decrease period  */
    uint256 public immutable startDropTimestamp;

    /** @notice Last reward index for each user  */
    mapping(address => uint256) public userRewardIndex;
    /** @notice Current amount of rewards claimable for the user  */
    mapping(address => uint256) public claimableRewards;
    /** @notice Timestamp of last update for user rewards  */
    mapping(address => uint256) public rewardsLastUpdate;

    /** @notice Base reward multiplier for lock  */
    uint256 public immutable baseLockBonusRatio;
    /** @notice Minimum reward multiplier for minimum lock duration  */
    uint256 public immutable minLockBonusRatio;
    /** @notice Maximum reward multiplier for maximum duration  */
    uint256 public immutable maxLockBonusRatio;

    /** @notice Last updated Bonus Ratio for rewards  */
    mapping(address => uint256) public userCurrentBonusRatio;
    /** @notice Value by which user Bonus Ratio decrease each second  */
    mapping(address => uint256) public userBonusRatioDecrease;

    /** @notice Error raised if contract is turned in emergency mode */
    error EmergencyBlock(); 

    // Event

    /** @notice Emitted when an user stake PAL in the contract */
    event Stake(address indexed user, uint256 amount);
    /** @notice Emitted when an user burns hPAL to withdraw PAL */
    event Unstake(address indexed user, uint256 amount);
    /** @notice Emitted when an user triggers the cooldown period */
    event Cooldown(address indexed user);
    /** @notice Emitted when an user creates or update its Lock */
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    /** @notice Emitted when an user exits the Lock */
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    /** @notice Emitted when an user is kicked out of the Lock */
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    /** @notice Emitted when an user claim the rewards */
    event ClaimRewards(address indexed user, uint256 amount);
    /** @notice Emitted when the delegate of an address changes */
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    /** @notice Emitted when the votes of a delegate is updated */
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    /** @notice Emitted when un user withdraw through the emergency method */
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        // Set the immutable variables
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        // Set all update timestamp as contract creation timestamp
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        // Start the reward distribution & DropPerSecond decrease
        startDropTimestamp = block.timestamp;
    }


    /**
     * @notice Deposits PAL & mints hPAL tokens
     * @param amount amount to stake
     * @return uint256 : amount of hPAL minted
     */
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    /**
     * @notice Updates the Cooldown for the caller
     */
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        // Set the current timestamp as start of the user cooldown
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    /**
     * @notice Burns hPAL & withdraws PAL
     * @param amount amount ot withdraw
     * @param receiver address to receive the withdrawn PAL
     * @return uint256 : amount withdrawn
     */
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    /**
     * @notice Locks hPAL for a given duration
     * @param amount amount of the hPAL balance to lock
     * @param duration duration of the Lock (in seconds)
     */
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            // If the user does not deelegate currently, automatically self-delegate
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    /**
     * @notice Increase the user current Lock duration (& restarts the Lock)
     * @param duration new duration for the Lock (in seconds)
     */
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current amount, and the new duration
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    /**
     * @notice Increase the amount of hPAL locked for the user
     * @param amount new amount of hPAL to be locked (in total)
     */
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        // Call the _lock method with the current duration, and the new amount
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    /**
     * @notice Removes the user Lock after expiration
     */
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    /**
     * @notice Removes an user Lock if too long after expiry, and applies a penalty
     * @param user address of the user to kick out of a Lock
     */
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        // Update user rewards before any change on their balance (staked and locked)
        // For both the user and the kicker
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    /**
     * @notice Staked PAL to get hPAL, and locks it for the given duration
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        // Stake the given amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // And then lock it
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    /**
     * @notice Stake more PAL into hPAL & add them to the current user Lock
     * @param amount amount of PAL to stake and lock
     * @param duration duration of the Lock (in seconds)
     * @return uint256 : amount of hPAL minted
     */
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        // Find the current Lock
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        // Stake the new amount
        uint256 stakedAmount = _stake(msg.sender, amount);
        // No need to update user rewards since it's done through the _stake() method
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        // Then update the lock with the new increased amount
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    /**
     * @notice Delegates the caller voting power to another address
     * @param delegatee address to delegate to
     */
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    /**
     * @notice Claim the given amount of rewards for the caller
     * @param amount amount ot claim
     */
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        // Cannot claim more than accrued rewards, but we can use a higher amount to claim all the rewards
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        // remove the claimed amount from the claimable mapping for the user, 
        // and transfer the PAL from the rewardsVault to the user
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    /**
     * @notice Updates the global Reward State for the contract
     */
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    /**
     * @notice Updates the given user Reward State
     * @param user address of the user to update
     */
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    // ---------------

    /**
     * @notice Estimates the new Cooldown for the receiver, based on sender & amount of transfer
     * @param sender address of the sender
     * @param receiver address fo the receiver
     * @param amount amount ot transfer
     * @return uint256 : new cooldown
     */
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    /**
     * @notice Get the total number of Locks for an user
     * @param user address of the user
     * @return uint256 : total number of Locks
     */
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    /**
     * @notice Get the current user Lock
     * @param user address of the user
     * @return UserLock : user Lock
     */
    function getUserLock(address user) external view returns(UserLock memory) {
        //If the contract is blocked (emergency mode)
        //Or if the user does not have a Lock yet
        //Return an empty lock
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    /**
     * @notice Get the user Lock at a given block (returns empty Lock if not existing / block number too old)
     * @param user address of the user
     * @param blockNumber block number
     * @return UserLock : user past Lock
     */
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    /**
     * @notice Get the total count of TotalLock
     * @return uint256 : total count
     */
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    /**
     * @notice Get the latest TotalLock
     * @return TotalLock : current TotalLock
     */
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); //If the contract is blocked (emergency mode), return an empty totalLocked
        return totalLocks[totalLocks.length - 1];
    }

    /**
     * @notice Get the TotalLock at a given block
     * @param blockNumber block number
     * @return TotalLock : past TotalLock
     */
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        // last checkpoint check
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    /**
     * @notice Get the user available balance (staked - locked)
     * @param user address of the user
     * @return uint256 : available balance
     */
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    /**
     * @notice Get all user balances
     * @param user address of the user
     * @return staked : staked balance
     * @return locked : locked balance
     * @return available : available balance (staked - locked)
     */
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        // If the contract was blocked (emergency mode) or
        // If the user has no Lock
        // then available == staked
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        // If a Lock exists
        // Then return
        // total staked balance
        // locked balance
        // available balance (staked - locked)
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    /**
     * @notice Get the estimated current amount of rewards claimable by the user
     * @param user address of the user
     * @return uint256 : estimated amount of rewards to claim
     */
    function estimateClaimableRewards(address user) external view returns(uint256) {
        // no rewards for address 0x0
        // & in case of emergency mode, show 0
        if(emergency || user == address(0)) return 0;
        // If the user rewards where updated on that block, then return the last updated value
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        // Get the user current claimable amount
        uint256 estimatedClaimableRewards = claimableRewards[user];
        // Get the last updated reward index
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            // If needed, update the reward index
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    /**
     * @notice Current number of vote checkpoints for the user
     * @param account address of the user
     * @return uint256 : number of checkpoints
     */
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    /**
     * @notice Get the user current voting power (with bonus voting power from the Lock)
     * @param user address of the user
     * @return uint256 : user current voting power
     */
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; //If emergency mode, do not show voting power

        uint256 nbCheckpoints = checkpoints[user].length;
        // current votes with delegation
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        // check if user has a lock
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        // and if there is a lock, and user self-delegate, add the bonus voting power 
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    /**
     * @notice Get the user voting power for a given block (with bonus voting power from the Lock)
     * @param user address of the user
     * @param blockNumber block number
     * @return uint256 : user past voting power
     */
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        // votes with delegation for the given block
        uint256 votes = _getPastVotes(user, blockNumber);


        // check if user has a lock at that block
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        // and if there is a lock, and user self-delegated, add the bonus voting power 
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    /**
     * @notice Get the user delegate at a given block
     * @param account address of the user
     * @param blockNumber block number
     * @return address : delegate
     */
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    // ----------------

    // Find the user available balance (staked - locked) => the balance that can be transfered
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    // Update dropPerSecond value
    function _updateDropPerSecond() internal returns (uint256){
        // If no more need for monthly updates => decrease duration is over
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            // Set the current DropPerSecond as the end value
            // Plus allows to be updated if the end value is later updated
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        // We calculate the new dropPerSecond value
        // We don't want to go under the endDropPerSecond
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        // Get the current total Supply
        uint256 currentTotalSupply = totalSupply();
        // and the seconds since the last update
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        // DropPerSeond without any multiplier => the base dropPerSecond for stakers
        // The multiplier for LockedBalance is applied later, accruing more rewards depending on the Lock.
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        // total base reward (without multiplier) to be distributed since last update
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         // calculate the ratio to add to the index
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    // Update global reward state internal
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; // Already updated for this block

        // Update (if needed) & get the current DropPerSecond
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        // Update the index
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        // Find the user last index & current balances
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                // calculate the base rewards for the user staked balance
                // (using avaialable balance to count the locked balance with the multiplier later in this function)
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    // and if an user has a lock, calculate the locked rewards
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    // using the locked balance, and the lock duration
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    // Check that the user's Lock is not empty
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            // Find the new multiplier for user:
                            // From the last Ratio, where we remove userBonusRatioDecrease for each second since last update
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                // Since the last update, bonus ratio decrease under 0
                                // We count the bonusRatioDecrease as the difference between the last Bonus Ratio and 0
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                // In the case this update is made far after the end of the lock, this method would mean
                                // the user could get a multiplier for longer than expected
                                // We count on the Kick logic to avoid that scenario
                            }

                            // and calculate the locking rewards based on the locked balance & 
                            // a ratio based on the rpevious one and the newly calculated one
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                // sum up the accrued rewards, and return it
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    // Update user reward state internal
    function _updateUserRewards(address user) internal {
        // Update the global reward state and get the latest index
        uint256 newIndex = _updateRewardState();

        // Called for minting & burning, but we don't want to update for address 0x0
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; // Already updated for this block

        // Update the user claimable rewards
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        // Store the new Bonus Ratio
        userCurrentBonusRatio[user] = newBonusRatio;
        
        // and set the current timestamp for last update, and the last used index for the user rewards
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    /** @dev Hook called before any transfer */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { //check must be skipped on minting
            // Only allow the balance that is unlocked to be transfered
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        // Update user rewards before any change on their balance (staked and locked)
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0 

        if(from != to) {
            // Update user rewards before any change on their balance (staked and locked)
            _updateUserRewards(to);
            // => we don't want a self-transfer to double count new claimable rewards
            // + no need to update the cooldown on a self-transfer

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        // If from transfer all of its balance, reset the cooldown to 0
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        // update delegation for the sender & the receiver if they delegate
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        // no checkpoints written
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        // last checkpoint check
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        // no checkpoint old enough
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        // last checkpoint check
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        // no checkpoint old enough
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        // no checkpoints written
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        // last checkpoint check
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        // no checkpoint old enough
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; // last checkpoint already checked
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                // Calculate the change in voting power, then write a new checkpoint
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        // write a new checkpoint for an user
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    // -----------------

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        // No need to update user rewards here since the _mint() method will trigger _beforeTokenTransfer()
        // Same for the Cooldown update, as it will be handled by _beforeTokenTransfer()    

        _mint(user, amount); //We mint hPAL 1:1 with PAL

        // Pull the PAL into this contract
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        // Check if user in inside the allowed period base on its cooldown
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        // No need to update user rewards here since the _burn() method will trigger _beforeTokenTransfer()

        // Can only unstake was is available, need to unlock before
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        // Burn the hPAL 1:1 with PAL
        _burn(user, burnAmount);

        // If all the balance is unstaked, cooldown reset is handled by _beforeTokenTransfer()

        // Then transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    // Get the new cooldown for an user receiving hPAL (mint or transfer),
    // based on receiver cooldown and sender cooldown
    // Inspired by stkAAVE cooldown system
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        // If receiver has no cooldown, no need to set a new one
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        // If last receiver cooldown is expired, set it back to 0
        if(receiverCooldown < minValidCooldown) return 0;

        // In case the given senderCooldown is 0 (sender has no cooldown, or minting)
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        // If the sender cooldown is better, we keep the receiver cooldown
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        // Default new cooldown, weighted average based on the amount and the previous balance
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            //User 1st Lock

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            // find the reward multiplier based on the user lock duration
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            // Update total locked supply
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            // Get the current user Lock
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            // Calculate the end of the user current lock
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                // User locked, and then unlocked
                // or user lock expired

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                // Update of the current Lock : increase amount or increase duration
                // or renew with the same parameters, but starting at the current timestamp
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                // If the method is called with INCREASE_AMOUNT, then we don't change the startTimestamp of the Lock

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            // If the duration is updated, re-calculate the multiplier for the Lock
            if(action != LockAction.INCREASE_AMOUNT){
                // find the reward multiplier based on the user lock duration
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            // Update total locked supply
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); //Never supposed to happen, but security check
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user current Lock
        // And calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Set the user Lock as an empty Lock
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        // Get the user to kick current Lock
        // and calculate the end of the Lock
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        // Remove amount from total locked supply
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        // Set an empty Lock for the user
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        // Remove the bonus multiplier
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        // Calculate the penalty for the Lock
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        // Send penalties to the kicker
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        // Move delegation from the old delegate to the given delegate
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        // update the the Delegate chekpoint for the delegatee
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        // and write the checkpoints for Votes
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    /**
     * @notice Allow to withdraw with override of the lock & cooldown in case of emergency
     * @param amount amount to withdraw
     * @param receiver address to receive the withdrawn funds
     * @return uint256 : amount withdrawn
     */
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            // Check if the user has a Lock, and if so, fetch it
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            // To remove the Lock and update the total locked
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        // Get the user hPAL balance, and burn & send the given amount, or the user balance if the amount is bigger
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        // Transfer the PAL to the user
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    // Utils

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    // Admin methods

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    /**
     * @notice Updates the ratio of penalty applied for each week after boost expiry
     * @param newKickRatioPerWeek new kick ratio (in BPS)
     */
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    /**
     * @notice Triggers the emergency mode on the smart contract (admin method)
     * @param trigger True to set the emergency mode
     */
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    /**
     * @notice Updates the EndDropPerSecond for the rewards distribution (after the 2 year decrease period) (admin method)
     * @param newEndDropPerSecond new amount of PAL to distribute per second
     */
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",12522.0,1437.0,"[H-01]DropPerSecondis not updated homogeneously, the rewards emission can be much higher than expected in some cases
In the function `_updateDropPerSecond()`, when current time is`lastDropUpdate + (2*MONTH-1)`:
`nbMonthEllapsed`will be round down to1, while it's actually 1.99 months passed, but because of precision loss, the smart contract will believe it's only 1 month elapsed, as a result,`DropPerSecond`will only decrease by 1 *`dropDecreasePerMonth`.
In another word, due to the precision loss in calculating the number of months elapsed, for each`_updateDropPerSecond()`there can be a short of up to1 * `dropDecreasePerMonth`for the decrease of emission rate.
At the very edge case, if all the updates happened just like the scenario above. by the end of thedropDecreaseDuration, it will drop only12 * dropDecreasePerMonthin total, while it's expected to be24 * dropDecreasePerMonth.
So only half of(startDropPerSecond - endDropPerSecond)is actually decreased. And the last timeupdateDropPerSecondis called,DropPerSecondwill suddenly drop toendDropPerSecond.[H-02] System could be wrapped and made useless without contract whitelisting
Anyone could create a contract or a contract factory ""PAL Locker"" with a fonction to deposit PAL tokens through a contract, lock them and delegate the voting power to the contract owner. Then, the ownership of this contract could be sold. By doing so, locked hPAL would be made liquid and transferrable again. This would eventually break the overall system of hPAL, where the idea is that you have to lock them to make them non liquid to get a boosted voting power and reward rate.
[M-01]HolyPaladinToken.solusesERC20token with a highly unsafe pattern
InHolyPaladinToken.solit importsERC20.solwith some changes from the original Open Zeppelin standard. One change is that the`transferFrom()`function does not follow the Checks Effect and Interactions safety pattern to safely make external calls to other contracts. All checks should be handled first, then any effects/state updates, followed by the external call to prevent reentrancy attacks. Currently the`transferFrom()`function inERC20.solused byHolyPaladinToken.solcalls_transfer()first and then updates thesenderallowance which is highly unsafe. The openZeppelinER20.solcontract which is the industry standard first updates thesenderallowance before calling_transfer. The external call should always be done last to avoid any double spending bugs or reentrancy attacks.
[M-02] Incorrect number of seconds in`ONE_YEAR`variable
InHolyPaladinToken.soltheONE_YEARvariable claims that there are31557600seconds in a year when this is incorrect. TheONE_YEARvariable is used in the`getCurrentVotes()`function as well as thegetPastVotes()function so it is vital that the correct time in seconds be used as it can effect users negatively.
[M-03] Users at`UNSTAKE_PERIOD`can assist other users in unstaking tokens.
In the `_getNewReceiverCooldown` function, `_senderCooldown` is Day 15 and receiverCooldown is Day 0, so the latest cooldown of user A is (100 * Day 15 + 200 * Day 0)/(100+200) = Day 5.[M-04]cooldownis set to 0 when the user sends all tokens to himself
In the `_beforeTokenTransfer` function, cooldowns will be set to 0 when the user transfers all tokens to himself.[M-05] Past state query results are susceptible to manipulation due to multiple states with same block number[M-09] Function`cooldown()`is not protected when protocol in emergency modeIts behavior is not consistent with the other major functions defined.
[M-13] Users Can Bypass Emergency Restrictions on`updateUserRewardState()`

[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards
Paladin protocol allows users to increase the amount or duration of their lock while it is stil active. Increasing the amount of an active lock should only increase the total locked amount and it shouldn't make any changes to the associated bonus ratios as the duration remains unchanged.",10.0,"pragma solidity ^0.8.10;

import ""./open-zeppelin/ERC20.sol"";
import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";
import ""./open-zeppelin/utils/Math.sol"";



contract HolyPaladinToken is ERC20(""Holy Paladin Token"", ""hPAL""), Ownable {
    using SafeERC20 for IERC20;


    
    uint256 public constant WEEK = 604800;
    
    uint256 public constant MONTH = 2629800;
    
    uint256 public constant UNIT = 1e18;
    
    uint256 public constant MAX_BPS = 10000;
    
    uint256 public constant ONE_YEAR = 31557600;

    
    uint256 public constant COOLDOWN_PERIOD = 864000; 
    
    uint256 public constant UNSTAKE_PERIOD = 432000; 

    
    uint256 public constant UNLOCK_DELAY = 1209600; 

    
    uint256 public constant MIN_LOCK_DURATION = 7889400; 
    
    uint256 public constant MAX_LOCK_DURATION = 63115200; 

    
    IERC20 public immutable pal;

    
    struct UserLock {
        
        uint128 amount; 
        
        uint48 startTimestamp;
        
        uint48 duration;
        
        uint32 fromBlock; 
    }

    
    mapping(address => UserLock[]) public userLocks;

    
    struct TotalLock {
        
        uint224 total;
        
        uint32 fromBlock;
    }

    
    uint256 public currentTotalLocked;
    
    TotalLock[] public totalLocks;

    
    mapping(address => uint256) public cooldowns;

    
    struct Checkpoint {
        uint32 fromBlock;
        uint224 votes;
    }

    
    struct DelegateCheckpoint {
        uint32 fromBlock;
        address delegate;
    }

    
    mapping(address => address) public delegates;

    
    mapping(address => Checkpoint[]) public checkpoints;

    
    mapping(address => DelegateCheckpoint[]) public delegateCheckpoints;

    
    uint256 public kickRatioPerWeek = 1000;

    
    uint256 public bonusLockVoteRatio = 0.5e18;

    
    bool public emergency = false;

    
    address public immutable rewardsVault;

    
    uint256 public rewardIndex;
    
    uint256 public lastRewardUpdate;

    
    uint256 public immutable startDropPerSecond;
    
    uint256 public endDropPerSecond;
    
    uint256 public currentDropPerSecond;
    
    uint256 public lastDropUpdate;
    
    uint256 public immutable dropDecreaseDuration;
    
    uint256 public immutable startDropTimestamp;

    
    mapping(address => uint256) public userRewardIndex;
    
    mapping(address => uint256) public claimableRewards;
    
    mapping(address => uint256) public rewardsLastUpdate;

    
    uint256 public immutable baseLockBonusRatio;
    
    uint256 public immutable minLockBonusRatio;
    
    uint256 public immutable maxLockBonusRatio;

    
    mapping(address => uint256) public userCurrentBonusRatio;
    
    mapping(address => uint256) public userBonusRatioDecrease;

    
    error EmergencyBlock(); 

    

    
    event Stake(address indexed user, uint256 amount);
    
    event Unstake(address indexed user, uint256 amount);
    
    event Cooldown(address indexed user);
    
    event Lock(address indexed user, uint256 amount, uint256 indexed startTimestamp, uint256 indexed duration, uint256 totalLocked);
    
    event Unlock(address indexed user, uint256 amount, uint256 totalLocked);
    
    event Kick(address indexed user, address indexed kicker, uint256 amount, uint256 penalty, uint256 totalLocked);
    
    event ClaimRewards(address indexed user, uint256 amount);
    
    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    
    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);
    
    event EmergencyUnstake(address indexed user, uint256 amount);

    constructor(
        address palToken,
        address _admin,
        address _rewardsVault,
        uint256 _startDropPerSecond,
        uint256 _endDropPerSecond,
        uint256 _dropDecreaseDuration,
        uint256 _baseLockBonusRatio,
        uint256 _minLockBonusRatio,
        uint256 _maxLockBonusRatio
    ){
        require(palToken != address(0));
        require(_admin != address(0));

        pal = IERC20(palToken);

        transferOwnership(_admin);

        totalLocks.push(TotalLock(
            0,
            safe32(block.number)
        ));
        
        rewardsVault = _rewardsVault;

        startDropPerSecond = _startDropPerSecond;
        endDropPerSecond = _endDropPerSecond;

        currentDropPerSecond = _startDropPerSecond;

        dropDecreaseDuration = _dropDecreaseDuration;

        baseLockBonusRatio = _baseLockBonusRatio;
        minLockBonusRatio = _minLockBonusRatio;
        maxLockBonusRatio = _maxLockBonusRatio;

        
        lastRewardUpdate = block.timestamp;
        lastDropUpdate = block.timestamp;
        
        startDropTimestamp = block.timestamp;
    }


    
    function stake(uint256 amount) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _stake(msg.sender, amount);
    }

    
    function cooldown() external {
        require(balanceOf(msg.sender) > 0, ""hPAL: No balance"");

        
        cooldowns[msg.sender] = block.timestamp;

        emit Cooldown(msg.sender);
    }

    
    function unstake(uint256 amount, address receiver) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        return _unstake(msg.sender, amount, receiver);
    }

    
    function lock(uint256 amount, uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        
        _updateUserRewards(msg.sender);
        if(delegates[msg.sender] == address(0)){
            
            _delegate(msg.sender, msg.sender);
        }
        _lock(msg.sender, amount, duration, LockAction.LOCK);
    }

    
    function increaseLockDuration(uint256 duration) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        
        _updateUserRewards(msg.sender);
        
        _lock(msg.sender, currentUserLock.amount, duration, LockAction.INCREASE_DURATION);
    }

    
    function increaseLock(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];
        
        _updateUserRewards(msg.sender);
        
        _lock(msg.sender, amount, currentUserLock.duration, LockAction.INCREASE_AMOUNT);
    }

    
    function unlock() external {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        _updateUserRewards(msg.sender);
        _unlock(msg.sender);
    }

    
    function kick(address user) external {
        if(emergency) revert EmergencyBlock();
        require(msg.sender != user, ""hPAL: cannot kick yourself"");
        
        
        _updateUserRewards(user);
        _updateUserRewards(msg.sender);
        _kick(user, msg.sender);
    }

    
    function stakeAndLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        
        uint256 stakedAmount = _stake(msg.sender, amount);
        
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        
        _lock(msg.sender, amount, duration, LockAction.LOCK);
        return stakedAmount;
    }

    
    function stakeAndIncreaseLock(uint256 amount, uint256 duration) external returns(uint256) {
        if(emergency) revert EmergencyBlock();
        require(userLocks[msg.sender].length != 0, ""hPAL: No Lock"");
        
        uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
        uint256 previousLockAmount = userLocks[msg.sender][currentUserLockIndex].amount;
        
        uint256 stakedAmount = _stake(msg.sender, amount);
        
        if(delegates[msg.sender] == address(0)){
            _delegate(msg.sender, msg.sender);
        }
        
        if(duration == userLocks[msg.sender][currentUserLockIndex].duration) {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.INCREASE_AMOUNT);
        } else {
            _lock(msg.sender, previousLockAmount + amount, duration, LockAction.LOCK);
        }
        return stakedAmount;
    }

    
    function delegate(address delegatee) external virtual {
        if(emergency) revert EmergencyBlock();
        return _delegate(_msgSender(), delegatee);
    }

    
    function claim(uint256 amount) external {
        if(emergency) revert EmergencyBlock();
        
        _updateUserRewards(msg.sender);

        require(amount > 0, ""hPAL: incorrect amount"");

        
        uint256 claimAmount = amount < claimableRewards[msg.sender] ? amount : claimableRewards[msg.sender];

        
        
        claimableRewards[msg.sender] -= claimAmount;

        pal.safeTransferFrom(rewardsVault, msg.sender, claimAmount);

        emit ClaimRewards(msg.sender, claimAmount);
    }

    
    function updateRewardState() external {
        if(emergency) revert EmergencyBlock();
        _updateRewardState();
    }

    
    function updateUserRewardState(address user) external {
        if(emergency) revert EmergencyBlock();
        _updateUserRewards(user);
    }

    

    
    function getNewReceiverCooldown(address sender, address receiver, uint256 amount) external view returns(uint256) {
        uint256 senderCooldown = cooldowns[sender];
        uint256 receiverBalance = balanceOf(receiver);

        return _getNewReceiverCooldown(
            senderCooldown,
            amount,
            receiver,
            receiverBalance
        );
    }

    
    function getUserLockCount(address user) external view returns(uint256) {
        return userLocks[user].length;
    }

    
    function getUserLock(address user) external view returns(UserLock memory) {
        
        
        
        if(emergency || userLocks[user].length == 0) return UserLock(0, 0, 0, 0);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return userLocks[user][lastUserLockIndex];
    }

    
    function getUserPastLock(address user, uint256 blockNumber) external view returns(UserLock memory) {
        return _getPastLock(user, blockNumber);
    }

    
    function getTotalLockLength() external view returns(uint256){
        return totalLocks.length;
    }

    
    function getCurrentTotalLock() external view returns(TotalLock memory){
        if(emergency) return TotalLock(0, 0); 
        return totalLocks[totalLocks.length - 1];
    }

    
    function getPastTotalLock(uint256 blockNumber) external view returns(TotalLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        TotalLock memory emptyLock = TotalLock(
            0,
            0
        );

        uint256 nbCheckpoints = totalLocks.length;

        
        if (totalLocks[nbCheckpoints - 1].fromBlock <= blockNumber) {
            return totalLocks[nbCheckpoints - 1];
        }

        
        if (totalLocks[0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (totalLocks[mid].fromBlock == blockNumber) {
                return totalLocks[mid];
            }
            if (totalLocks[mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : totalLocks[high - 1];
    }

    
    function availableBalanceOf(address user) external view returns(uint256) {
        return _availableBalanceOf(user);
    }

    
    function allBalancesOf(address user) external view returns(
        uint256 staked,
        uint256 locked,
        uint256 available
    ) {
        
        
        
        if(emergency || userLocks[user].length == 0) {
            return(
                balanceOf(user),
                0,
                balanceOf(user)
            );
        }
        
        
        
        
        
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return(
            balanceOf(user),
            uint256(userLocks[user][lastUserLockIndex].amount),
            balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount)
        );
    }

    
    function estimateClaimableRewards(address user) external view returns(uint256) {
        
        
        if(emergency || user == address(0)) return 0;
        
        if(rewardsLastUpdate[user] == block.timestamp) return claimableRewards[user];

        
        uint256 estimatedClaimableRewards = claimableRewards[user];
        
        uint256 currentRewardIndex = rewardIndex;

        if(lastRewardUpdate < block.timestamp){
            
            currentRewardIndex = _getNewIndex(currentDropPerSecond);
        }

        (uint256 accruedRewards,) = _getUserAccruedRewards(user, currentRewardIndex);

        estimatedClaimableRewards += accruedRewards;

        return estimatedClaimableRewards;
    }

    
    function numCheckpoints(address account) external view virtual returns (uint256){
        return checkpoints[account].length;
    }

    
    function getCurrentVotes(address user) external view returns (uint256) {
        if(emergency) return 0; 

        uint256 nbCheckpoints = checkpoints[user].length;
        
        uint256 currentVotes = nbCheckpoints == 0 ? 0 : checkpoints[user][nbCheckpoints - 1].votes;

        
        uint256 nbLocks = userLocks[user].length;

        if(nbLocks == 0) return currentVotes;

        
        uint256 lockAmount = userLocks[user][nbLocks - 1].amount;
        uint256 bonusVotes = delegates[user] == user && userLocks[user][nbLocks - 1].duration >= ONE_YEAR ? (lockAmount * bonusLockVoteRatio) / UNIT : 0;

        return currentVotes + bonusVotes;
    }

    
    function getPastVotes(address user, uint256 blockNumber) external view returns(uint256) {
        
        uint256 votes = _getPastVotes(user, blockNumber);


        
        UserLock memory pastLock = _getPastLock(user, blockNumber);
        
        uint256 bonusVotes = getPastDelegate(user, blockNumber) == user && pastLock.duration >= ONE_YEAR ? (pastLock.amount * bonusLockVoteRatio) / UNIT : 0;

        return votes + bonusVotes;
    }

    
    function getPastDelegate(address account, uint256 blockNumber)
        public
        view
        returns (address)
    {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) {
            return address(0);
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    

    
    function _availableBalanceOf(address user) internal view returns(uint256) {
        if(userLocks[user].length == 0) return balanceOf(user);
        uint256 lastUserLockIndex = userLocks[user].length - 1;
        return balanceOf(user) - uint256(userLocks[user][lastUserLockIndex].amount);
    }

    
    function _updateDropPerSecond() internal returns (uint256){
        
        if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {
            
            
            if(currentDropPerSecond != endDropPerSecond) {
                currentDropPerSecond = endDropPerSecond;
                lastDropUpdate = block.timestamp;
            }

            return endDropPerSecond;
        }

        if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; 

        uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);
        uint256 nbMonthEllapsed = (block.timestamp - lastDropUpdate) / MONTH;

        uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed;

        
        
        uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;
    
        currentDropPerSecond = newDropPerSecond;
        lastDropUpdate = block.timestamp;

        return newDropPerSecond;
    }

    function _getNewIndex(uint256 _currentDropPerSecond) internal view returns (uint256){
        
        uint256 currentTotalSupply = totalSupply();
        
        uint256 ellapsedTime = block.timestamp - lastRewardUpdate;

        
        
        uint256 baseDropPerSecond = (_currentDropPerSecond * UNIT) / maxLockBonusRatio;

        
        uint256 accruedBaseAmount = ellapsedTime * baseDropPerSecond;

         
        uint256 ratio = currentTotalSupply > 0 ? (accruedBaseAmount * UNIT) / currentTotalSupply : 0;

        return rewardIndex + ratio;
    }

    
    function _updateRewardState() internal returns (uint256){
        if(lastRewardUpdate == block.timestamp) return rewardIndex; 

        
        uint256 _currentDropPerSecond = _updateDropPerSecond();

        
        uint256 newIndex = _getNewIndex(_currentDropPerSecond);
        rewardIndex = newIndex;
        lastRewardUpdate = block.timestamp;

        return newIndex;
    }

    struct UserLockRewardVars {
        uint256 lastUserLockIndex;
        uint256 previousBonusRatio;
        uint256 userRatioDecrease;
        uint256 bonusRatioDecrease;
        uint256 periodBonusRatio;
    }

    function _getUserAccruedRewards(
        address user,
        uint256 currentRewardsIndex
    ) internal view returns(
        uint256 accruedRewards,
        uint256 newBonusRatio
    ) {
        
        uint256 userLastIndex = userRewardIndex[user];
        uint256 userStakedBalance = _availableBalanceOf(user);
        uint256 userLockedBalance = 0;

        if(userLastIndex != currentRewardsIndex){

            if(balanceOf(user) > 0){
                
                
                uint256 indexDiff = currentRewardsIndex - userLastIndex;

                uint256 stakingRewards = (userStakedBalance * indexDiff) / UNIT;

                uint256 lockingRewards = 0;

                if(userLocks[user].length > 0){
                    UserLockRewardVars memory vars;

                    
                    vars.lastUserLockIndex = userLocks[user].length - 1;

                    
                    userLockedBalance = uint256(userLocks[user][vars.lastUserLockIndex].amount);

                    
                    if(userLockedBalance > 0 && userLocks[user][vars.lastUserLockIndex].duration != 0){
                        vars.previousBonusRatio = userCurrentBonusRatio[user];

                        if(vars.previousBonusRatio > 0){
                            vars.userRatioDecrease = userBonusRatioDecrease[user];
                            
                            
                            vars.bonusRatioDecrease = (block.timestamp - rewardsLastUpdate[user]) * vars.userRatioDecrease;
                            
                            newBonusRatio = vars.bonusRatioDecrease >= vars.previousBonusRatio ? 0 : vars.previousBonusRatio - vars.bonusRatioDecrease;

                            if(vars.bonusRatioDecrease >= vars.previousBonusRatio){
                                
                                
                                vars.bonusRatioDecrease = vars.previousBonusRatio;
                                
                                
                                
                            }

                            
                            
                            vars.periodBonusRatio = newBonusRatio + ((vars.userRatioDecrease + vars.bonusRatioDecrease) / 2);
                            lockingRewards = (userLockedBalance * ((indexDiff * vars.periodBonusRatio) / UNIT)) / UNIT;
                        }
                    }

                }
                
                accruedRewards = stakingRewards + lockingRewards;
            }
        }
    }

    
    function _updateUserRewards(address user) internal {
        
        uint256 newIndex = _updateRewardState();

        
        if(user == address(0)) return;

        if(rewardsLastUpdate[user] == block.timestamp) return; 

        
        (uint256 accruedRewards, uint256 newBonusRatio) = _getUserAccruedRewards(user, newIndex);
        claimableRewards[user] += accruedRewards;
        
        userCurrentBonusRatio[user] = newBonusRatio;
        
        
        rewardsLastUpdate[user] = block.timestamp;
        userRewardIndex[user] = newIndex;

    }

    
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        if(from != address(0)) { 
            
            require(amount <= _availableBalanceOf(from), ""hPAL: Available balance too low"");
        }

        
        _updateUserRewards(from);

        uint256 fromCooldown = cooldowns[from]; 

        if(from != to) {
            
            _updateUserRewards(to);
            
            

            uint256 previousToBalance = balanceOf(to);
            cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);
        }

        
        uint256 previousFromBalance = balanceOf(from);
        if(previousFromBalance == amount && fromCooldown != 0) {
            cooldowns[from] = 0;
        }
    }

    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal virtual override {
        
        _moveDelegates(delegates[from], delegates[to], amount);
    }

    function _getPastLock(address account, uint256 blockNumber) internal view returns(UserLock memory) {
        require(
            blockNumber < block.number,
            ""hPAL: invalid blockNumber""
        );

        UserLock memory emptyLock = UserLock(
            0,
            0,
            0,
            0
        );

        
        uint256 nbCheckpoints = userLocks[account].length;
        if (nbCheckpoints == 0) return emptyLock;

        
        if (userLocks[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return userLocks[account][nbCheckpoints - 1];
        }

        
        if (userLocks[account][0].fromBlock > blockNumber) {
            return emptyLock;
        }

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (userLocks[account][mid].fromBlock == blockNumber) {
                return userLocks[account][mid];
            }
            if (userLocks[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? emptyLock : userLocks[account][high - 1];
    }

    function _getPastVotes(address account, uint256 blockNumber) internal view returns (uint256){
        require( blockNumber < block.number, ""hPAL: invalid blockNumber"");

        
        uint256 nbCheckpoints = checkpoints[account].length;
        if (nbCheckpoints == 0) return 0;

        
        if (checkpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return checkpoints[account][nbCheckpoints - 1].votes;
        }

        
        if (checkpoints[account][0].fromBlock > blockNumber) return 0;

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (checkpoints[account][mid].fromBlock == blockNumber) {
                return checkpoints[account][mid].votes;
            }
            if (checkpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? 0 : checkpoints[account][high - 1].votes;
    }

    function _getPastDelegate(address account, uint256 blockNumber) internal view returns (address) {
        require(blockNumber < block.number, ""hPAL: invalid blockNumber"");

        
        uint256 nbCheckpoints = delegateCheckpoints[account].length;
        if (nbCheckpoints == 0) return address(0);

        
        if (delegateCheckpoints[account][nbCheckpoints - 1].fromBlock <= blockNumber) {
            return delegateCheckpoints[account][nbCheckpoints - 1].delegate;
        }

        
        if (delegateCheckpoints[account][0].fromBlock > blockNumber) return address(0);

        uint256 high = nbCheckpoints - 1; 
        uint256 low = 0;
        uint256 mid;
        while (low < high) {
            mid = Math.average(low, high);
            if (delegateCheckpoints[account][mid].fromBlock == blockNumber) {
                return delegateCheckpoints[account][mid].delegate;
            }
            if (delegateCheckpoints[account][mid].fromBlock > blockNumber) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        return high == 0 ? address(0) : delegateCheckpoints[account][high - 1].delegate;
    }

    function _moveDelegates(address from, address to, uint256 amount) internal {
        if (from != to && amount > 0) {
            if (from != address(0)) {
                
                uint256 nbCheckpoints = checkpoints[from].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[from][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes - amount;
                _writeCheckpoint(from, newVotes);
                emit DelegateVotesChanged(from, oldVotes, newVotes);
            }

            if (to != address(0)) {
                
                uint256 nbCheckpoints = checkpoints[to].length;
                uint256 oldVotes = nbCheckpoints == 0 ? 0 : checkpoints[to][nbCheckpoints - 1].votes;
                uint256 newVotes = oldVotes + amount;
                _writeCheckpoint(to, newVotes);
                emit DelegateVotesChanged(to, oldVotes, newVotes);
            }
        }
    }

    function _writeCheckpoint(address delegatee, uint256 newVotes) internal {
        
        uint pos = checkpoints[delegatee].length;

        if (pos > 0 && checkpoints[delegatee][pos - 1].fromBlock == block.number) {
            checkpoints[delegatee][pos - 1].votes = safe224(newVotes);
        } else {
            uint32 blockNumber = safe32(block.number);
            checkpoints[delegatee].push(Checkpoint(blockNumber, safe224(newVotes)));
        }
    }

    

    function _stake(address user, uint256 amount) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");

        
        

        _mint(user, amount); 

        
        pal.safeTransferFrom(user, address(this), amount);

        emit Stake(user, amount);

        return amount;
    }

    function _unstake(address user, uint256 amount, address receiver) internal returns(uint256) {
        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        
        uint256 userCooldown = cooldowns[user];
        require(block.timestamp > (userCooldown + COOLDOWN_PERIOD), ""hPAL: Insufficient cooldown"");
        require(block.timestamp - (userCooldown + COOLDOWN_PERIOD) <= UNSTAKE_PERIOD, ""hPAL: unstake period expired"");

        

        
        uint256 userAvailableBalance = _availableBalanceOf(user);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        
        _burn(user, burnAmount);

        

        
        pal.safeTransfer(receiver, burnAmount);

        emit Unstake(user, burnAmount);

        return burnAmount;
    }

    
    
    
    function _getNewReceiverCooldown(
        uint256 senderCooldown,
        uint256 amount,
        address receiver,
        uint256 receiverBalance
    ) internal view returns(uint256) {
        uint256 receiverCooldown = cooldowns[receiver];

        
        if(receiverCooldown == 0) return 0;

        uint256 minValidCooldown = block.timestamp - (COOLDOWN_PERIOD + UNSTAKE_PERIOD);

        
        if(receiverCooldown < minValidCooldown) return 0;

        
        uint256 _senderCooldown = senderCooldown < minValidCooldown ? block.timestamp : senderCooldown;

        
        if(_senderCooldown < receiverCooldown) return receiverCooldown;

        
        return ((amount * _senderCooldown) + (receiverBalance * receiverCooldown)) / (amount + receiverBalance);

    }

    enum LockAction { LOCK, INCREASE_AMOUNT, INCREASE_DURATION }

    function _lock(address user, uint256 amount, uint256 duration, LockAction action) internal {
        require(user != address(0)); 
        require(amount != 0, ""hPAL: Null amount"");
        uint256 userBalance = balanceOf(user);
        require(amount <= userBalance, ""hPAL: Amount over balance"");
        require(duration >= MIN_LOCK_DURATION, ""hPAL: Lock duration under min"");
        require(duration <= MAX_LOCK_DURATION, ""hPAL: Lock duration over max"");

        if(userLocks[user].length == 0){
            

            userLocks[user].push(UserLock(
                safe128(amount),
                safe48(block.timestamp),
                safe48(duration),
                safe32(block.number)
            ));

            
            uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
            uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

            userCurrentBonusRatio[user] = userLockBonusRatio;
            userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;

            
            currentTotalLocked += amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            emit Lock(user, amount, block.timestamp, duration, currentTotalLocked);
        } 
        else {
            
            uint256 currentUserLockIndex = userLocks[user].length - 1;
            UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
            
            uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

            uint256 startTimestamp = block.timestamp;

            if(currentUserLock.amount == 0 || userCurrentLockEnd < block.timestamp) { 
                
                

                userLocks[user].push(UserLock(
                    safe128(amount),
                    safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));
            }
            else {
                
                
                require(amount >=  currentUserLock.amount,""hPAL: smaller amount"");
                require(duration >=  currentUserLock.duration,""hPAL: smaller duration"");

                

                userLocks[user].push(UserLock(
                    safe128(amount),
                    action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : safe48(startTimestamp),
                    safe48(duration),
                    safe32(block.number)
                ));

                startTimestamp = action == LockAction.INCREASE_AMOUNT ? currentUserLock.startTimestamp : startTimestamp;
            }

            
            if(action != LockAction.INCREASE_AMOUNT){
                
                uint256 durationRatio = ((duration - MIN_LOCK_DURATION) * UNIT) / (MAX_LOCK_DURATION - MIN_LOCK_DURATION);
                uint256 userLockBonusRatio = minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT);

                userCurrentBonusRatio[user] = userLockBonusRatio;
                userBonusRatioDecrease[user] = (userLockBonusRatio - baseLockBonusRatio) / duration;
            }
            
            
            if(amount != currentUserLock.amount){

                if(currentUserLock.amount != 0) currentTotalLocked -= currentUserLock.amount;
                
                currentTotalLocked += amount;
                totalLocks.push(TotalLock(
                    safe224(currentTotalLocked),
                    safe32(block.number)
                ));
            }

            emit Lock(user, amount, startTimestamp, duration, currentTotalLocked);
        }
    }

    function _unlock(address user) internal {
        require(user != address(0)); 
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        
        
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        emit Unlock(user, currentUserLock.amount, currentTotalLocked);
    }

    function _kick(address user, address kicker) internal {
        require(user != address(0) && kicker != address(0), ""hPAL: Address Zero"");
        require(userLocks[user].length > 0, ""hPAL: No Lock"");

        
        
        uint256 currentUserLockIndex = userLocks[user].length - 1;
        UserLock storage currentUserLock = userLocks[user][currentUserLockIndex];
        uint256 userCurrentLockEnd = currentUserLock.startTimestamp + currentUserLock.duration;

        require(block.timestamp > userCurrentLockEnd, ""hPAL: Not expired"");
        require(currentUserLock.amount > 0, ""hPAL: No Lock"");

        require(block.timestamp > userCurrentLockEnd + UNLOCK_DELAY, ""hPAL: Not kickable"");

        
        currentTotalLocked -= currentUserLock.amount;
        totalLocks.push(TotalLock(
            safe224(currentTotalLocked),
            safe32(block.number)
        ));

        
        userLocks[user].push(UserLock(
            safe128(0),
            safe48(block.timestamp),
            safe48(0),
            safe32(block.number)
        ));

        
        userCurrentBonusRatio[user] = 0;
        userBonusRatioDecrease[user] = 0;

        
        uint256 nbWeeksOverLockTime = (block.timestamp - userCurrentLockEnd) / WEEK;
        uint256 penaltyPercent = nbWeeksOverLockTime * kickRatioPerWeek;
        uint256 penaltyAmount = penaltyPercent >= MAX_BPS ? 
            currentUserLock.amount : 
            (currentUserLock.amount * penaltyPercent) / MAX_BPS;

        
        _transfer(user, kicker, penaltyAmount);

        emit Kick(user, kicker, currentUserLock.amount, penaltyAmount, currentTotalLocked);
    }

    function _delegate(address delegator, address delegatee) internal {
        
        address oldDelegatee = delegates[delegator];
        uint256 delegatorBalance = balanceOf(delegator);
        delegates[delegator] = delegatee;

        
        delegateCheckpoints[delegator].push(DelegateCheckpoint(safe32(block.number), delegatee));

        emit DelegateChanged(delegator, oldDelegatee, delegatee);

        
        _moveDelegates(oldDelegatee, delegatee, delegatorBalance);
    }

    
    function emergencyWithdraw(uint256 amount, address receiver) external returns(uint256) {

        require(emergency, ""hPAL: Not emergency"");

        require(amount > 0, ""hPAL: Null amount"");
        require(receiver != address(0), ""hPAL: Address Zero"");

        if(userLocks[msg.sender].length != 0){
            
            uint256 currentUserLockIndex = userLocks[msg.sender].length - 1;
            UserLock storage currentUserLock = userLocks[msg.sender][currentUserLockIndex];

            
            currentTotalLocked -= currentUserLock.amount;
            totalLocks.push(TotalLock(
                safe224(currentTotalLocked),
                safe32(block.number)
            ));

            userLocks[msg.sender].push(UserLock(
                safe128(0),
                safe48(block.timestamp),
                safe48(0),
                safe32(block.number)
            ));
        }

        
        uint256 userAvailableBalance = balanceOf(msg.sender);
        uint256 burnAmount = amount > userAvailableBalance ? userAvailableBalance : amount;

        _burn(msg.sender, burnAmount);

        
        pal.safeTransfer(receiver, burnAmount);

        emit EmergencyUnstake(msg.sender, burnAmount);

        return burnAmount;

    }

    

    error Exceed224Bits(); 
    error Exceed128Bits(); 
    error Exceed48Bits(); 
    error Exceed32Bits(); 

    function safe32(uint n) internal pure returns (uint32) {
        if(n > type(uint32).max) revert Exceed32Bits();
        return uint32(n);
    }

    function safe48(uint n) internal pure returns (uint48) {
        if(n > type(uint48).max) revert Exceed48Bits();
        return uint48(n);
    }

    function safe128(uint n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Exceed128Bits();
        return uint128(n);
    }

    function safe224(uint n) internal pure returns (uint224) {
        if(n > type(uint224).max) revert Exceed224Bits();
        return uint224(n);
    }

    

    error IncorrectParameters();
    error DecreaseDurationNotOver();

    
    function setKickRatio(uint256 newKickRatioPerWeek) external onlyOwner {
        if(newKickRatioPerWeek == 0 || newKickRatioPerWeek > 5000) revert IncorrectParameters();
        kickRatioPerWeek = newKickRatioPerWeek;
    }

    
    function triggerEmergencyWithdraw(bool trigger) external onlyOwner {
        emergency = trigger;
    }

    
    function setEndDropPerSecond(uint256 newEndDropPerSecond) external onlyOwner {
        if(block.timestamp < startDropTimestamp + dropDecreaseDuration) revert DecreaseDurationNotOver();
        endDropPerSecond = newEndDropPerSecond;
    }
}",8463.0,2,8,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Insufficient Input Validation in Constructor**:
   - The constructor does not validate that `maxLockBonusRatio` is greater than or equal to `minLockBonusRatio` and `baseLockBonusRatio`. If `maxLockBonusRatio` is set lower than `minLockBonusRatio`, it can cause underflow in the calculation of `userLockBonusRatio` in the `_lock` function, leading to incorrect reward bonuses or transaction reverts.

2. **Potential Division by Zero**:
   - In `_getNewIndex`, if `maxLockBonusRatio` is zero (due to improper constructor arguments), the calculation `(_currentDropPerSecond * UNIT) / maxLockBonusRatio` will result in a division by zero, causing transactions to revert and disrupting reward distribution.

3. **Incorrect Bonus Ratio Calculation**:
   - If `maxLockBonusRatio` is not properly configured (e.g., set to a value less than `minLockBonusRatio`), the formula `minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT)` in `_lock` will underflow, leading to invalid bonus ratios and incorrect reward accrual.

4. **Checkpoint Array Growth and Gas Inefficiency**:
   - Frequent updates to checkpoints (e.g., during token transfers, locks, or delegate changes) can lead to large arrays. Accessing historical data via binary search in functions like `getPastTotalLock` may result in high gas costs and potential out-of-gas errors for users interacting with older checkpoints.

5. **Centralization Risks**:
   - The contract owner has significant control, including setting emergency mode and modifying critical parameters like `kickRatioPerWeek` and `endDropPerSecond`. Malicious or compromised owner actions could lead to fund loss or unfair penalties (e.g., setting extreme `kickRatioPerWeek`).

6. **Cooldown Manipulation via Token Transfers**:
   - The cooldown mechanism uses a weighted average when tokens are transferred, which could allow users to manipulate cooldown timestamps by transferring tokens between accounts. However, this is part of the design and not a direct vulnerability.

7. **Unchecked PAL Token Allowance in `claim` Function**:
   - The `claim` function assumes the `rewardsVault` has sufficient allowance for the contract. If the vault's allowance is insufficient, the transfer fails, preventing users from claiming rewards. This relies on proper external setup but isn't a contract bug.

8. **Timestamp Dependence**:
   - Reliance on `block.timestamp` for cooldown periods and lock durations makes the contract susceptible to minor miner manipulation, though the impact is typically minimal within acceptable bounds.","### **Output**

---

**[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases**

**Report Description**:  
The function `_updateDropPerSecond()` suffers from precision loss when calculating the number of months elapsed. Specifically, when the current time is `lastDropUpdate + (2*MONTH-1)`, `nbMonthEllapsed` is rounded down to 1, even though 1.99 months have passed. This results in `DropPerSecond` decreasing by only 1 * `dropDecreasePerMonth` instead of the expected 2 * `dropDecreasePerMonth`. Over time, this can lead to a significant discrepancy in the emission rate, with only half of the expected decrease being applied. This issue can cause the system to emit rewards at a much higher rate than intended, potentially leading to economic instability.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue at all. The precision loss in `_updateDropPerSecond()` and its impact on reward emissions is a critical vulnerability that is entirely missed.

---

**[H-02] System could be wrapped and made useless without contract whitelisting**

**Report Description**:  
An attacker could create a contract or contract factory (e.g., ""PAL Locker"") that deposits PAL tokens, locks them, and delegates voting power to the contract owner. The ownership of this contract could then be sold, effectively making locked hPAL liquid and transferable again. This would undermine the core design of hPAL, which relies on locking tokens to make them non-liquid in exchange for boosted voting power and reward rates. Without contract whitelisting, the system could be rendered ineffective.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The potential for wrapping the system and making locked tokens liquid is a significant vulnerability that is entirely overlooked.

---

**[M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern**

**Report Description**:  
The `transferFrom()` function in `HolyPaladinToken.sol` does not follow the Checks-Effects-Interactions (CEI) pattern. Instead of updating the sender's allowance before making the external call to `_transfer()`, it performs the transfer first and then updates the allowance. This unsafe pattern opens the door to reentrancy attacks, where an attacker could exploit the external call to perform double-spending or other malicious actions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The failure to follow the CEI pattern in `transferFrom()` is a critical security flaw that is entirely missed.

---

**[M-02] Incorrect number of seconds in `ONE_YEAR` variable**

**Report Description**:  
The `ONE_YEAR` variable in `HolyPaladinToken.sol` is set to `31557600` seconds, which is incorrect. This variable is used in functions like `getCurrentVotes()` and `getPastVotes()`, and the incorrect value could negatively impact users by providing inaccurate voting power calculations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The incorrect `ONE_YEAR` value is a significant inaccuracy that could affect user calculations and is entirely missed.

---

**[M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens**

**Report Description**:  
In the `_getNewReceiverCooldown` function, if `_senderCooldown` is Day 15 and `receiverCooldown` is Day 0, the new cooldown is calculated as `(100 * Day 15 + 200 * Day 0)/(100+200) = Day 5`. This allows users at `UNSTAKE_PERIOD` to assist others in unstaking tokens earlier than intended, potentially bypassing intended restrictions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The ability to manipulate cooldown periods through token transfers is a significant vulnerability that is entirely missed.

---

**[M-04] `cooldown` is set to 0 when the user sends all tokens to himself**

**Report Description**:  
In the `_beforeTokenTransfer` function, the `cooldown` is set to 0 when a user transfers all tokens to himself. This behavior could be exploited to reset cooldown periods, allowing users to bypass intended restrictions.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The resetting of `cooldown` to 0 during self-transfers is a significant vulnerability that is entirely missed.

---

**[M-05] Past state query results are susceptible to manipulation due to multiple states with same block number**

**Report Description**:  
Past state queries (e.g., `getPastVotes()`) are susceptible to manipulation because multiple states can exist with the same block number. This could allow attackers to exploit the system by providing misleading historical data.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The susceptibility of past state queries to manipulation is a significant vulnerability that is entirely missed.

---

**[M-09] Function `cooldown()` is not protected when protocol is in emergency mode**

**Report Description**:  
The `cooldown()` function is not protected when the protocol is in emergency mode, making its behavior inconsistent with other major functions. This could allow users to bypass emergency restrictions, potentially undermining the protocol's security.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The lack of protection for `cooldown()` in emergency mode is a significant vulnerability that is entirely missed.

---

**[M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`**

**Report Description**:  
Users can bypass emergency restrictions on the `updateUserRewardState()` function, allowing them to update their reward state even when the protocol is in emergency mode. This could lead to unfair reward distribution or other unintended consequences.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The ability to bypass emergency restrictions on `updateUserRewardState()` is a significant vulnerability that is entirely missed.

---

**[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards**

**Report Description**:  
When users increase the lock amount on an expired lock, the associated bonus ratios are not updated correctly. This could cause users to miss out on rewards, as the bonus ratios are not recalculated to reflect the new lock amount.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The failure to update bonus ratios correctly when increasing the lock amount on an expired lock is a significant vulnerability that is entirely missed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] DropPerSecond is not updated homogeneously, the rewards emission can be much higher than expected in some cases**  
- **[H-02] System could be wrapped and made useless without contract whitelisting**  
- **[M-01] HolyPaladinToken.sol uses ERC20 token with a highly unsafe pattern**  
- **[M-02] Incorrect number of seconds in `ONE_YEAR` variable**  
- **[M-03] Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens**  
- **[M-04] `cooldown` is set to 0 when the user sends all tokens to himself**  
- **[M-05] Past state query results are susceptible to manipulation due to multiple states with same block number**  
- **[M-09] Function `cooldown()` is not protected when protocol is in emergency mode**  
- **[M-13] Users Can Bypass Emergency Restrictions on `updateUserRewardState()`**  
- **[M-14] Increasing the Lock Amount on an Expired Lock Will Cause Users to Miss Out on Rewards**  

--- 

The response list fails to address any of the issues in the issue report, indicating a significant gap in coverage and accuracy.",0,0,10,8,"Okay, let's take a look at this smart contract and try to find all the vulnerabilities. Hmm, the contract is called HolyPaladinToken and it's an ERC20 token. It seems to involve staking, locking, voting, rewards, and some emergency features. 

First, I'll start by checking common vulnerabilities like reentrancy. The contract uses SafeERC20, which should handle safe transfers, so maybe that's covered. Let's see the functions that transfer tokens. For example, in the _unstake function, they call pal.safeTransfer. SafeERC20's safeTransfer should prevent reentrancy here. So maybe reentrancy isn't an issue here.

Next, look for integer overflows/underflows. The contract is using Solidity 0.8.10, which has built-in overflow checks, so that's probably okay. But maybe there's some division or calculations that could lead to unexpected behavior. For example, in the _getNewReceiverCooldown function, there's a calculation involving (amount * senderCooldown + receiverBalance * receiverCooldown) divided by (amount + receiverBalance). If amount + receiverBalance is zero, that could be a problem. But since amount is being transferred, maybe the code ensures that amount is positive. But the function is called in _beforeTokenTransfer when transferring, so if someone transfers to a receiver with zero balance, maybe there's a division by zero here. Wait, the parameters are amount, receiverBalance. If both are zero, but amount is part of the transfer, so maybe amount is positive. Not sure. But need to check.

Another area is access control. The contract uses Ownable, so functions with onlyOwner modifier are protected. But are there any functions that should be restricted but aren't? For example, emergencyWithdraw is a public function, but it checks if emergency is true. Only the owner can trigger the emergency via triggerEmergencyWithdraw. So that's okay.

Now, looking at the lock mechanisms. The _lock function has various checks. Let's see the parameters: duration must be between MIN_LOCK_DURATION and MAX_LOCK_DURATION. If a user increases the lock duration, they have to provide a duration longer than the current one. But when creating a new lock, the duration must be within the min and max. That seems okay.

What about the kick function? When someone kicks a user, they take a penalty. The penalty is calculated based on the number of weeks past the unlock time. The penaltyPercent is nbWeeksOverLockTime multiplied by kickRatioPerWeek. If kickRatioPerWeek is set too high, like 10000 (MAX_BPS), the penalty could be 100% or more. But the setKickRatio function checks that newKickRatioPerWeek is <=5000. So the owner can set it up to 50% per week, leading to a maximum of 50% * weeks. But if weeks are many, the penalty could exceed 100%, so in that case, penaltyAmount is set to currentUserLock.amount. That's handled with a ternary check. So that's okay.

Reward calculations: The _updateUserRewards function is critical. It calculates accrued rewards based on the user's staked and locked balances. The _getUserAccruedRewards function has some complex calculations. Let's check if any variables could be manipulated. For example, userStakedBalance is _availableBalanceOf(user), which is balanceOf(user) minus locked amount. If the locked amount is not properly tracked, this could be wrong. But userLocks are pushed correctly when locking, so that's probably okay.

Another thing: when a user locks tokens, their voting power includes a bonus based on the lock duration. The getCurrentVotes function adds bonus votes if the delegate is the user and the duration is over a year. However, the check is delegates[user] == user. If a user delegates to someone else, they don't get the bonus. That's intended, but maybe a user could delegate to themselves to get the bonus. Which is allowed.

Potential issues with checkpoints: The contract uses checkpoints for voting power and delegates. When moving tokens, _moveDelegates is called. The _writeCheckpoint function adds a new checkpoint if the block number is different. But if multiple transactions occur in the same block, it updates the existing checkpoint. That's correct.

Another possible issue: when a user increases their lock amount or duration, the _lock function may push a new UserLock. But when increasing the duration, the startTimestamp could be updated. Let's see: if the action is INCREASE_AMOUNT, the startTimestamp remains the same as the current lock. If it's a new lock, it uses block.timestamp. But when extending the duration, does the startTimestamp reset? For example, if a user had a lock for 1 year starting at time X, then increases the duration to 2 years, does the startTimestamp stay at X? That would mean the lock ends at X + 2 years. That's correct.

What about the cooldown period? The cooldown is set to block.timestamp when the user calls cooldown(). Then, unstake requires that block.timestamp > cooldown + COOLDOWN_PERIOD. But if the user transfers their tokens, the cooldown of the receiver is updated. The _beforeTokenTransfer function calculates the new cooldown for the receiver based on the sender's cooldown and the receiver's existing balance. This could potentially allow someone to bypass the cooldown by transferring tokens to another account. For example, if Alice has a cooldown set, she transfers to Bob who has no cooldown. Then Bob's cooldown is calculated as a weighted average. But if Bob's previous balance was zero, the new cooldown would be (amount * senderCooldown) / (0 + amount) = senderCooldown. So Bob's cooldown would be the same as Alice's. But since Bob can't unstake until cooldown period passes from that timestamp, this is probably acceptable. However, maybe there's a way to manipulate cooldowns by transferring tokens between accounts to reset the cooldown. But according to the code, the receiver's cooldown is set based on a weighted average, so if they receive tokens from someone with an older cooldown, their cooldown could become older, which might not be desired. But the code is designed this way, so it's not a vulnerability, but a feature.

Another thing: the emergencyWithdraw function allows users to withdraw their tokens without going through the cooldown. But this is only possible when emergency is true, which only the owner can set. So that's controlled.

Possible front-running: When a user calls unlock, anyone can kick them after UNLOCK_DELAY. But if the user unlocks and then quickly tries to relock, maybe there's a race condition. However, when a user unlocks, a new UserLock is pushed with amount 0, so subsequent actions would require creating a new lock. The kick function can only be called on expired locks, so front-running might not be an issue here.

Division precision: In several places, the code uses divisions which could lead to rounding errors. For example, in _getNewIndex, accruedBaseAmount is (ellapsedTime * baseDropPerSecond). baseDropPerSecond is (_currentDropPerSecond * UNIT) / maxLockBonusRatio. If these divisions truncate, there could be precision loss. Similarly, when calculating user rewards, using (userStakedBalance * indexDiff) / UNIT. If the indexDiff is not precise enough, users might lose out on small amounts. However, this is a common approach in reward calculations and not necessarily a vulnerability, just a design choice.

In the _lock function, when increasing the amount, the code requires that the new amount is greater than or equal to the current amount. But if the user's balance is less than the new amount, the require(amount <= userBalance) would fail. So that's checked.

Another thing: when a user has multiple locks (userLocks array), the code always uses the last one (length -1). So previous locks are ignored once a new one is added. That's correct, as each new lock replaces the previous in terms of active locked amount.

Potential DoS: Functions that loop through checkpoints using binary search. For example, getPastTotalLock uses a loop for binary search. If the number of checkpoints is very large, this could consume too much gas and cause out-of-gas errors. However, the number of checkpoints depends on how often the totalLocked changes. If the contract is used heavily, this could become a problem. But it's a common pattern in checkpoint-based systems.

The kick function's penalty calculation: If the lock is expired and UNLOCK_DELAY has passed, the penalty is applied. The penalty is based on how many weeks have passed since expiration. However, if the kick is called much later, the penalty could be 100% (if nbWeeksOverLockTime * kickRatioPerWeek >= MAX_BPS). But the setKickRatio function allows the owner to set up to 5000 (50% per week). So after two weeks, penaltyPercent would be 10000, which is 100%, so penaltyAmount becomes the full amount. This could lead to users losing all their locked tokens if they don't unlock in time and someone kicks them. But this is intended behavior, not a vulnerability.

In the emergencyWithdraw function, when the user has a lock, the current lock is set to zero and the totalLocked is reduced. But if the user had a lock that was already expired, this could allow them to withdraw even if they were supposed to be kicked. However, in an emergency, the owner wants users to withdraw regardless, so this is intentional.

Possible issues with the SafeMath libraries: Since the contract uses Solidity 0.8, overflows are handled automatically. So no need for SafeMath.

Another thing: The ERC20 _beforeTokenTransfer hook is overridden to handle cooldowns and reward updates. However, if the parent ERC20 contract also has a _beforeTokenTransfer, the override might miss calling super. Looking at the code, the contract imports ERC20 from OpenZeppelin, and the _beforeTokenTransfer is correctly overridden with the override keyword. So that's okay.

The _delegate function allows a user to delegate to address(0), which would remove their delegation. That's allowed. But the code in getCurrentVotes checks if delegates[user] == user to apply the bonus. So if a user delegates to someone else, they lose the bonus. That's correct.

In the _updateUserRewards function, if the user is address(0), the function returns early. But how can user be address(0)? Maybe when tokens are burned or minted to address(0), but in ERC20, transfers to address(0) are allowed (for burning). However, the function would skip updating rewards for address(0), which is probably okay.

What about the initial minting? The constructor doesn't mint any tokens, and the _stake function mints when users stake. So the total supply is controlled by staking, which is correct.

In the stakeAndIncreaseLock function, if the duration is the same as the current lock's duration, it uses LockAction.INCREASE_AMOUNT. Otherwise, it creates a new lock. But the code adds the previous amount plus the new staked amount. However, when creating a new lock with a different duration, the previous lock's amount is replaced. So the user's locked amount is increased correctly.

In the _getUserAccruedRewards function, the code calculates lockingRewards based on the user's locked amount and bonus ratio. However, if the user's bonus ratio decreases over time (due to userBonusRatioDecrease), the calculation uses an average of the previous and new bonus ratio. The formula is (previousBonusRatio + newBonusRatio) / 2 multiplied by the time elapsed. This is a trapezoidal approximation for the integral of the bonus ratio over time. But if the bonus decreases linearly, this approximation is correct. However, if the decrease is not linear, this might not be accurate. But given the code sets userBonusRatioDecrease as (userLockBonusRatio - baseLockBonusRatio) / duration, which implies a linear decrease, the trapezoidal method is appropriate. So that's correct.

Another thing: the kick function can be called by anyone on any expired lock after the UNLOCK_DELAY. This could lead to griefing where someone kicks a user just to make them lose funds, even if the user was about to unlock. But this is part of the contract's design to incentivize timely unlocking.

Possible issues with the safe casting functions (safe32, safe48, etc.). For example, if a value exceeds the type's max, the function reverts. These are correctly implemented with custom errors, so any overflow in these casts would revert the transaction. That's good.

In the _updateDropPerSecond function, the code calculates the newDropPerSecond by decreasing monthly. However, the code uses MONTH as 2629800 seconds (approx 30.44 days). But the code checks if block.timestamp is beyond startDropTimestamp + dropDecreaseDuration, then sets to endDropPerSecond. Otherwise, decreases by dropDecreasePerMonth each month. But if the dropDecreaseDuration is not a multiple of MONTH, the last decrease might be partial. But the code handles it by checking if the current time is within the decrease period.

Another thing: when a user has multiple locks, the getCurrentVotes function only considers the latest lock for the bonus votes. That's correct because older locks are no longer active.

In the getPastVotes function, it combines the checkpoint votes with the past lock's bonus. The past lock is retrieved using _getPastLock, which uses the same block number. But if the lock was created in a different block, the delegate at that block might not be the user, so the bonus wouldn't apply. The code correctly checks getPastDelegate(user, blockNumber) == user before applying the bonus. That's accurate.

Potential issue with the rewardIndex calculation: _getNewIndex uses (currentDropPerSecond * UNIT) / maxLockBonusRatio to calculate baseDropPerSecond. If maxLockBonusRatio is zero, this would cause a division by zero. But in the constructor, maxLockBonusRatio is set via the constructor parameters, and there's a require statement that the admin is not address(0), but no check on maxLockBonusRatio. However, the constructor parameters are provided when deploying, so if the deployer sets maxLockBonusRatio to zero, that would be a problem. The contract should have a check in the constructor to ensure that maxLockBonusRatio is greater than zero. But in the current code, there's no such check. So this is a vulnerability. For example, if baseLockBonusRatio is 0, min and max are 0, then divisions by zero could occur.

Looking at the constructor parameters:

baseLockBonusRatio, minLockBonusRatio, maxLockBonusRatio are passed in. The code doesn't check that maxLockBonusRatio > minLockBonusRatio, or that they are non-zero. So if maxLockBonusRatio is zero, then in _lock function, the durationRatio calculation could divide by zero. Because MAX_LOCK_DURATION is a constant (63115200) and MIN_LOCK_DURATION is 7889400. So MAX - MIN is 55225800. If maxLockBonusRatio is set to minLockBonusRatio, then durationRatio would be ((duration - MIN) * UNIT) / (MAX - MIN), which is okay. But if maxLockBonusRatio is less than min, the code would have issues. So the constructor should validate that maxLockBonusRatio >= minLockBonusRatio and min >= base, etc. But the current code doesn't do that. This could lead to underflow or incorrect calculations in the lock bonus ratios.

Another thing: the _lock function calculates userLockBonusRatio as minLockBonusRatio + (((maxLockBonusRatio - minLockBonusRatio) * durationRatio) / UNIT). If max < min, this would underflow. So if during deployment, someone configures max < min, the contract would have a critical error. Therefore, the constructor lacks input validation for these parameters, leading to a possible vulnerability.

Also, in the same function, userBonusRatioDecrease is set to (userLockBonusRatio - baseLockBonusRatio) / duration. If userLockBonusRatio < baseLockBonusRatio, this would underflow. But userLockBonusRatio is min + (max - min)*durationRatio/UNIT. So if max < min, this would be a problem. So again, the lack of input validation here is a vulnerability.

Another possible issue is in the _getNewReceiverCooldown function. If the receiver's balance is zero and they receive tokens, the new cooldown is calculated as (amount * senderCooldown) / (amount + 0) = senderCooldown. So if the sender had a valid cooldown, the receiver inherits it. But if the sender's cooldown is old (beyond the cooldown period + unstake period), then receiver's cooldown is also old. But the unstake function checks that block.timestamp > cooldown + COOLDOWN_PERIOD. So if the receiver's cooldown is too old, they might not be able to unstake. However, the cooldown for the receiver is set in _beforeTokenTransfer, which could reset if the entire balance is transferred out. For example, if Alice has a cooldown and transfers all her tokens to Bob, then Alice's cooldown is reset to zero. But Bob's cooldown is set based on Alice's previous cooldown. If Bob's cooldown is too old, he can't unstake until the cooldown period passes. But this is a design choice, not necessarily a vulnerability.

Another possible issue: when a user calls increaseLockDuration, they can set a duration longer than the current one. But if the current lock has already started, increasing the duration extends the lock end time. However, the startTimestamp remains the original one, which could lead to a longer lock than intended. But this is as per the function's design.

In the emergencyWithdraw function, the code burns the user's tokens and transfers the PAL back. However, the user's locked amount is set to zero, but currentTotalLocked is reduced by the currentUserLock.amount. If the user had already unlocked (i.e., the lock is expired), the currentUserLock.amount might be zero, leading to currentTotalLocked not being updated correctly. Wait, in emergencyWithdraw, if the user has a lock, the code subtracts currentUserLock.amount from currentTotalLocked. But if the lock was already unlocked (amount zero), this would subtract zero. So it's okay. But if the user is in an active lock, emergencyWithdraw allows them to bypass the lock and withdraw, which is intended during an emergency.

Another vulnerability: the contract uses block.timestamp for cooldowns and lock durations. Miners can manipulate block.timestamp slightly, but the impact is minimal as it's within a few seconds. This is a known issue but generally considered acceptable.

In the claim function, the code transfers PAL from the rewardsVault to the user. If the rewardsVault doesn't have enough allowance or balance, the transfer would fail. But the function requires that the rewardsVault has approved the contract to spend the tokens. However, the contract doesn't check if the rewardsVault has sufficient allowance. If the rewardsVault hasn't set the allowance, the transfer would fail, and the user can't claim rewards. This is a dependency on the rewardsVault's setup, not a vulnerability in the contract itself.

Finally, there's a potential issue with the initial setup of the contract. For example, if startDropPerSecond is set very high, it could drain the rewardsVault quickly. But that's up to the deployer to configure properly.

So summarizing the vulnerabilities found:

1. **Lack of Input Validation in Constructor**: The constructor does not validate that maxLockBonusRatio >= minLockBonusRatio and minLockBonusRatio >= baseLockBonusRatio. If max is less than min, calculations in _lock would underflow, leading to incorrect bonus ratios and possible reverts.

2. **Division by Zero in Reward Calculations**: If maxLockBonusRatio is zero, the calculation of baseDropPerSecond in _getNewIndex would divide by zero. This is possible if the contract is deployed with maxLockBonusRatio set to zero.

3. **Incorrect Bonus Ratio Calculation**: If the constructor parameters for base, min, and max lock bonus ratios are not properly validated, leading to underflow or invalid ratios, causing incorrect reward distribution.

4. **Unchecked Return Value for safeTransferFrom**: In the claim function, pal.safeTransferFrom is used, which should handle failures, but if the rewardsVault hasn't approved the contract or has insufficient balance, the transfer would revert. However, this is an external dependency issue, not a contract bug.

5. **Cooldown Manipulation via Transfers**: Transferring tokens can affect the receiver's cooldown timestamp, potentially allowing manipulation, but this is part of the intended design.

6. **Checkpoint Array Growth**: Functions that repeatedly add checkpoints (e.g., every lock/unlock) could lead to gas inefficiencies and potential out-of-gas errors when accessing historical data. However, this is a trade-off of the checkpoint pattern.

7. **Kick Ratio Setting**: The owner can set kickRatioPerWeek up to 5000 (50% per week), leading to possible 100% penalty after two weeks. While this is a governance decision, it could be considered a centralization risk if the owner is malicious.

8. **Emergency Mode Centralization**: The owner can trigger emergency mode, allowing users to withdraw without cooldown. This is a centralization risk but documented in the contract's design.

The main vulnerabilities here are points 1, 2, and 3 related to input validation and division by zero in the reward calculations. These could lead to contract reverts or incorrect reward distributions if the constructor parameters are misconfigured.","```
None.
```",0.0
PaladinRewardReserve.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";

/** @title Paladin Reward Reserve contract  */
/// @author Paladin
contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    /** @notice Addresses allowed to transfer tokens from this contract */
    mapping(address => bool) public approvedSpenders;

    /** @notice Emitted when a new spender is approved*/
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when the allowance of a spander is updated */
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    /** @notice Emitted when a spender allowance is removed */
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",494.0,56.0,"[M-06]PaladinRewardReserve.solmay have potential bugs if it uses new tokens as rewards
[M-08] Add a timelock toPaladinRewardReservefunctions
The owner of PaladinRewardReserve can approve and transfer any amount of tokens with no limits on any account. This is not good for investors. To give more trust to users: these functions should be put behind a timelock.",2.0,"pragma solidity ^0.8.4;

import ""./open-zeppelin/utils/Ownable.sol"";
import ""./open-zeppelin/utils/ReentrancyGuard.sol"";
import ""./open-zeppelin/interfaces/IERC20.sol"";
import ""./open-zeppelin/libraries/SafeERC20.sol"";



contract PaladinRewardReserve is Ownable, ReentrancyGuard{
    using SafeERC20 for IERC20;

    
    mapping(address => bool) public approvedSpenders;

    
    event NewSpender(address indexed token, address indexed spender, uint256 amount);
    
    event UpdateSpender(address indexed token, address indexed spender, uint256 amount);
    
    event RemovedSpender(address indexed token, address indexed spender);

    constructor(address _admin) {
        transferOwnership(_admin);
    }

    function setNewSpender(address token, address spender, uint256 amount) external onlyOwner {
        require(!approvedSpenders[spender], ""Already Spender"");
        approvedSpenders[spender] = true;
        IERC20(token).safeApprove(spender, amount);

        emit NewSpender(token, spender, amount);
    }

    function updateSpenderAllowance(address token, address spender, uint256 amount) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        IERC20(token).safeApprove(spender, 0);
        IERC20(token).safeApprove(spender, amount);

        emit UpdateSpender(token, spender, amount);
    }

    function removeSpender(address token, address spender) external onlyOwner {
        require(approvedSpenders[spender], ""Not approved Spender"");
        approvedSpenders[spender] = false;
        IERC20(token).safeApprove(spender, 0);

        emit RemovedSpender(token, spender);
    }

    function transferToken(address token, address receiver, uint256 amount) external onlyOwner nonReentrant {
        IERC20(token).safeTransfer(receiver, amount);
    }

}",423.0,0,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Spender Approval Tracking**  
   - The `approvedSpenders` mapping tracks approval globally per spender (address) rather than per (token, spender) pair. This leads to:
     - Inability to approve a spender for multiple tokens.
     - Allowing updates/removals for tokens unrelated to the spender's original approval.
     - Residual allowances remaining active for other tokens after removal.

2. **Insecure Allowance Modifications Across Tokens**  
   - The `updateSpenderAllowance` and `removeSpender` functions do not validate the token originally associated with a spender. An owner can mistakenly:
     - Approve a spender for unintended tokens.
     - Leave active allowances on other tokens when removing a spender for one token.

3. **Residual Allowances After Removal**  
   - When removing a spender via `removeSpender`, only the specified token's allowance is set to zero. Allowances for other tokens remain unchanged, allowing the spender to retain access to those funds.

4. **Misleading Event Logging**  
   - Events (`NewSpender`, `UpdateSpender`, `RemovedSpender`) include a token address parameter, but the contract does not track per-token approvals. This creates ambiguity about which token a spender is approved for.

5. **Lack of Token-Spender Pair Tracking**  
   - The contract fails to track which tokens a spender is approved for, leading to inconsistent state:
     - A spender can be ""removed"" for one token but retain approvals for others.
     - Updates to allowances can unintentionally affect unrelated tokens.

6. **Centralized Token Transfer Risk**  
   - The `transferToken` function allows the owner to withdraw arbitrary tokens. While intended, this poses a centralization risk where the owner could drain all funds. However, this is a design choice rather than a code vulnerability.

**Critical Impact**:  
The most severe issues stem from improper tracking of (token, spender) pairs, allowing unintended token approvals and residual access. Attackers could exploit these flaws to drain tokens the spender was never intended to access.","### **Output**

---

**[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards**

**Report Description**:  
The issue highlights potential bugs in `PaladinRewardReserve.sol` when new tokens are introduced as rewards. The report suggests that the contract may not handle new tokens correctly, leading to vulnerabilities such as improper reward distribution or unintended behavior.

**Match in Response List**:  
**No match found**. The response list does not address the specific issue of handling new tokens as rewards in `PaladinRewardReserve.sol`.

**Validation**:  
**Incorrect**. The response list does not cover the issue of handling new tokens as rewards, which is a critical oversight. This leaves the vulnerability unaddressed.

---

**[M-08] Add a timelock to PaladinRewardReserve functions**

**Report Description**:  
The issue points out that the owner of `PaladinRewardReserve` can approve and transfer any amount of tokens without limits, which is not favorable for investors. To enhance trust, the report recommends adding a timelock to these functions to prevent immediate and unrestricted token transfers.

**Match in Response List**:  
**No match found**. The response list does not mention the lack of a timelock mechanism for `PaladinRewardReserve` functions.

**Validation**:  
**Incorrect**. The response list fails to address the centralization risk posed by the owner's unrestricted ability to transfer tokens. The absence of a timelock mechanism is a significant oversight.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-06] PaladinRewardReserve.sol may have potential bugs if it uses new tokens as rewards**  
- **[M-08] Add a timelock to PaladinRewardReserve functions**

---

### **Conclusion**  
The `response_list` does not adequately address the issues raised in the `issue` report. Specifically, it misses critical vulnerabilities related to handling new tokens as rewards and the lack of a timelock mechanism for token transfers. These gaps indicate a need for more comprehensive coverage of security concerns in the smart contract.",0,0,2,6,"Okay, let me take a look at this smart contract and try to find any vulnerabilities. So the contract is called PaladinRewardReserve, and it's using Ownable and ReentrancyGuard from OpenZeppelin. That means the owner has special privileges and there's some protection against reentrancy attacks. Let's go through the functions and variables step by step.

First, there's a mapping called approvedSpenders which tracks addresses that are allowed to spend tokens. The events are for tracking when a new spender is added, updated, or removed. The constructor transfers ownership to an admin address, which is good because it's not hardcoded.

Looking at the setNewSpender function: it checks if the spender is already approved, then sets them to true and calls safeApprove with the given amount. The problem here might be that safeApprove is being used, which I remember has a known issue. The ERC20 approve function can have a race condition if the current allowance isn't zero. Because if the spender already has some allowance, they could front-run this transaction and transfer the old amount, then the new approval would be set. But wait, in setNewSpender, they first check if the spender isn't already approved. Wait, the mapping approvedSpenders is separate from the actual allowance. So even if the spender was previously approved and then removed, the actual allowance might still be non-zero. So maybe when adding a new spender, they don't reset the allowance first. For example, if a spender was approved before, removed (which sets the mapping to false and sets allowance to zero), but maybe in some other scenario, the allowance isn't zero when setting a new spender. Hmm. Wait, the setNewSpender function requires that approvedSpenders[spender] is false. So the first time they are added, the allowance is set to the given amount. But if the spender was previously approved, then removed (which sets the mapping to false and sets allowance to zero), but suppose someone tries to add them again. Then, since approvedSpenders is false, setNewSpender would proceed, but what if the spender still has some allowance left? Wait, no. When they remove a spender, they call safeApprove(spender, 0). So when adding a new spender, maybe the allowance is set correctly. But maybe in another case, if the spender was never added before, but the contract had previously approved some amount for them (unlikely, but possible), then safeApprove would fail if the current allowance is non-zero. Because safeApprove checks that the current allowance is zero before approving. Wait, SafeERC20's safeApprove function actually includes a check: it requires that the current allowance is zero, otherwise it reverts. So if you call safeApprove when the current allowance is non-zero, it will fail. Therefore, the code here could have a problem. For example, in setNewSpender, when you set a new spender, it calls safeApprove(spender, amount). If the contract had previously approved that spender for some amount (even if not through this contract's functions), then safeApprove would fail because the current allowance isn't zero. So the function would revert. But according to the code, when you add a new spender, it's supposed to be the first time. However, maybe the spender was approved in the past but then removed. When you remove a spender, you set their allowance to zero. So when adding again, the allowance would start at zero, so safeApprove should work. Wait, the removeSpender function calls safeApprove(spender, 0), which sets the allowance to zero. So when you add a new spender again, the current allowance is zero, so safeApprove(amount) would work. But if someone tries to add a spender that was never added before, but the contract had some prior allowance for that spender (maybe from a different function or a different contract), then this would revert. However, that's an edge case. But maybe the contract's setNewSpender function should first set the allowance to zero before approving. Wait, the function setNewSpender does not check the current allowance. So if the contract had previously approved some amount for the spender (without going through this contract's functions), then safeApprove would fail. But in the context of this contract, all approvals are handled through these functions, so that might not be an issue. But perhaps it's a vulnerability if, for example, the owner mistakenly tries to add a spender that was already approved in the past, but through another method. So this could cause the function to revert. But maybe that's not a vulnerability, just a user error. Not sure.

Another thing: the setNewSpender function adds a spender and approves them for a certain amount. But if the same spender is added again (which is prevented by the approvedSpenders check), but if they are removed and then added again, the code would work. However, when you remove a spender, you set the allowance to zero. Then adding them again would call safeApprove(amount), which would work because the current allowance is zero. So that's okay.

Wait, but in setNewSpender, the function is only allowed if the spender is not already approved (approvedSpenders[spender] is false). So that's correct. When you remove a spender, approvedSpenders is set to false. So adding again is allowed. But during that add, safeApprove is called. If during the time between removal and adding again, someone else called approve on the token for that spender, then the current allowance would not be zero, causing safeApprove to revert. But that's unlikely. So maybe this is safe.

Next, the updateSpenderAllowance function. It checks that the spender is approved, then sets their allowance to zero and then to the new amount. This uses safeApprove twice. First setting to zero, then to the new amount. This is the correct way to handle allowance changes to prevent the race condition. Because if you just set it from non-zero to another non-zero, a spender could front-run and use the old allowance. By setting to zero first, you prevent that. So the updateSpenderAllowance function is safe here.

The removeSpender function sets approvedSpenders to false and sets allowance to zero. That's good.

The transferToken function allows the owner to transfer any ERC20 token to any receiver. Since it's onlyOwner, that's a centralization risk, but not a vulnerability per se. However, the owner could potentially drain any tokens held by the contract. But since it's part of the design, maybe that's intended. However, there's no restriction on which tokens can be transferred. If the contract holds multiple tokens, the owner can transfer all of them. But as per the contract's design, maybe that's acceptable. But this could be a centralization issue, not a vulnerability in code.

Another point: the approvedSpenders mapping is a global mapping, not per token. Wait, no. The mapping is address => bool, where the address is the spender. But when you set a spender, you specify a token. So if the same spender is approved for multiple tokens, each approval is tracked in the mapping. Wait, no. The approvedSpenders mapping is just for the spender address, not per token. So once a spender is approved for any token, they are marked as approved, and you can't approve them for another token without removing them first. Wait, this is a problem. Let's see.

For example, suppose the owner calls setNewSpender(tokenA, spenderX, 100). Then approvedSpenders[spenderX] becomes true. Now, if the owner wants to setNewSpender(tokenB, spenderX, 200), the function will check if approvedSpenders[spenderX] is false, which it isn't, so it will revert. So the spender can only be approved for one token at a time. But maybe the intention is that a spender can be approved for multiple tokens. However, the current mapping structure doesn't track per token, it's a global approval. So if you want to approve a spender for multiple tokens, you can't because once they are approved for one, you can't add them again for another. This could be a flaw in the design. For example, if a spender needs to handle multiple tokens, the contract as written doesn't allow that. Each spender can only be associated with one token. Because when you set a new spender for a different token, you have to first remove them from the previous token. But the removeSpender function requires passing a token and a spender, but the mapping is not per token. So let's see: when you call removeSpender(token, spender), it checks if approvedSpenders[spender] is true. Then sets it to false. But this is a problem because the mapping is not per token. So once a spender is approved for any token, the approvedSpenders is true. If you then remove them by calling removeSpender for tokenA, it sets approvedSpenders to false, regardless of any other tokens they might have been approved for. Wait, but the code doesn't track per token. So the mapping approvedSpenders is address => bool, not (token => address => bool). Therefore, this is a design flaw. For example:

1. Owner calls setNewSpender(tokenA, spenderX, 100). approvedSpenders[spenderX] becomes true.
2. Then, owner calls setNewSpender(tokenB, spenderY, 200). approvedSpenders[spenderY] becomes true.
3. Now, if owner wants to remove spenderX for tokenA, they call removeSpender(tokenA, spenderX). This sets approvedSpenders[spenderX] to false. But spenderY is still approved.

Wait, no. The approvedSpenders mapping is a single bool per spender. So when you set a spender for any token, they are marked as approved. If you then set another spender for a different token, they are another entry. But in reality, the approvedSpenders mapping is a flat list. So if you have multiple spenders, each spender is tracked individually. Wait, no, each spender is a key in the mapping. So if the owner adds spenderX for tokenA, then spenderX is approved. If the owner then adds spenderY for tokenB, spenderY is approved. Then, removing spenderX (via removeSpender) will set their entry to false. But spenderY's entry remains true. So the mapping is per-spender, not per-token. Therefore, the approvedSpenders mapping tracks whether a spender is approved for any token. Wait, no, the code as written, when you add a spender for a specific token, the mapping marks that spender as approved. But if the same spender is used for another token, the mapping already has them as approved, so you can't add them again. So this is a problem. Because the mapping is not per token, a spender can only be approved for a single token. Once they are approved for any token, they can't be approved for another token until they are removed. So the design is incorrect. For example, if a spender is supposed to handle tokenA and tokenB, the current code would not allow that. Because when you try to setNewSpender for tokenB, the approvedSpenders[spender] is already true (from tokenA), so it will revert. Therefore, the mapping should track per token and per spender. But currently, it's only per spender, regardless of the token. This is a vulnerability because it incorrectly tracks approved spenders globally instead of per token. So if the same spender is needed for multiple tokens, the contract doesn't allow it. This is a logical error in the contract's design.

Another issue is that when updating a spender's allowance, the code allows the owner to update it for any token. The updateSpenderAllowance function takes a token and spender, but since the approvedSpenders mapping is not per token, it's possible to update the allowance for any token, even if the spender was originally approved for a different token. For example:

1. Owner adds spenderX for tokenA. approvedSpenders[spenderX] = true.
2. Owner calls updateSpenderAllowance(tokenB, spenderX, 500). Since approvedSpenders[spenderX] is true, the code allows this. But this would approve spenderX for tokenB, even though spenderX was originally approved for tokenA. But the approvedSpenders mapping doesn't track which token a spender is allowed for. So this allows the owner to mistakenly approve a spender for a different token than intended, leading to potential misuse of funds. For example, if spenderX was supposed to handle tokenA but the owner calls updateSpenderAllowance for tokenB, then spenderX now has access to tokenB's funds. This is a vulnerability because the contract doesn't enforce that spenders are only approved for specific tokens. The mapping is global, so once a spender is approved, they can have their allowance updated for any token. This is a critical flaw.

Similarly, when removing a spender, the code allows the owner to pass any token. For example:

1. Owner adds spenderX for tokenA. approvedSpenders[spenderX] = true.
2. Owner calls removeSpender(tokenB, spenderX). Since approvedSpenders[spenderX] is true, this will set it to false and set the allowance for tokenB to zero. But spenderX was approved for tokenA, so the allowance for tokenA remains. Because the removeSpender function only sets the allowance for the given token to zero. Therefore, after removal, spenderX still has approval for tokenA (unless the owner explicitly set it to zero via another function). Wait, no: when the owner calls removeSpender, they pass a token and spender. The function checks if the spender is approved (which they are). Then it sets approvedSpenders[spender] to false and sets the allowance for that token to zero. However, the spender may have been approved for other tokens as well. But since the approvedSpenders mapping is global, once removed, they are considered not approved, even if they had approvals for other tokens. For example, if the owner called setNewSpender for tokenA and tokenB with the same spender (which is not possible because the mapping prevents adding the same spender again), but in reality, the spender could have been approved for multiple tokens through the update function. Wait, no. Let's think again.

Actually, the approvedSpenders mapping is per spender, not per token. So once a spender is approved (for any token), they are marked as approved. When you call updateSpenderAllowance, you can change their allowance for any token. For example:

1. Owner adds spenderX for tokenA. approvedSpenders[spenderX] = true. TokenA's allowance for spenderX is set to 100.
2. Owner then calls updateSpenderAllowance(tokenB, spenderX, 200). Since approvedSpenders[spenderX] is true, this is allowed. Now, spenderX has an allowance of 200 for tokenB, even though they were originally approved for tokenA.
3. Then, the owner calls removeSpender(tokenC, spenderX) (even though spenderX wasn't approved for tokenC). The function checks that approvedSpenders[spenderX] is true, which it is, so it proceeds. It sets approvedSpenders[spenderX] to false and sets tokenC's allowance to zero. However, spenderX's allowances for tokenA and tokenB are still whatever they were before (100 and 200, respectively), but the approvedSpenders mapping is now false. However, the actual allowances for tokenA and tokenB are not reset to zero. So even though the spender is removed (approvedSpenders is false), their actual allowances for other tokens are still active. This is a major vulnerability because the approvedSpenders mapping is meant to track approval, but it's possible for a spender to still have allowances for other tokens even after being ""removed"" for a different token.

This is a critical issue. The contract's logic for managing spenders is flawed because it uses a single boolean per spender, regardless of the token. This leads to several problems:

- A spender can only be approved for one token at a time (since adding them for another token would require removing them first).
- When updating or removing a spender, the token parameter is not checked against the original token they were approved for. This allows the owner to modify allowances for any token, leading to unintended approvals.
- Removing a spender for one token does not reset their allowances for other tokens, leaving potential active allowances even after removal.

Another vulnerability: the events don't match the actions. For example, the NewSpender event is emitted when a spender is added, but the event includes the token address. However, the approvedSpenders mapping is not tracking per token, so the event might be misleading. Similarly, the UpdateSpender and RemovedSpender events include the token, but the mapping doesn't track which tokens a spender is associated with. This could lead to confusion in monitoring events, as a spender could be associated with multiple tokens, but the events would suggest a per-token approval.

Additionally, there's the possibility of a front-running attack when adding a new spender, but given that the safeApprove function is used, which requires the current allowance to be zero, this might be mitigated. But given the earlier design flaw in the mapping, this could still be an issue.

In summary, the main vulnerabilities are:

1. **Incorrect Spender Approval Tracking**: The approvedSpenders mapping tracks approval globally per spender, not per token. This leads to several issues, including inability to approve a spender for multiple tokens, allowing updates/removals for incorrect tokens, and leaving active allowances after removal.

2. **Insecure Allowance Updates for Different Tokens**: The updateSpenderAllowance and removeSpender functions allow changing allowances for any token, not just the one the spender was originally approved for, leading to unintended token approvals.

3. **Residual Allowances After Removal**: When a spender is removed for a specific token, their allowances for other tokens remain active, which can lead to unauthorized token transfers.

4. **Inconsistent Event Logging**: Events include token addresses, but the contract's logic doesn't track per-token approvals, leading to misleading event information.

5. **Potential Front-Running in Approval**: Although safeApprove is used, if the contract's state allows for multiple token approvals for a spender, there might still be race conditions, but this is somewhat mitigated by the safeApprove checks.

6. **Lack of Token Tracking in Mappings**: The contract doesn't track which tokens a spender is approved for, leading to logical inconsistencies and potential security risks.

These vulnerabilities could allow an owner to mistakenly approve spenders for incorrect tokens, leave residual allowances, or fail to properly revoke access across all tokens. Attackers could exploit these to gain unauthorized allowances for tokens they weren't intended to access.","```
None.
```",0.0
,,,,,,,,2,10,,,0,0,12,14,,,
