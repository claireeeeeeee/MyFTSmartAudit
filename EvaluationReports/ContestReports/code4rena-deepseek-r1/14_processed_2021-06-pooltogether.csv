nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
IdleYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";

/// @title An pooltogether yield source for Idle token
/// @author Sunny Radadiya
contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    /// @notice Emitted when the yield source is initialized
    event IdleYieldSourceInitialized(address indexed idleToken);

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    /// @notice Emitted when ERC20 tokens other than yield source's idleToken are withdrawn from the yield source
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    /// @notice Initializes the yield source with Idle Token
    /// @param _idleToken Idle Token address
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Calculates the balance of Total idle Tokens Contract hasv
    /// @return balance of Idle Tokens
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    /// @notice Calculates the number of shares that should be mint or burned when a user deposit or withdraw
    /// @param tokens Amount of tokens
    /// return Number of shares
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    /// @notice Calculates the number of tokens a user has in the yield source
    /// @param shares Amount of shares
    /// return Number of tokens
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    /// @notice Deposit asset tokens to Idle
    /// @param mintAmount The amount of asset tokens to be deposited
    /// @return 0 if successful 
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param mintAmount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    /// @notice Redeems tokens from the yield source from the msg.sender, it burn yield bearing tokens and return token to the sender.
    /// @param redeemAmount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    /// @notice Transfer ERC20 tokens other than the idleTokens held by this contract to the recipient address
    /// @dev This function is only callable by the owner or asset manager
    /// @param erc20Token The ERC20 token to transfer
    /// @param to The recipient of the tokens
    /// @param amount The amount of tokens to transfer
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1555.0,160.0,"[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource
The `redeemToken` function in `IdleYieldSource` uses redeemedShare instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should.
When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the tokenPriceWithFee() is greater than ONE_IDLE_TOKEN, and thus redeemedShare is less than redeemAmount, causing users to get fewer underlying tokens than expected.
  [H-05] IdleYieldSource doesn't use mantissa calculations
Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given.
For example, say I deposit 1 token, expecting 1 share in return. On L95, if the `totalUnderlyingAssets` is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares.
Recommend implementing mantissa calculations like in the contract for the AAVE yield.
  [M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits
Function `timelockDepositTo` The contract uses `_msgSender()` to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be.
While the code handles this separation of role in most cases, it misses doing so in `timelockDepositTo()` function where it accounts the `_timelockBalances` to the operator address instead of the user specified to address. It assumes they are the same. The corresponding usage in _mintTimelock() which is called from withdrawWithTimelockFrom() uses the user specified 'from' address and not the _msgSender(). Therefore the corresponding usage in timelockDepositTo() should be the same.
In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator’s address does not have the required amount of _timelockBalances.",3.0,"pragma solidity 0.8.4;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol""; 
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""./interfaces/pooltogether/IProtocolYieldSource.sol"";
import ""./interfaces/idle/IIdleToken.sol"";
import ""./interfaces/idle/IIdleTokenHelper.sol"";
import ""./access/AssetManager.sol"";



contract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {
    using SafeERC20Upgradeable for IERC20Upgradeable;

    address public idleToken;
    address public underlyingAsset;
    uint256 public totalUnderlyingAssets;

    
    event IdleYieldSourceInitialized(address indexed idleToken);

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event Sponsored(
        address indexed from,
        uint256 amount
    );

    
    event TransferredERC20(
        address indexed from,
        address indexed to,
        uint256 amount,
        address indexed token
    );

    
    
    function initialize(
        address _idleToken
    ) public initializer {

        __Ownable_init();

        idleToken = _idleToken;
        underlyingAsset = IIdleToken(idleToken).token();

        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);
        emit IdleYieldSourceInitialized(idleToken);
    }

    
    
    function depositToken() external view override returns (address) {
        return (underlyingAsset);
    }

    
    
    function balanceOfToken(address addr) external view override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    function _totalShare() internal view returns(uint256) {
        return IIdleToken(idleToken).balanceOf(address(this));
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(_totalShare() == 0) {
            shares = tokens;
        } else {
            shares = (tokens * _totalShare())  / totalUnderlyingAssets;
        }
    }

    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { 
        if(_totalShare() == 0) {
            tokens = shares;
        } else {
            tokens = (shares * totalUnderlyingAssets) / _totalShare();
        }
    }

    
    
    
    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {
        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 mintedTokens = IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));
        return mintedTokens;
    }

    
    
    
    function supplyTokenTo(uint256 mintAmount, address to) public nonReentrant override {
        uint256 mintedTokenShares = _depositToIdle(mintAmount);
        _mint(to, mintedTokenShares);
        totalUnderlyingAssets = totalUnderlyingAssets + mintAmount;
        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);
    }

    
    
    
    function redeemToken(uint256 redeemAmount) public override nonReentrant returns (uint256) {
        uint256 _idleShare = _tokenToShares(redeemAmount);
        _burn(msg.sender, _idleShare);
        totalUnderlyingAssets = totalUnderlyingAssets - redeemAmount;
        uint256 redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(_idleShare);
        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);
        emit RedeemedToken(msg.sender, _idleShare, redeemAmount);
        return redeemedUnderlyingAsset;
    }

    
    
    
    
    
    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {
        require(address(erc20Token) != address(idleToken), ""IdleYieldSource/idleDai-transfer-not-allowed"");
        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);
        emit TransferredERC20(msg.sender, to, amount, erc20Token);
    }

    
    
    
    function sponsor(uint256 amount) external override {
        _depositToIdle(amount);
        emit Sponsored(msg.sender, amount);
    }
}",1010.0,2,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Underlying Asset Tracking**  
   The `totalUnderlyingAssets` state variable does not reflect the actual value of the underlying assets held in the IdleToken. This variable is manually incremented/decremented during deposits/redemptions but does not account for interest, losses, or sponsored deposits. Share calculations (`_tokenToShares`/`_sharesToToken`) become inaccurate, leading to unfair minting/burning of shares.

2. **Uninitialized ERC20 Metadata**  
   The contract inherits `ERC20Upgradeable` but fails to initialize the token's **name**, **symbol**, and **decimals** in the `initialize` function. This breaks ERC20 compliance and interoperability with external systems expecting these values.

3. **Sponsor Function Accounting Error**  
   The `sponsor` function deposits assets into IdleToken without updating `totalUnderlyingAssets`. This dilutes the value of existing shares, as the contract’s shares-to-assets ratio becomes skewed compared to the actual IdleToken holdings.

4. **Mismatch in Redeemed Amount Handling**  
   `redeemToken` subtracts the user-provided `redeemAmount` from `totalUnderlyingAssets` instead of the actual amount returned by `redeemIdleToken`. Fees, slippage, or interest in IdleToken will cause `totalUnderlyingAssets` to deviate from reality, leading to incorrect future calculations.

5. **Missing Reentrancy Guard on `sponsor`**  
   The `sponsor` function lacks the `nonReentrant` modifier. If the underlying asset is a malicious contract, reentrancy during `safeTransferFrom` could manipulate the contract’s state (e.g., multiple sponsorships before state updates).

6. **Inaccurate Share Conversion Logic**  
   Share conversions depend on `totalUnderlyingAssets` and `_totalShare()`, but the former is not synced with real asset value. For example, interest accrual in IdleToken is ignored, causing users to receive incorrect shares during deposits/redemptions.

7. **Underlying Asset Drain via `transferERC20`**  
   The `transferERC20` function allows the owner to transfer the `underlyingAsset` (e.g., DAI) if it is accidentally held in the contract (not converted to IdleToken). This could result in loss of user funds if the underlying asset is improperly retained.","### **Output**

---

**[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**

**Report Description**:  
The `redeemToken` function in `IdleYieldSource` uses `redeemedShare` instead of `redeemAmount` as the input parameter when calling `redeemIdleToken` of the Idle yield source. As a result, users could get fewer underlying tokens than they should. When burning users' shares, it is correct to use `redeemedShare` (line 130). However, when redeeming underlying tokens from Idle Finance, `redeemAmount` should be used instead of `redeemedShare` (line 131). Usually, the `tokenPriceWithFee()` is greater than `ONE_IDLE_TOKEN`, and thus `redeemedShare` is less than `redeemAmount`, causing users to get fewer underlying tokens than expected.

**Match in Response List**:  
Matches with the issue titled **""Mismatch in Redeemed Amount Handling""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the mismatch in handling the redeemed amount in the `redeemToken` function. It correctly explains the risks associated with using `redeemAmount` instead of `redeemedShare`, which aligns with the reported issue.

---

**[H-05] IdleYieldSource doesn't use mantissa calculations**

**Report Description**:  
Because mantissa calculations are not used in this case to account for decimals, the arithmetic can zero out the number of shares or tokens that should be given. For example, say I deposit 1 token, expecting 1 share in return. On line 95, if the `totalUnderlyingAssets` is increased to be larger than the number of total shares, then the division would output 0 and I wouldn't get any shares. Recommend implementing mantissa calculations like in the contract for the AAVE yield.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the lack of mantissa calculations in the `IdleYieldSource` contract, which is a critical issue affecting share and token calculations.

---

**[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

**Report Description**:  
Function `timelockDepositTo`. The contract uses `_msgSender()` to denote an operator who is operating on behalf of the user. This is typically used for meta-transactions where the operator is an intermediary/relayer who may facilitate gas-less transactions on behalf of the user. They may be the same address but it is safer to assume that they may not be. While the code handles this separation of role in most cases, it misses doing so in `timelockDepositTo()` function where it accounts the `_timelockBalances` to the operator address instead of the user specified `to` address. It assumes they are the same. The corresponding usage in `_mintTimelock()` which is called from `withdrawWithTimelockFrom()` uses the user specified 'from' address and not the `_msgSender()`. Therefore the corresponding usage in `timelockDepositTo()` should be the same. In the scenario where the operator address != user specified from/to addresses, i.e. meta-transactions, the timelock deposits and withdrawals are made to/from different addresses and so the deposits of timelocked tokens will fail because the operator’s address does not have the required amount of `_timelockBalances`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Missed Issue**. The response list does not address the issue with the assumption that the operator and user addresses are the same in the `timelockDepositTo` function, which could lead to failed timelock deposits in meta-transaction scenarios.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-01] User could lose underlying tokens when redeeming from the IdleYieldSource**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-05] IdleYieldSource doesn't use mantissa calculations**
- **[M-04] The assumption that operator == to (user) may not hold leading to failed timelock deposits**

---",1,0,2,7,"Okay, let me try to figure out the vulnerabilities in this smart contract. So, the contract is called IdleYieldSource and it's using OpenZeppelin's upgradeable contracts. It also imports some interfaces from PoolTogether and Idle, and it's an ERC20 token. 

First, I'll look for common vulnerabilities like reentrancy, even though there's a ReentrancyGuardUpgradeable. But wait, the functions supplyTokenTo and redeemToken are marked as nonReentrant, so that's probably covered. But maybe there's something else.

Looking at the initialize function: it's initializing the contract, setting up the idleToken and underlyingAsset. They approve the idleToken with max uint256. That's okay as long as the idleToken is trusted. But if the idleToken is malicious, that could be a problem. But maybe that's a trust assumption, not a vulnerability.

The _tokenToShares and _sharesToToken functions calculate shares based on totalUnderlyingAssets and the balance of idleToken. Wait, totalUnderlyingAssets is a state variable that's being updated in supplyTokenTo and redeemToken. But when you deposit, it adds mintAmount to totalUnderlyingAssets. But when you redeem, subtracts redeemAmount. However, the actual underlying amount in IdleToken might not match totalUnderlyingAssets. Because IdleToken's value can change due to interest or losses. So the contract's totalUnderlyingAssets is a tracked variable, but maybe it's not in sync with the actual underlying tokens. That could lead to incorrect share calculations.

For example, suppose the IdleToken's underlying value increases because of interest. But totalUnderlyingAssets in this contract doesn't account for that. So when new deposits come in, the shares would be calculated based on an incorrect total. That would mean that existing users' shares are diluted because the totalUnderlyingAssets is not reflecting the actual value. That's a big issue. Because the contract's totalUnderlyingAssets is just a variable that's increased by deposits and decreased by withdrawals, but the actual underlying assets in IdleToken can appreciate or depreciate. So the share calculation should be based on the actual value of the IdleToken holdings, not the stored totalUnderlyingAssets.

Another thing: when you call redeemToken, it burns shares based on the redeemAmount converted via _tokenToShares. But if the IdleToken's value has changed, the redeemedUnderlyingAsset might be different than the redeemAmount. Wait, the code says:

redeemAmount is the amount in terms of underlying asset. So, when the user wants to redeem X tokens, the contract converts that to shares using _tokenToShares(redeemAmount), which uses the current totalUnderlyingAssets and _totalShare() (which is the balance of idleToken in the contract). But totalUnderlyingAssets is not the actual value, but a stored variable. So if the IdleToken's value has increased, totalUnderlyingAssets is less than the real value, leading to more shares being burned than necessary. For example:

Suppose totalUnderlyingAssets is 100, and the actual IdleToken balance is worth 110 (due to interest). Then _totalShare() would be, say, 100 (if each share was 1:1). Then when someone redeems 10 tokens, shares would be (10 * 100) / 100 = 10 shares. But redeeming 10 shares of IdleToken (which is worth 11 tokens now) would give the user 11, but the contract subtracts 10 from totalUnderlyingAssets. That would cause the totalUnderlyingAssets to be 90, but the actual value is 100 (110 - 10*1.1). So this discrepancy would accumulate over time, leading to incorrect accounting. This is a critical flaw because the share calculations don't track the actual value of the underlying assets.

Another possible issue: the sponsor function deposits an amount but doesn't mint any shares. So when someone sponsors, they're increasing the IdleToken balance of the contract, but totalUnderlyingAssets is increased by the amount (through _depositToIdle which calls supplyTokenTo's internal function? Wait no, sponsor calls _depositToIdle(amount), which mints idleTokens and returns mintedTokens, but in sponsor function, it doesn't do anything with the mintedTokens. Wait, no. Let me check:

The sponsor function calls _depositToIdle(amount). The _depositToIdle function transfers the underlyingAsset from the sender to the contract, then mints idleToken. The mintedTokens variable is the amount of idleToken received. However, the sponsor function doesn't mint any shares (ERC20 tokens) to anyone. So those idleTokens are owned by the contract but aren't accounted for in the totalUnderlyingAssets. Wait, no, in _depositToIdle, when you call IIdleToken(idleToken).mintIdleToken(mintAmount, ...), that mints idleToken to the contract. Then in the sponsor function, the code does not update totalUnderlyingAssets. Wait, no. The supplyTokenTo function does add to totalUnderlyingAssets, but the sponsor function does not call supplyTokenTo. Instead, sponsor calls _depositToIdle(amount) directly, which mints the idleToken but does not update totalUnderlyingAssets. So the totalUnderlyingAssets remains the same. Therefore, the idleTokens deposited via sponsor are not reflected in totalUnderlyingAssets. So when calculating shares, those idleTokens are part of the _totalShare() (since that's the balance of idleToken in the contract), but totalUnderlyingAssets hasn't been increased by the sponsored amount. This would cause the ratio between shares and tokens to be incorrect. For example, if totalUnderlyingAssets is 100, and someone sponsors 10, then the contract's idleToken balance increases by 10 (assuming 1:1), but totalUnderlyingAssets remains 100. Then, when someone else deposits, the shares are calculated as (mintAmount * totalShare) / totalUnderlyingAssets. But totalShare is now 110 (original 100 + sponsored 10), and totalUnderlyingAssets is 100. So depositing 10 would give (10 * 110) / 100 = 11 shares. But the actual underlying is 110 +10 =120? Wait, maybe not. The sponsor's deposited amount is part of the idleToken's underlying, so the total underlying in the idleToken is higher. But the contract's totalUnderlyingAssets variable is not tracking that. So the accounting is off.

This leads to incorrect minting and burning of shares. Essentially, the totalUnderlyingAssets is a broken accounting variable because it's not tracking the actual underlying assets held in the IdleToken. Instead, it's only updated when users deposit or redeem through supplyTokenTo and redeemToken, but not when the IdleToken's underlying value changes due to interest, or when someone sponsors (since sponsor adds to idleToken but not to totalUnderlyingAssets). This would cause the value per share to be miscalculated, leading to users being able to mint more shares than they should, or redeem more/less than they should.

Another issue: the ERC20Upgradeable is initialized but the __ERC20_init function isn't called. Wait, looking at the contract definition: the contract is Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager. In the initialize function, they call __Ownable_init(). But ERC20Upgradeable requires that __ERC20_init is called with a name and symbol. However, in this contract's initialize function, they don't initialize the ERC20. That's a problem because the ERC20 contract's name, symbol, and decimals aren't set. This would cause the ERC20 functions to fail or have default empty values. So when someone tries to call name(), symbol(), or decimals(), it would return empty strings or 0, which is incorrect. This is a critical issue because the ERC20 token would not function properly.

Also, the contract inherits from AssetManager. Need to check what that does. The import is ""./access/AssetManager.sol"". Assuming that AssetManager has a onlyOwnerOrAssetManager modifier. In the transferERC20 function, that modifier is used. But the problem here is that transferring ERC20 tokens (other than idleToken) is allowed by the owner or asset manager. However, if the underlyingAsset is another token, the owner could drain it. Wait, the transferERC20 function requires that the token is not the idleToken. But the underlyingAsset could be a different token. For example, if the underlyingAsset is DAI, and someone calls transferERC20 with DAI, then they could drain all DAI in the contract. But the contract is supposed to hold the underlyingAsset in the idleToken. Wait, no: the underlyingAsset is the token that the idleToken wraps. So when you deposit underlyingAsset, it's converted to idleToken. So the contract's balance of underlyingAsset should be zero, except when in the middle of a deposit or redeem. However, if there's a balance of underlyingAsset in the contract (due to a sponsorship, perhaps), then the owner could transfer it out. But the sponsor function deposits into idleToken, so underlyingAsset should be transferred to idleToken. Wait, in sponsor, _depositToIdle is called, which does safeTransferFrom the sender to the contract, then mints idleToken. So the underlyingAsset is sent to the contract, then to idleToken. So after sponsor, the contract's underlyingAsset balance should be zero. But if there's a miscalculation or someone sends underlyingAsset directly to the contract, then the owner could transfer it out. But that's maybe intentional. However, the transferERC20 function allows the owner to transfer any ERC20 except idleToken. So if there's any other ERC20 tokens accidentally sent to the contract, the owner can recover them. That's probably okay, but if the underlyingAsset is allowed to be transferred out, that's a problem. Because the contract's accounting (totalUnderlyingAssets) assumes that all underlyingAsset is held in idleToken. But if the owner transfers out underlyingAsset, then the actual balance is less than what's accounted for. For example, suppose the contract has 100 underlyingAsset (not in idleToken), and the owner transfers it out. Then totalUnderlyingAssets is still 100, but the actual underlyingAsset is gone. But how would that underlyingAsset get there? Only via depositTokenTo or sponsor, but those functions should convert the underlyingAsset to idleToken. Unless there's a way for the underlyingAsset to be in the contract without being converted. For example, if someone accidentally sends underlyingAsset directly to the contract. In that case, the owner can transfer it out, but that's a privilege. However, this could be a backdoor for the owner to steal funds if there's any underlyingAsset stuck in the contract. But maybe that's by design. However, the main issue here is if the underlyingAsset is sent to the contract outside of deposit/sponsor, then the owner can take it. But the problem is that the contract's totalUnderlyingAssets variable doesn't track that. So if someone sends underlyingAsset directly, the totalUnderlyingAssets doesn't increase, but the owner can transfer it out. Not sure if that's a vulnerability, but it's a possible privilege escalation.

Another possible issue is the use of SafeERC20Upgradeable. The contract uses safeTransfer and safeTransferFrom, which is good. But what about the decimals? If the underlyingAsset has different decimals than the ERC20 shares, that could cause issues. But the contract's ERC20 shares are supposed to represent shares in the underlying, but since the ERC20 isn't initialized with a name, symbol, or decimals, that's a problem as mentioned before.

Another thing: the _depositToIdle function uses mintIdleToken with 'false' for some parameter. Looking at the IIdleToken interface, the mintIdleToken function's parameters might include a flag for whether to use a referral address or not. The third parameter here is address(0), which might be a referral address. If passing address(0) is allowed, that's fine. But maybe there's a potential for referral bonuses that the contract isn't handling. Not sure if that's a vulnerability.

Reentrancy in the sponsor function: the sponsor function calls _depositToIdle, which does a safeTransferFrom. If the underlyingAsset is a malicious ERC20 that calls back into the contract, but since the sponsor function is not marked as nonReentrant, that could be a problem. Wait, the sponsor function isn't marked as nonReentrant. Let me check:

The supplyTokenTo and redeemToken functions are nonReentrant. The sponsor function is not. So if the underlyingAsset's transferFrom is a malicious contract that reenters into the IdleYieldSource's functions, like sponsor again, it could cause some reentrancy issues. But since the contract uses ReentrancyGuardUpgradeable, but the sponsor function doesn't have the nonReentrant modifier, this could be a possible attack vector. For example, during the safeTransferFrom in _depositToIdle, a malicious token could call back into the sponsor function, which would allow multiple deposits before the state is updated. However, since the sponsor function doesn't update any state variables (except emitting an event), maybe it's not a problem. Wait, the sponsor function calls _depositToIdle, which does a transferFrom and mints idleToken. The state change here is that the contract's idleToken balance increases, but totalUnderlyingAssets is not modified (since sponsor does not add to it). The totalUnderlyingAssets is only modified in supplyTokenTo and redeemToken. So if a reentrancy occurs during sponsor, the main issue is that the idleToken's mint could be manipulated. But since the idleToken is presumably a trusted contract (as it's part of the integration), this might not be a problem. However, the lack of reentrancy guard on the sponsor function could still be an issue if the underlyingAsset is malicious. But the sponsor function is external and can be called by anyone. So an attacker could potentially cause reentrancy here. However, since the ReentrancyGuard is inherited, but the sponsor function is not marked with nonReentrant, this is a possible vulnerability.

Also, in the redeemToken function, after burning the shares, it subtracts redeemAmount from totalUnderlyingAssets. But the actual amount redeemed could be different. For example, if the IdleToken's redeemIdleToken function returns less or more than redeemAmount. Wait, the code says:

redeemAmount is the amount the user wants to redeem in underlying. The function converts that to shares via _tokenToShares(redeemAmount). Then, it calls IIdleToken(idleToken).redeemIdleToken(_idleShare), which returns the actual amount of underlyingAsset redeemed. However, the contract subtracts redeemAmount from totalUnderlyingAssets, not the actual redeemed amount. So if the redeemed amount is different (due to fees, or loss/gain in the idleToken), then the totalUnderlyingAssets becomes incorrect. For example, if redeeming _idleShare shares actually gives more underlyingAsset than redeemAmount, then totalUnderlyingAssets would be reduced by redeemAmount, but the actual underlying in the contract (via idleToken) would have decreased by more. This would make the accounting wrong. This is another critical issue because the contract assumes that the redeemAmount equals the actual underlying redeemed, which may not be the case.

For example, suppose the IdleToken has a fee on redemption. When you redeem _idleShare shares, you get less than the expected redeemAmount. Then, totalUnderlyingAssets is subtracted by redeemAmount, which is higher than the actual amount taken out of idleToken. So the totalUnderlyingAssets would be less than the actual underlying in idleToken, leading to incorrect share calculations.

Alternatively, if the IdleToken's redemption returns more than the redeemAmount (unlikely, but possible if there's a profit), then totalUnderlyingAssets would be under-subtracted, leading to inflation of shares.

So the core issue here is that the contract's totalUnderlyingAssets variable is not properly synced with the actual underlying value of the idleToken holdings. All the share calculations are based on this variable, which can be out of sync, leading to incorrect minting and burning of shares.

Another possible issue is the use of the initializer modifier in the initialize function. Since the contract is upgradeable, it's important that the initialize function can only be called once. OpenZeppelin's Initializable does that, but the contract's initialize function is public, so it's possible that someone could call it again if it's not properly secured. Wait, the initialize function is marked with 'initializer', which is a modifier from OpenZeppelin that ensures the function can only be called once. So that's probably okay.

So summarizing the vulnerabilities:

1. **Incorrect Accounting of Underlying Assets**: The contract uses a manually tracked `totalUnderlyingAssets` variable which does not reflect the actual underlying value of the IdleToken holdings. This leads to incorrect share calculations during deposits, redemptions, and sponsor actions. The actual value of the IdleToken can change due to interest or losses, but `totalUnderlyingAssets` is not updated accordingly.

2. **Uninitialized ERC20 Token**: The contract inherits from ERC20Upgradeable but does not call the `__ERC20_init` function during initialization. This results in the ERC20 token not having a name, symbol, or decimals, which will cause issues with wallets, exchanges, and other contracts that rely on these values.

3. **Sponsor Function Miscalculations**: The `sponsor` function deposits underlying assets into IdleToken but does not update `totalUnderlyingAssets`. This discrepancy causes the ratio between shares and underlying assets to become incorrect, leading to improper minting and redemption values for users.

4. **Incorrect Redemption Handling**: The `redeemToken` function subtracts `redeemAmount` from `totalUnderlyingAssets` instead of the actual amount redeemed from the IdleToken. This can lead to underflow or overflow in `totalUnderlyingAssets` if the redeemed amount differs from expected (due to fees, interest, etc.).

5. **Potential Reentrancy in Sponsor Function**: The `sponsor` function lacks the `nonReentrant` modifier, which could allow reentrancy attacks if the underlying asset is a malicious ERC20 token. This could potentially be exploited, although the risk might be mitigated if the underlying asset is trusted.

6. **Inaccurate Share Conversion**: The `_tokenToShares` and `_sharesToToken` functions rely on `totalUnderlyingAssets` and `_totalShare()`, but since `totalUnderlyingAssets` is not accurately tracking the real value, these conversions will be incorrect. This can result in users receiving more or fewer shares than they should, leading to loss of funds or unfair distribution.

7. **Transfer of Underlying Asset via transferERC20**: The `transferERC20` function allows the owner to transfer any ERC20 token except the idleToken. If the underlying asset (e.g., DAI) is accidentally held in the contract (not converted to idleToken), the owner could drain it, leading to a mismatch between `totalUnderlyingAssets` and the actual holdings.

Each of these points represents a vulnerability that could be exploited or lead to unintended behavior in the contract.","```
1. Mismatch in Redeemed Amount Handling
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks at which the true positives appear in the ranked list of predictions**:
   - The true positive is ""Mismatch in Redeemed Amount Handling"".
   - This appears at rank 4 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 4 (\( P@4 \)) is calculated as the number of true positives up to rank 4 divided by 4.
   - Since there is only one true positive up to rank 4, \( P@4 = \frac{1}{4} = 0.25 \).

3. **Average the precision values for all true positives**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 0.25 \).

**Output**:
```
0.25
```"
YearnV2YieldSource.sol,"// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";


/// @title Yield source for a PoolTogether prize pool that generates yield by depositing into Yearn Vaults.
/// @dev This contract inherits from the ERC20 implementation to keep track of users deposits
/// @dev This is a generic contract that will work with main Yearn Vaults. Vaults using v0.3.2 to v0.3.4 included
/// @dev are not compatible, as they had dips in shareValue due to a small miscalculation
/// @notice Yield Source Prize Pools subclasses need to implement this interface so that yield can be generated.
contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    /// @notice Yearn Vault which manages `token` to generate yield
    IYVaultV2 public vault;
    /// @dev Deposit Token contract address
    IERC20Upgradeable internal token; 
    /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS
    uint256 public maxLosses = 0; // 100% would be 10_000

    /// @notice Emitted when asset tokens are supplied to sponsor the yield source
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    /// @notice Emitted when the yield source is initialized
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    /// @notice Emitted when the Max Losses accepted when withdrawing from yVault are changed
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    /// @notice Emitted when asset tokens are supplied to the yield source
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    /// @notice Emitted when asset tokens are redeemed from the yield source
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    /// @notice Initializes the yield source with 
    /// @param _vault YearnV2 Vault in which the Yield Source will deposit `token` to generate Yield
    /// @param _token Underlying Token / Deposit Token
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        // NOTE: Vaults from 0.3.2 to 0.3.4 have dips in shareValue
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    /// @notice Returns the ERC20 asset token used for deposits
    /// @return The ERC20 asset token address
    function depositToken() external view override returns (address) {
        return address(token);
    }

    /// @notice Returns user total balance (in asset tokens). This includes the deposits and interest.
    /// @param addr User address
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    /// @notice Supplies asset tokens to the yield source
    /// @dev Shares corresponding to the number of tokens supplied are mint to the user's balance
    /// @dev Asset tokens are supplied to the yield source, then deposited into Aave
    /// @param _amount The amount of asset tokens to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        // NOTE: we have to deposit after calculating shares to mint
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    /// @notice Redeems asset tokens from the yield source
    /// @dev Shares corresponding to the number of tokens withdrawn are burnt from the user's balance
    /// @dev Asset tokens are withdrawn from Yearn's Vault, then transferred from the yield source to the user's wallet
    /// @param amount The amount of asset tokens to be redeemed
    /// @return The actual amount of tokens that were redeemed
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    /// @notice Allows someone to deposit into the yield source without receiving any shares
    /// @dev This allows anyone to distribute tokens among the share holders
    /// @param amount The amount of tokens to deposit
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    // ************************ INTERNAL FUNCTIONS ************************

    /// @notice Deposits full balance (or max available deposit) into Yearn's Vault
    /// @dev if deposit limit is reached, tokens will remain in the Yield Source and
    /// @dev they will be queued for retries in subsequent deposits
    /// @return The actual amount of shares that were received for the deposited tokens
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; // NOTE: for gas usage
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        // this will deposit full balance (for cases like not enough room in Vault)
        return v.deposit();
    }

    /// @notice Withdraws requested amount from Vault
    /// @dev Vault withdrawal function required amount of shares to be redeemed
    /// @dev Losses are accepted by the Yield Source to avoid funds being locked in the Vault if something happened
    /// @param amount amount of asset tokens to be redeemed
    /// @return Tokens received from the Vault
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        // we accept losses to avoid being locked in the Vault (if losses happened for some reason)
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    /// @notice Returns the amount of shares of yearn's vault that the Yield Source holds
    /// @return Balance of vault's shares holded by Yield Source
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    /// @notice Ratio between yShares and underlying token
    /// @dev use this to convert from shares to deposit tokens and viceversa
    /// @dev (see _tokenToYShares & _ySharesToToken)
    /// @return Price per vault's share
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    /// @notice Balance of deposit token held in the Yield Source
    /// @return balance of deposit token
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    /// @notice Total Assets under Management by Yield Source, denominated in Deposit Token
    /// @dev amount of deposit token held in Yield Source + investment (amount held in Yearn's Vault)
    /// @return Total AUM denominated in deposit Token
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    /// @notice Support function to retrieve used by Vault
    /// @dev used to correctly scale prices 
    /// @return decimals of vault's shares (and underlying token)
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    // ************************ CALCS ************************

    /// @notice Converter from deposit token to yShares (yearn vault's shares)
    /// @param tokens Amount of tokens to be converted
    /// @return yShares to redeem to receive `tokens` deposit token
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    /// @notice Converter from deposit yShares (yearn vault's shares) to token 
    /// @param yShares Vault's shares to be converted
    /// @return tokens that will be received if yShares shares are redeemed
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    /// @notice Function to calculate the amount of Yield Source shares equivalent to a deposit tokens amount
    /// @param tokens amount of tokens to be converted
    /// @return shares number of shares equivalent to the amount of tokens
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    /// @notice Function to calculate the amount of Deposit Tokens equivalent to a Yield Source shares amount
    /// @param shares amount of Yield Source shares to be converted
    /// @dev used to calculate how many shares to mint / burn when depositing / withdrawing
    /// @return tokens number of tokens equivalent (in value) to the amount of Yield Source shares
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    /// @notice Pure support function to compare strings
    /// @param a One string
    /// @param b Another string
    /// @return Whether or not the strings are the same or not
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",2782.0,280.0,"[H-02] YearnV2YieldSource wrong subtraction in withdraw
When withdrawing function `_withdrawFromVault` from the `vault`, one redeems `yTokens` for `tokens`, thus the `token` balance of the contract should increase after withdrawal. But the contract subtracts the `currentBalance` from the `previousBalance`:
``` uint256 yShares = _tokenToYShares(amount);
uint256 previousBalance = token.balanceOf(address(this));
// we accept losses to avoid being locked in the Vault (if losses happened for some reason)
if(maxLosses != 0) {
    vault.withdraw(yShares, address(this), maxLosses);
} else {
    vault.withdraw(yShares);
}
uint256 currentBalance = token.balanceOf(address(this));
// @audit-issue this seems wrong
return previousBalance.sub(currentBalance);
```
All vault withdrawals fail due to the integer underflow as the `previousBalance` is less than `currentBalance`. Users won't be able to get back their investment.
  [M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS
The `_depositInVault()` function for Yearn yield source uses ERC20 `safeApprove()` from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.
However, the `safeApprove` function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the `safeIncreaseAllowance` and `safeDecreaseAllowance` functions should be used. Comment from the OZ library for this function:
“// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'""
If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible. See similar Medium-severity finding M03.",2.0,"pragma solidity 0.6.12;

import ""../interfaces/IYieldSource.sol"";
import ""../external/yearn/IYVaultV2.sol"";

import ""@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";







contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeMathUpgradeable for uint;
    
    
    IYVaultV2 public vault;
    
    IERC20Upgradeable internal token; 
    
    uint256 public maxLosses = 0; 

    
    event Sponsored(
        address indexed user,
        uint256 amount
    );
    
    
    event YieldSourceYearnV2Initialized(
        IYVaultV2 vault,
        IERC20Upgradeable token
    );

    
    event MaxLossesChanged(
        uint256 newMaxLosses
    );

    
    event SuppliedTokenTo(
        address indexed from,
        uint256 shares,
        uint256 amount,
        address indexed to
    );

    
    event RedeemedToken(
        address indexed from,
        uint256 shares,
        uint256 amount
    );

    
    
    
    function initialize(
        IYVaultV2 _vault,
        IERC20Upgradeable _token
    ) 
        public 
        initializer
    {
        require(address(vault) == address(0), ""YearnV2YieldSource:: already initialized"");
        require(_vault.token() == address(_token), ""YearnV2YieldSource:: incorrect vault"");
        require(_vault.activation() != uint256(0), ""YearnV2YieldSource:: vault not initialized"");
        
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.2""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.3""), ""YearnV2YieldSource:: vault not compatible"");
        require(!areEqualStrings(_vault.apiVersion(), ""0.3.4""), ""YearnV2YieldSource:: vault not compatible"");

        vault = _vault;
        token = _token;

        __Ownable_init();
        __ReentrancyGuard_init();

        _token.safeApprove(address(vault), type(uint256).max);

        emit YieldSourceYearnV2Initialized(
            _vault,
            _token
        );
    }

    function setMaxLosses(uint256 _maxLosses) external onlyOwner {
        require(_maxLosses <= 10_000, ""YearnV2YieldSource:: losses set too high"");

        maxLosses = _maxLosses;

        emit MaxLossesChanged(_maxLosses);
    }

    
    
    function depositToken() external view override returns (address) {
        return address(token);
    }

    
    
    
    function balanceOfToken(address addr) external override returns (uint256) {
        return _sharesToToken(balanceOf(addr));
    }

    
    
    
    
    
    function supplyTokenTo(uint256 _amount, address to) external override nonReentrant {
        uint256 shares = _tokenToShares(_amount);

        _mint(to, shares);

        
        token.safeTransferFrom(msg.sender, address(this), _amount);

        _depositInVault();

        emit SuppliedTokenTo(msg.sender, shares, _amount, to);
    }

    
    
    
    
    
    function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
        uint256 shares = _tokenToShares(amount);

        uint256 withdrawnAmount = _withdrawFromVault(amount);

        _burn(msg.sender, shares);

        token.safeTransfer(msg.sender, withdrawnAmount);

        emit RedeemedToken(msg.sender, shares, amount);
        return withdrawnAmount;
    }

    
    
    
    function sponsor(uint256 amount) external nonReentrant {
        token.safeTransferFrom(msg.sender, address(this), amount);

        _depositInVault();

        emit Sponsored(msg.sender, amount);
    }

    

    
    
    
    
    function _depositInVault() internal returns (uint256) {
        IYVaultV2 v = vault; 
        if(token.allowance(address(this), address(v)) < token.balanceOf(address(this))) {
            token.safeApprove(address(v), type(uint256).max);
        }
        
        return v.deposit();
    }

    
    
    
    
    
    function _withdrawFromVault(uint amount) internal returns (uint256) {
        uint256 yShares = _tokenToYShares(amount);
        uint256 previousBalance = token.balanceOf(address(this));
        
        if(maxLosses != 0) {
            vault.withdraw(yShares, address(this), maxLosses);
        } else {
            vault.withdraw(yShares);
        }
        uint256 currentBalance = token.balanceOf(address(this));

        return previousBalance.sub(currentBalance);
    }

    
    
    function _balanceOfYShares() internal view returns (uint256) {
        return vault.balanceOf(address(this));
    }

    
    
    
    
    function _pricePerYShare() internal view returns (uint256) {
        return vault.pricePerShare();
    }

    
    
    function _balanceOfToken() internal view returns (uint256) {
        return token.balanceOf(address(this));
    }

    
    
    
    function _totalAssetsInToken() internal view returns (uint256) {
        return _balanceOfToken().add(_ySharesToToken(_balanceOfYShares()));
    }

    
    
    
    function _vaultDecimals() internal view returns (uint256) {
        return vault.decimals();
    }

    

    
    
    
    function _tokenToYShares(uint256 tokens) internal view returns (uint256) {
        return tokens.mul(10 ** _vaultDecimals()).div(_pricePerYShare());
    }

    
    
    
    function _ySharesToToken(uint256 yShares) internal view returns (uint256) {
        return yShares.mul(_pricePerYShare()).div(10 ** _vaultDecimals());
    }

    
    
    
    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {
        if(totalSupply() == 0) {
            shares = tokens;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            shares = tokens.mul(totalSupply()).div(_totalTokens);
        }
    }

    
    
    
    
    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) {
        if(totalSupply() == 0) {
            tokens = shares;
        } else {
            uint256 _totalTokens = _totalAssetsInToken();
            tokens = shares.mul(_totalTokens).div(totalSupply());
        }
    }

    
    
    
    
    function areEqualStrings(string memory a, string memory b) internal pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}",1523.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Share Burning During Redemption**  
   The `redeemToken` function burns shares based on the user-requested token amount (`amount`) instead of the actual tokens withdrawn (`withdrawnAmount`). If the vault withdrawal incurs losses (due to `maxLosses`), users lose more shares than the value of tokens received, leading to unfair value redistribution.

2. **Donation Attack Vulnerability**  
   The contract is vulnerable to front-running attacks where an attacker can ""donate"" tokens (via `sponsor` or direct transfers) before the first deposit. This dilutes the initial depositor's shares, allowing them to claim a disproportionate share of the total pool, effectively stealing donated funds.

3. **Missing ERC20 Metadata Initialization**  
   The contract inherits `ERC20Upgradeable` but does not initialize the token's `name` and `symbol` in the `initialize` function. This results in an ERC20 token with empty metadata, causing integration issues with wallets, explorers, and other protocols.

4. **Insecure Vault API Version Check**  
   The contract checks the vault's `apiVersion` during initialization but does not account for future upgrades of the vault. If the vault is later upgraded to an incompatible version, the contract will continue interacting with it, potentially introducing vulnerabilities.

5. **Incorrect Withdrawal Amount Tracking**  
   The `_withdrawFromVault` function calculates the withdrawn token amount as the difference between the contract's token balance before and after withdrawal. This method is unreliable if the contract holds tokens outside the vault (e.g., from `sponsor`), leading to incorrect withdrawal accounting.

6. **Unbounded Vault Allowance**  
   The contract grants infinite approval (`type(uint256).max`) to the vault during initialization and in `_depositInVault`. If the vault is compromised, attackers could drain all approved tokens from the contract.

7. **Lack of Input Validation in `sponsor`**  
   The `sponsor` function allows arbitrary token amounts to be deposited without checks, enabling potential manipulation of share calculations or token balances.

These vulnerabilities affect the contract's security, fairness, and reliability.","### **[H-02] YearnV2YieldSource wrong subtraction in withdraw**

**Report Description**:  
The `_withdrawFromVault` function in the YearnV2YieldSource contract incorrectly calculates the withdrawn token amount by subtracting the `currentBalance` from the `previousBalance`. Since the `currentBalance` is expected to be higher than the `previousBalance` after a successful withdrawal, this subtraction results in an integer underflow, causing all withdrawals to fail. This prevents users from retrieving their investments, leading to a critical loss of funds.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Withdrawal Amount Tracking""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the withdrawal amount calculation in the `_withdrawFromVault` function. It correctly explains that the method of tracking withdrawal amounts by comparing token balances before and after withdrawal is unreliable, which aligns with the reported issue of integer underflow and withdrawal failures.

---

### **[M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS**

**Report Description**:  
The `_depositInVault` function uses OpenZeppelin's `safeApprove` to grant allowance to the Yearn Vault. However, `safeApprove` reverts if the allowance is being changed from a non-zero value, which can occur if the vault's balance limit prevents a full deposit. This behavior can cause the function to revert, leading to a denial-of-service (DoS) for users attempting to deposit tokens. The recommended solution is to use `safeIncreaseAllowance` or `safeDecreaseAllowance` instead.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue with `safeApprove` reverting due to non-zero allowance changes. This is a critical oversight, as the issue directly impacts the contract's functionality and user experience.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[H-02] YearnV2YieldSource wrong subtraction in withdraw**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[M-01] safeApprove() for Yearn Vault may revert preventing deposits causing DoS**

---

The response list covers the critical issue of incorrect withdrawal amount tracking but misses the medium-severity issue related to `safeApprove` reverting. This gap highlights the need for a more comprehensive review of the contract's allowance management mechanisms.",1,0,1,7,"Okay, let's take a look at this smart contract and try to find all the vulnerabilities. The contract is called YearnV2YieldSource and it's using Solidity 0.6.12. Hmm, first thing I notice is the version. Solidity 0.6.12 is a bit old, so maybe there are compiler bugs or features not available, but maybe that's not the main issue here.

Looking at the imports, they're using OpenZeppelin upgradeable contracts. Wait, but the contract itself is an upgradeable one? Because it has initializer functions. The initialize function is called once, and they're using the initializer modifier. That's correct, but I should check if there's any way someone else could call initialize again. No, because there's a require that checks if the vault address is already set. So that's probably safe.

The contract inherits from IYieldSource, ERC20Upgradeable, OwnableUpgradeable, and ReentrancyGuardUpgradeable. ReentrancyGuard is used, which is good. They have nonReentrant modifiers on functions like supplyTokenTo and redeemToken. That should prevent reentrancy attacks, but maybe there's something else.

Looking at the initialize function: They check that the vault's token matches the _token provided. That's important. Also, they check the vault's activation time is not zero. Then they check the apiVersion of the vault to not be 0.3.2, 0.3.3, or 0.3.4. So they are blacklisting certain versions, maybe because those have issues. But how is the apiVersion checked? They have a function areEqualStrings which compares the keccak hashes. That's correct, but maybe the vault's apiVersion could change? Wait, no, because it's a function call to the vault, which is an external contract. So if the vault is upgradable, its apiVersion could change, but that's a dependency on the vault's own upgradeability. But the check is only done once during initialization. So if the vault is later upgraded to a blacklisted version, this contract wouldn't know. But maybe that's outside the scope here.

The token is approved with type(uint256).max, which is the maximum allowance. That's okay because it's for the vault address. So whenever the contract deposits, it can transfer tokens to the vault. But maybe if the vault is malicious or has a bug, but assuming it's a trusted vault, that's acceptable.

Looking at the setMaxLosses function: Only the owner can set it, and it's capped at 10_000 (which is 100% if that's a basis points value). Wait, maxLosses is used in the withdraw function of the vault. So when withdrawing, the maxLosses is passed as a parameter. The Yearn vault's withdraw function allows specifying a max loss, which is the maximum acceptable loss in basis points (1/100 of a percent). So setting maxLosses to 10,000 would allow 100% loss, which is dangerous. But the function requires that the new maxLosses is <= 10_000, which is allowed. However, if the owner sets it to a high value, users could lose funds when redeeming. So this is a centralization risk because the owner can set high max losses, leading to users getting less than expected. But is that a vulnerability in the code itself? Maybe, if the owner is considered trusted, but if not, it's a risk. However, the question is to list vulnerabilities in the code, not trust issues. So maybe this isn't a code vulnerability but a trust issue.

Moving on to the supplyTokenTo function: It transfers tokens from the user, mints shares based on the amount. Then deposits into the vault. Wait, but the deposit is after transferring. Let's see: The user sends tokens to the contract, then the contract deposits into the vault. But the shares are calculated as _tokenToShares(_amount). How does that work? The _tokenToShares function uses the current totalSupply and totalAssets. If totalSupply is zero, then shares equal tokens. Otherwise, it's tokens * totalSupply / totalAssets. That's the standard way to calculate shares. However, when the contract deposits into the vault, the vault's shares (yShares) are different from the shares of this contract. So maybe there's a miscalculation here.

Wait, when a user supplies tokens, the contract transfers the tokens to itself, then deposits into the vault. The vault gives back shares (yShares) based on the deposited tokens. But the contract's own shares (ERC20) are minted based on the amount of token supplied, not the yShares received. So if the vault's pricePerShare is not 1:1, the contract's shares may not accurately represent the underlying value. For example, if the vault's pricePerShare is higher than 1, then the same amount of tokens deposited would get fewer yShares. However, the contract's _tokenToShares function uses the total assets (which includes the vault's yShares converted back to tokens). So maybe it's correctly accounting for the vault's appreciation. Let me think: Suppose the contract has some tokens in the vault (yShares), and when a new user deposits, the total assets would be the sum of the contract's token balance and the value of yShares. Then the new shares are calculated based on that total. That seems correct.

But there's a possible issue with front-running or price manipulation during deposit and redeem. For example, if the vault's pricePerShare changes between the time the shares are calculated and when the deposit is made. But since the deposit happens immediately after the calculation, and the pricePerShare is a view function, maybe that's okay.

Another thing: the _depositInVault function checks if the allowance is less than the current balance and then approves max again. But the initialize function already approves max. So maybe this is redundant, but safe. However, if for some reason the vault's address changes (but it can't, since vault is set once in initialize), this would be a problem. But since vault is immutable after initialize, this is okay.

Looking at the redeemToken function: The user specifies an amount, which is converted to shares. Then the contract withdraws that amount from the vault, burns the shares, and transfers the tokens. But wait, the _withdrawFromVault function takes the amount as a parameter, converts it to yShares using _tokenToYShares(amount). Then calls vault.withdraw. But the amount here is the token amount the user wants to redeem. However, when converting to yShares, if the pricePerShare is higher than 1, the yShares would be less than the token amount. So when withdrawing, the contract gets back tokens equal to yShares multiplied by pricePerShare. Wait, no: the vault's withdraw function takes the number of shares (yShares) to withdraw. So _tokenToYShares(amount) converts the desired token amount into the number of yShares needed. But if the pricePerShare is higher, then to get 'amount' tokens, you need fewer yShares. So that conversion is correct. But during the withdrawal, if the actual amount received is less than expected due to losses (if maxLosses is set), then the user might get less than the calculated amount. However, the redeemToken function's parameter is the amount in tokens, but the user's shares are based on that. Wait, no. Let me re-examine: redeemToken takes 'amount' as the token amount the user wants to redeem, converts that to shares (using _tokenToShares(amount)), then burns those shares. Then it withdraws 'amount' tokens from the vault. Wait, that doesn't seem right. Because the 'amount' is the token amount, but when converting to shares, it's possible that the shares correspond to more or less than the actual yShares.

Wait, let's break it down. When a user calls redeemToken(amount), the code does:

shares = _tokenToShares(amount)

Then, it calls _withdrawFromVault(amount), which converts the 'amount' (token amount) to yShares by _tokenToYShares(amount). Then withdraws those yShares. The problem here is that the shares burned are based on the total assets (including the vault's holdings), but the actual withdrawal is based on the amount in tokens. So if the contract's total token holdings (balance plus vault's value) is different from the amount being withdrawn, the shares burned may not correspond correctly to the actual value.

Wait, perhaps there's a miscalculation here. For example, suppose the contract's total assets (token balance plus vault shares converted to tokens) is 1000 tokens, and totalSupply is 1000 shares. If a user redeems 500 tokens, they would burn 500 shares. Then the contract needs to withdraw 500 tokens from the vault. But converting 500 tokens to yShares depends on the current pricePerShare. If the price is 2 (each yShare is worth 2 tokens), then yShares needed would be 500 / 2 = 250. Then withdrawing 250 yShares gives 250 * 2 = 500 tokens. So that's correct. But if during the time between calculating the shares and withdrawing, the pricePerShare changes, then the actual tokens received could differ.

But in the code, the _tokenToYShares uses the current pricePerShare, which is view, so it's up to date. However, the problem arises when the withdrawal from the vault doesn't get the exact amount. The _withdrawFromVault function returns the actual tokens withdrawn (currentBalance - previousBalance). Then, that amount is transferred to the user. But the shares burned were based on the 'amount' parameter, not the actual withdrawn amount. That could lead to a discrepancy. For example, if the user requests to redeem 500 tokens (which converts to 500 shares if totalSupply is 1000 and totalAssets 1000), but the actual withdrawn amount is 400 tokens (due to a loss in the vault, maybe because of maxLosses being set high). The user would get 400 tokens, but their 500 shares are burned. This would lead to the user losing more than expected, and the contract's totalSupply decreases by 500, but the total assets decrease by 400. This would cause the remaining shares to represent more value than before, which benefits other users. Wait, but the shares burned are calculated based on the 'amount', not the actual tokens received. So if the actual tokens received are less than 'amount', then the contract's total assets are reduced by the actual tokens, but the totalSupply is reduced by shares corresponding to 'amount'. This would cause the share price to increase, which is unfair to the redeemer. They are losing shares equivalent to 'amount', but only receiving less tokens.

So this is a vulnerability. The redeemToken function burns shares based on the 'amount' parameter, but the actual tokens withdrawn could be less. This means the user is losing more shares than the value they receive. The problem is in the redeemToken function's logic. The shares should be calculated based on the actual tokens received, not the requested 'amount'. 

Wait, let me look at the code again:

function redeemToken(uint256 amount) external override nonReentrant returns (uint256) {
    uint256 shares = _tokenToShares(amount);
    uint256 withdrawnAmount = _withdrawFromVault(amount);
    _burn(msg.sender, shares);
    token.safeTransfer(msg.sender, withdrawnAmount);
    emit RedeemedToken(msg.sender, shares, amount);
    return withdrawnAmount;
}

So the shares are calculated as _tokenToShares(amount), which converts the 'amount' of tokens to the corresponding shares based on the current ratio. But when the contract withdraws from the vault, the actual tokens received (withdrawnAmount) could be less than 'amount' (due to maxLosses). However, the shares burned are based on 'amount', not 'withdrawnAmount'. This means that even if the withdrawnAmount is less than 'amount', the user still loses shares equivalent to 'amount'. That's incorrect because the user is effectively redeeming 'withdrawnAmount' tokens, so the shares should be calculated based on 'withdrawnAmount', not the requested 'amount'.

For example, suppose the user wants to redeem 100 tokens, and the shares for that amount is 100. But due to a loss in the vault, they only get 80 tokens. The user's 100 shares are burned, but they only receive 80 tokens. The remaining users now have their shares worth more because totalSupply decreased by 100, but total assets decreased by 80. This is a loss for the redeeming user. So the calculation should instead compute the shares based on the actual withdrawnAmount. 

This is a critical vulnerability because it allows the contract to burn more shares than the value actually withdrawn, leading to loss for the user. The correct approach would be to first withdraw the tokens, calculate the shares based on the actual tokens received, then burn those shares. However, in the current code, the shares are burned based on the requested amount, not the actual amount. So this is a flaw in the logic.

Another possible issue: the _withdrawFromVault function uses the maxLosses parameter. If the owner has set a high maxLosses, then during redemption, the vault might take a loss, leading to less tokens being received. But as mentioned earlier, the user's shares are burned based on the original amount, not the actual received. So combining these two, it's possible that users lose more than they should.

Next, looking at the _tokenToShares function. When totalSupply is zero, shares equal tokens. But if there are existing tokens in the contract (from someone else, like a sponsor), then the first depositor could be minted shares based on the totalAssets, which includes any existing tokens or yShares. For example, if someone sponsored tokens before any deposits, then the first user's deposit would have their shares diluted. But the sponsor function is callable by anyone? No, wait the sponsor function is external and nonReentrant, but not restricted. Wait, no: the sponsor function is public, anyone can call it. So if someone sends tokens to the contract via sponsor, then when the first user deposits, the totalAssets would include those sponsored tokens, leading the user's shares to be based on that. This could allow a front-running attack where a sponsor donates tokens before the first deposit, thereby making the initial depositor's shares worth less. This is known as a donation attack. For example, suppose the contract already has 100 tokens from a sponsor. The first user deposits 100 tokens. The totalSupply is zero, so shares = 100 tokens. But the totalAssets is 100 (existing) + 100 (deposited) = 200. Wait, no. Because when the user deposits, the code transfers the tokens to the contract, then calls _depositInVault(), which deposits all tokens into the vault. So after deposit, the contract's token balance is zero, but it has yShares. Let's see:

- User deposits 100 tokens. The contract transfers 100 tokens from user to itself. Then calls _depositInVault(), which deposits all tokens (100) into the vault. The vault gives back yShares, say 100 if pricePerShare is 1. So the totalAssetsInToken is 0 (balance) + 100 yShares * 1 = 100. But if there were already sponsored tokens, say 100 tokens deposited via sponsor, then when the user deposits, the contract's token balance before deposit is 100 (sponsored) + 100 (user) = 200. Then _depositInVault deposits 200 into the vault, getting 200 yShares. The totalAssetsInToken is 200. Since totalSupply is zero, the user gets 200 shares (since tokens = 200). But the user only supplied 100 tokens. The sponsored 100 tokens are now part of the user's shares. So the user gets double the shares they should. This is a critical issue because the sponsor can front-run the first deposit and donate tokens, causing the first depositor to receive shares for both their own tokens and the donated ones, effectively stealing value from the sponsor.

This is a classic donation attack vulnerability, similar to what happened with some vaults in the past. The issue arises because when totalSupply is zero, the shares are minted as the deposited tokens, but if there are existing tokens in the contract (from sponsor or accidental transfers), those are included in the totalAssets, leading to incorrect share calculation.

Another possible issue: the ERC20Upgradeable contract uses a name and symbol, but in the given code, the initialize function doesn't call the ERC20's initialize function with a name and symbol. Wait, the contract YearnV2YieldSource inherits from ERC20Upgradeable, which is an upgradeable ERC20. The ERC20Upgradeable requires that the __ERC20_init function is called with the name and symbol. However, in the provided code's initialize function, there is no call to __ERC20_init. That means the ERC20 token will have empty name and symbol, which could cause issues with external systems expecting valid ERC20 metadata. This is a vulnerability because the token won't have a proper name or symbol, leading to potential confusion or integration problems.

Looking at the initialize function again: It calls __Ownable_init() and __ReentrancyGuard_init(), but not __ERC20_init. So the ERC20Upgradeable's initializer isn't called, leaving the name and symbol unset. That's definitely a bug.

Another thing: The vault's apiVersion is checked during initialization with areEqualStrings. But if the vault's apiVersion returns a longer string or different casing, the check could pass incorrectly. But the code uses the exact comparison, so as long as the strings are exactly those versions, it's blocked. However, future versions that are incompatible might not be caught, but that's a dependency issue.

Also, the function areEqualStrings is using abi.encodePacked, which is correct for string comparison. So that's not an issue.

Looking at the _depositInVault function: It checks if the allowance is less than the balance and approves max. But since the initial approve is already max, this might be redundant. However, in some cases, if the vault's token is upgraded (but vault is immutable), or if the initial approval was somehow reduced, this could help. But since the vault is fixed after initialization, and the initial approval is max, this check is unnecessary but harmless.

Another possible issue: The contract uses SafeMathUpgradeable, which is necessary for Solidity 0.6, since it doesn't have built-in overflow checks. But since they're using SafeMath functions with .mul and .div, that's handled. So no overflow vulnerabilities here.

Reentrancy: The external functions that transfer tokens use nonReentrant modifiers. The functions supplyTokenTo, redeemToken, and sponsor all have nonReentrant. So reentrancy should be prevented. But what about the vault's deposit and withdraw functions? If the vault is malicious and calls back into the contract, could that cause reentrancy? But since the nonReentrant modifier is on the external functions, and the internal _depositInVault and _withdrawFromVault are called from them, any reentrant calls would be blocked by the nonReentrant modifier. So that's probably safe.

Another thing: The vault's pricePerShare could be manipulated if the vault is not secure. But that's a dependency on the vault, not this contract's fault.

In the redeemToken function, after burning the shares, the tokens are transferred to the user. But if the token transfer fails (e.g., a blacklisted address), the shares are already burned. That's an issue because the user loses shares but doesn't receive the tokens. The function uses SafeERC20's safeTransfer, which should revert on failure, so the entire transaction would revert, and the shares wouldn't be burned. So that's safe.

So summarizing the vulnerabilities found:

1. **Incorrect Share Calculation During Redemption**: When redeeming tokens, the shares burned are based on the requested 'amount' rather than the actual 'withdrawnAmount', leading to users losing more shares than the value they receive. This is a critical vulnerability.

2. **Donation Attack Vulnerability**: The initial deposit can be front-run by a sponsor, allowing the first depositor to mint shares based on existing tokens in the contract, leading to incorrect share distribution and potential theft of funds.

3. **Missing ERC20 Initialization**: The contract fails to initialize the ERC20 token's name and symbol, resulting in an ERC20 token with empty metadata, which can cause integration issues.

4. **Reliance on Owner to Set Safe MaxLosses**: The owner can set maxLosses to a high value (up to 100%), which could lead to users receiving significantly fewer tokens than expected during redemption. While this is a trust issue, the code allows for potential loss if the owner is malicious or compromised.

Wait, but the question says ""no need for Mitigation"", just list vulnerabilities. So even if it's a trust issue, but if the code allows for a dangerous setting, maybe that's considered a vulnerability. However, the code does have a require that maxLosses <= 10_000, which is allowed by the protocol. So it's a feature, not a vulnerability. The risk is that the owner can set a high max loss, but that's by design, so maybe not a code vulnerability. Unless the maxLosses is not properly validated, which it is. So that's probably not a vulnerability but a potential risk.

So the main vulnerabilities are the first three: incorrect share burn, donation attack, missing ERC20 init.

Another thing to check: In the redeemToken function, the parameter is named 'amount', which is in tokens. The function converts that to shares and burns them. However, the actual tokens withdrawn could be less, leading to the shares burned not reflecting the actual value. The user expects to receive 'amount' tokens, but due to maxLosses, they might get less. But the shares are calculated based on 'amount', not the actual withdrawn. This discrepancy means that the user's shares are not correctly proportional to the redeemed value. This is definitely a logic error and a critical vulnerability.

Another thing: the sponsor function allows anyone to send tokens to the contract, increasing the totalAssets, which affects share calculations. While this is intentional, the problem arises when those tokens are not accounted for in the shares. For example, when someone sponsors tokens, they are deposited into the vault, increasing the totalAssets, but no shares are minted. This dilutes the value of existing shares, effectively transferring value from existing shareholders to the sponsor. However, the sponsor function doesn't mint any shares, so the sponsored tokens are added to the pool, and existing shareholders benefit from the increased totalAssets. So this is a design choice where sponsors can donate funds to the pool, but it can be exploited as part of a donation attack if done before the first deposit.

So the donation attack is possible if someone sends tokens (via sponsor or direct transfer) before any shares are minted. For example, if the contract has a balance of tokens (from sponsor) and the first deposit is made, the depositor's shares are calculated based on the totalAssets (including sponsored tokens), allowing them to receive shares for both their deposit and the sponsored amount. This allows the attacker to steal the sponsored tokens by being the first depositor.

Additionally, the ERC20 token not having a name or symbol is a vulnerability because it's standard for ERC20 tokens to have these metadata fields, and their absence can cause issues with wallets, explorers, and other contracts that expect them.

So the list of vulnerabilities is:

1. **Incorrect Share Burning in Redemption**: Shares are burned based on the requested token amount rather than the actual withdrawn amount, leading to loss of user funds.

2. **Donation Attack Vulnerability**: The contract is susceptible to front-running attacks where an attacker can donate tokens to the contract before the first deposit, allowing the first depositor to mint shares at an incorrect rate.

3. **Missing ERC20 Metadata Initialization**: The contract does not initialize the ERC20 token's name and symbol, leading to potential integration issues.

4. **Insecure Handling of Vault API Version**: The contract checks the vault's API version during initialization but does not account for future upgrades of the vault, which could introduce incompatible changes.

Wait, the fourth point: the contract checks the vault's apiVersion during initialization, but if the vault is upgradable, its apiVersion could change later. However, the contract's code only checks during initialization. This means that if the vault is upgraded to a blacklisted version after initialization, the contract will still interact with it. However, the code as written only blocks certain versions at initialization time. This is a potential risk, but since the contract cannot control the vault's upgradeability, it's more of a dependency risk. However, the code's check during initialization may not be sufficient if the vault is later upgraded. But according to the code's comments, they want to block certain versions, so if the vault is upgraded, the contract would still use it. But the code can't do anything about that. So this might not be a vulnerability in this contract's code, but a limitation.

Another thing: the vault's activation is checked to not be zero. So if the vault is not activated, the contract cannot be initialized. That's correct.

Another possible issue: the use of the vault's token() function. The contract initializes with a token and checks that vault.token() == address(_token). But if the vault's token can change (if the vault is upgradable), then the contract's token variable would be incorrect. But the vault's token() is usually immutable once set. So if the vault is not upgradable, this is safe. If it is upgradable, that's a risk. But this is again a dependency on the vault's implementation.

So focusing on the code's own vulnerabilities:

The main ones are the first three I listed. Let me confirm again:

1. **Incorrect Share Calculation During Redemption**: This is a critical issue where shares are burned based on the requested amount, not the actual received amount.

2. **Donation Attack**: Allowing the first depositor to receive shares for pre-existing tokens in the contract.

3. **Missing ERC20 Initialization**: Not setting the name and symbol for the ERC20 token.

Another possible issue: the contract uses the initializer modifier but doesn't call the ERC20's initialize function. The ERC20Upgradeable requires that __ERC20_init is called. Since the contract inherits from ERC20Upgradeable and doesn't initialize it, the token's name and symbol are empty. This is a mistake in the initialization process. So this is a definite vulnerability.

Also, the function areEqualStrings is used to check the vault's apiVersion. However, comparing strings in Solidity can be tricky, but the function uses keccak256 hashing correctly. So no issue there.

Another thing to check: the vault.deposit() function in _depositInVault returns the number of shares, but the code doesn't use it. However, the code just deposits the entire balance of the contract. Since token.approve is set to max, and deposit() is called without a parameter, which deposits the entire token balance of the contract. So the code is correct there. The return value is ignored, but since it's not needed, that's okay.

In terms of potential vulnerabilities, that's all I can find for now.","```
1. Incorrect Withdrawal Amount Tracking
```",0.16666666666666666
BagerYieldSource.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";

/// @title A pooltogether yield source for badger sett
/// @author Steffel Fenix, 0xkarl
contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    /// @notice Returns the ERC20 asset token used for deposits.
    /// @return The ERC20 asset token
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
    /// @return The underlying balance of asset tokens
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    /// @notice Allows assets to be supplied on other user's behalf using the `to` param.
    /// @param amount The amount of `token()` to be supplied
    /// @param to The user whose balance will receive the tokens
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    /// @notice Redeems tokens from the yield source to the msg.sender, it burns yield bearing tokens and returns token to the sender.
    /// @param amount The amount of `token()` to withdraw.  Denominated in `token()` as above.
    /// @return The actual amount of tokens that were redeemed.
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}",830.0,83.0,"[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong
Function `balanceOfToken` When suppling to the `BadgerYieldSource`, some amount of badger is deposited to badgerSett and one receives badgerSett share tokens in return which are stored in the balances mapping of the user. So far this is correct.
The `balanceOfToken` function should then return the redeemable balance in `badger` for the user's badgerSett balance. It computes it as the pro-rata share of the user balance (compared to the total-supply of badgerSett) on the badger in the vault:
``` balances[addr].mul(
  badger.balanceOf(address(badgerSett))
).div(
  badgerSett.totalSupply()
)
```
However, `badger.balanceOf(address(badgerSett))` is only a small amount of badger that is deployed in the vault (""Sett"") due to most of the capital being deployed to the strategies. Therefore, it under-reports the actual balance:
‘Typically, a Sett will keep a small portion of deposited funds in reserve to handle small withdrawals cheaply. Badger Docs’
Any contract or user calling the `balanceOf` function will receive a value that is far lower than the actual balance. Using this value as a basis for computations will lead to further errors in the integrations.
  [M-02] Return values of ERC20 `transfer` and `transferFrom` are unchecked
In the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., BADGER). In that case, the transfer fails without being noticed by the calling contract.
If warden's understanding of the BadgerYieldSource is correct, the badger variable should be the BADGER token at address 0x3472a5a71965499acd81997a54bba8d852c6e53d. However, this implementation of BADGER is not ERC20-compliant, which returns false when the sender does not have enough token to transfer (both for transfer and transferFrom). See the source code on Etherscan (at line 226) for more details.
  [M-03] `SafeMath` not completely used in yield source contracts (overflow) `SafeMath` is not completely used at the following lines of yield source contracts, which could potentially cause arithmetic underflow and overflow: line 67 in BadgerYieldSource
```(amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)```",3.0,"pragma solidity 0.6.12;

import { IYieldSource } from ""@pooltogether/yield-source-interface/contracts/IYieldSource.sol"";
import ""@openzeppelin/contracts/math/SafeMath.sol"";
import ""./IBadgerSett.sol"";
import ""./IBadger.sol"";
import ""hardhat/console.sol"";



contract BadgerYieldSource is IYieldSource {
    using SafeMath for uint256;
    IBadgerSett private immutable badgerSett;
    IBadger private immutable badger;
    mapping(address => uint256) private balances;

    constructor(address badgerSettAddr, address badgerAddr) public {
        badgerSett = IBadgerSett(badgerSettAddr);
        badger = IBadger(badgerAddr);
    }

    
    
    function depositToken() public view override returns (address) {
        return (address(badger));
    }

    
    
    function balanceOfToken(address addr) public override returns (uint256) {
        if (balances[addr] == 0) return 0;

        uint256 totalShares = badgerSett.totalSupply();
        uint256 badgerSettBadgerBalance = badger.balanceOf(address(badgerSett));
        return (balances[addr].mul(badgerSettBadgerBalance).div(totalShares));
    }

    
    
    
    function supplyTokenTo(uint256 amount, address to) public override {
        badger.transferFrom(msg.sender, address(this), amount);
        badger.approve(address(badgerSett), amount);

        uint256 beforeBalance = badgerSett.balanceOf(address(this));
        badgerSett.deposit(amount);
        uint256 afterBalance = badgerSett.balanceOf(address(this));
        uint256 balanceDiff = afterBalance.sub(beforeBalance);
        balances[to] = balances[to].add(balanceDiff);
    }

    
    
    
    function redeemToken(uint256 amount) public override returns (uint256) {
        uint256 totalShares = badgerSett.totalSupply();
        if (totalShares == 0) return 0;

        uint256 badgerSettBadgerBalance = badgerSett.balance();
        if (badgerSettBadgerBalance == 0) return 0;

        uint256 badgerBeforeBalance = badger.balanceOf(address(this));

        uint256 requiredShares =
            ((amount.mul(totalShares) + totalShares)).div(
                badgerSettBadgerBalance
            );
        if (requiredShares == 0) return 0;

        uint256 requiredSharesBalance = requiredShares.sub(1);
        badgerSett.withdraw(requiredSharesBalance);

        uint256 badgerAfterBalance = badger.balanceOf(address(this));
        uint256 badgerBalanceDiff = badgerAfterBalance.sub(badgerBeforeBalance);

        balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
        badger.transfer(msg.sender, badgerBalanceDiff);
        return (badgerBalanceDiff);
    }
}",624.0,1,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Reentrancy Vulnerability in `redeemToken`:**
   - The `redeemToken` function performs external calls (`badgerSett.withdraw` and `badger.transfer`) **before** updating the user's balance in the `balances` mapping. This allows a malicious actor to re-enter the function during the external calls, potentially draining funds multiple times before the balance is deducted.

2. **Incorrect Share Calculation in `redeemToken`:**
   - The formula for `requiredShares` uses `(amount.mul(totalShares) + totalShares)` instead of the correct proportional calculation. This introduces rounding errors, leading to overestimation/underestimation of shares needed for redemption. Users may receive incorrect amounts of tokens or be unable to redeem small balances.

3. **Unsafe ERC20 Approval in `supplyTokenTo`:**
   - The `badger.approve(address(badgerSett), amount)` call resets the allowance to `amount` without first setting it to zero. If the Sett already had a non-zero allowance, this could enable front-running attacks where an attacker uses the residual allowance before the new approval is processed.

4. **Rounding Errors Leading to Failed Redemptions:**
   - When redeeming small amounts, the calculation for `requiredShares` may round down to zero after the flawed formula and subsequent subtraction of 1 (`requiredSharesBalance = requiredShares.sub(1)`). This results in no tokens being redeemed while the user's share balance remains unchanged.

5. **Lack of Access Control in `supplyTokenTo`:**
   - The function allows any user to deposit tokens to **any address** (`to` parameter). If the system expects users to only deposit funds for themselves, this could enable malicious actors to manipulate other users' balances or disrupt accounting mechanisms.

6. **Outdated Solidity Version (0.6.12):**
   - While not a direct code vulnerability, using an older compiler version misses critical security fixes and features from newer versions, increasing overall risk exposure.","### **[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**

**Report Description**:
The `balanceOfToken` function in `BadgerYieldSource` incorrectly calculates the redeemable balance of `badger` for a user's `badgerSett` balance. It uses the formula `balances[addr].mul(badger.balanceOf(address(badgerSett))).div(badgerSett.totalSupply())`, which only accounts for the `badger` balance in the vault (`badgerSett`). However, most of the capital is deployed to strategies, leading to an under-reporting of the actual balance. This discrepancy can cause errors in integrations relying on this value.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect share calculation in `balanceOfToken`. This is a critical oversight, as the function's flawed logic directly impacts the accuracy of balance reporting and subsequent computations.

---

### **[M-02] Return values of ERC20 `transfer` and `transferFrom` are unchecked**

**Report Description**:
In `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked. This is particularly problematic for non-ERC20-compliant tokens like `BADGER`, which return `false` on failure instead of reverting. This oversight could lead to unnoticed transfer failures, potentially causing discrepancies in token balances.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of unchecked ERC20 `transfer` and `transferFrom` return values. This is a significant security concern, as it could allow silent failures in token transfers, especially when dealing with non-compliant tokens.

---

### **[M-03] `SafeMath` not completely used in yield source contracts (overflow)**

**Report Description**:
The yield source contracts do not fully utilize `SafeMath`, particularly in the calculation `(amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)` at line 67 in `BadgerYieldSource`. This omission could lead to arithmetic underflow or overflow, potentially causing incorrect calculations and vulnerabilities in the contract's logic.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incomplete `SafeMath` usage, which could lead to arithmetic vulnerabilities. This is a critical oversight, as it directly impacts the contract's safety and reliability.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-03] BadgerYieldSource balanceOfToken share calculation seems wrong**
- **[M-02] Return values of ERC20 `transfer` and `transferFrom` are unchecked**
- **[M-03] `SafeMath` not completely used in yield source contracts (overflow)**

---

### **Conclusion**
The `response_list` fails to address any of the issues identified in the `issue` report. This indicates a significant gap in the coverage of vulnerabilities, particularly in areas such as incorrect share calculations, unchecked ERC20 return values, and incomplete `SafeMath` usage. Addressing these issues is critical to ensuring the security and reliability of the smart contracts.",0,0,3,6,"Okay, let's look at this BadgerYieldSource contract. Hmm, first, I should check for common vulnerabilities like reentrancy, integer overflows, and improper access control. Let's start with the functions.

Looking at the supplyTokenTo function. It transfers Badger tokens from the user, approves the Sett to spend them, deposits into the Sett, and updates the user's balance. Wait, the approve is done right after transferFrom. But since the contract is using SafeMath, maybe overflows are handled. But in older Solidity versions, like 0.6.12, some checks might be needed. Wait, the SafeMath is imported, so maybe that's okay.

Now the redeemToken function. It calculates requiredShares based on the amount. There's a part where requiredShares is (amount * totalShares + totalShares) divided by badgerSettBadgerBalance. Wait, that formula seems odd. Let's see: requiredShares = (amount * totalShares + totalShares) / badgerSettBadgerBalance. Maybe that's a rounding issue? Like, adding totalShares before division could lead to incorrect shares calculation. For example, if the division is supposed to be (amount * totalShares) / balance, but here they add totalShares to that product. That might be a mistake. That could lead to overestimating the required shares, which might result in taking more shares than needed, leading to loss of funds or incorrect redemption amounts.

Also, in redeemToken, after calculating requiredShares, they subtract 1 (requiredSharesBalance = requiredShares.sub(1)). Why subtract 1? That might be a way to handle rounding, but if requiredShares is very small, subtracting 1 could underflow. But since requiredShares is calculated with (amount * totalShares + totalShares) divided by balance, maybe there's a scenario where requiredShares is 0, and subtracting 1 would cause an underflow. But SafeMath's sub is used, so that would revert. But wait, requiredShares is checked if it's 0 before that. If requiredShares is zero, return 0. Otherwise, subtract 1. So maybe in cases where requiredShares is 1, subtracting 1 would make it zero, which could be problematic when withdrawing. For example, if the user has 1 share, the withdraw would be for 0, which might fail or not do anything.

Another thing: the balanceOfToken function calls badger.balanceOf(address(badgerSett)), but the Sett's balance might change over time. However, balanceOfToken is not a view function because it's overridden from IYieldSource, which might have a different function modifier. Wait, in the interface, is balanceOfToken supposed to be a view? If the original function in IYieldSource is not marked as view, then this function can't be view either. But since this implementation does an external call to badger.balanceOf, which is a view function, maybe that's okay. However, if the interface expects balanceOfToken to be a view function, then this implementation would have an error because it's not marked view. Let me check the code again. The function is declared as ""function balanceOfToken(address addr) public override returns (uint256)"", so it's not view. But inside, it calls badger.balanceOf, which is view, and badgerSett.totalSupply(), which is also view. So maybe the state doesn't change here, but the function isn't marked as view. That's not a vulnerability per se, but could cause issues if the interface expects a view function. But maybe the interface doesn't, so that's okay.

Looking for reentrancy in redeemToken. The function withdraws from badgerSett, then transfers Badger tokens. The withdraw could potentially interact with another contract, but since the Sett is presumably trusted, maybe that's not an issue. But if the Sett's withdraw function calls back into this contract, there might be a reentrancy. However, the state changes (balances[msg.sender] is updated before the transfer. Wait, no, the order is: after withdraw, the contract gets the Badger tokens, then subtracts the requiredSharesBalance from the user's balance, then transfers the tokens. Wait, the code is:

badgerSett.withdraw(requiredSharesBalance);
balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
badger.transfer(msg.sender, badgerBalanceDiff);

So the user's balance is updated after the withdraw. If during the withdraw, the Sett calls back into this contract, the user's balance hasn't been updated yet. But since the balances are subtracted after the withdraw, maybe a reentrant call could exploit that. For example, if someone calls redeemToken again before their balance is updated, they might be able to withdraw more than they should. But since the withdraw is done first, and then the balance is subtracted, maybe there's a reentrancy vulnerability here. Let me think: when you call badgerSett.withdraw, that could trigger a transfer to this contract. If the Badger token's transfer function calls back into this contract's redeemToken function, the attacker's balance hasn't been decreased yet. So the attacker could call redeemToken again, and their balance is still the original amount. So they could drain their balance multiple times. That's a classic reentrancy issue.

Another point: the approve in supplyTokenTo is done with amount, but if there was a previous allowance, it might not be reset. For example, if the contract previously approved the Sett to spend some tokens, then the next approve might not go through if the current allowance is non-zero. Because the approve function in ERC20 requires that you first set the allowance to zero before changing it. So if there's a leftover allowance, the approve could fail. But in this code, after transferring the tokens from the user to the contract, they approve the Sett to spend exactly 'amount'. If the Sett already had an allowance, then the new approve would only allow 'amount', but maybe the contract already had some. For instance, if the contract previously approved a larger amount, the new approve would reduce it. But if the contract's previous allowance was less than 'amount', then the approve would increase it. Wait, no. The approve function sets the allowance to the given value. So if the contract previously approved, say, 100 tokens for the Sett, and now approves 'amount' (say, 50), then the Sett's allowance is 50. But when depositing into the Sett, the Sett would take the 'amount' (50) tokens. But the code here first transfers 'amount' from the user to the contract, then approves the Sett to spend 'amount', and then deposits that 'amount'. But if the contract already had some tokens in it, maybe from previous deposits, then the approve might not be sufficient. Wait, no. The 'amount' here is the amount being transferred from the user. So the contract should have exactly 'amount' tokens, and the approve is for 'amount', so the deposit should work. However, if the contract had existing tokens, then the approve would allow the Sett to take up to 'amount', but if the contract has more tokens (existing ones + the new 'amount'), then the Sett could take more than intended. Wait, no. Because the deposit(amount) would take exactly 'amount' tokens. Wait, the Sett's deposit function takes an amount parameter. So when the code calls badgerSett.deposit(amount), the Sett would transfer 'amount' tokens from the caller (this contract) to itself. But the contract must have approved at least 'amount' for the Sett. The code does badger.approve(address(badgerSett), amount), so if there was a previous approval, this sets it to exactly 'amount', which is sufficient. So maybe that's okay.

Another issue: the balances mapping is updated based on the difference in Sett shares before and after deposit. That's correct because the Sett's deposit could mint shares based on the current price, so the actual shares received might not be 1:1 with the deposited tokens. So using the balance difference is a good way to track shares. So that part seems okay.

Back to the redeemToken function's calculation of requiredShares. Let's see: the user wants to redeem 'amount' of Badger tokens. The contract calculates how many Sett shares are needed to get that amount. The formula is (amount * totalShares + totalShares) / badgerSettBadgerBalance. Why add totalShares here? That seems incorrect. The correct formula should be (amount * totalShares) / badgerSettBadgerBalance, using the current exchange rate. By adding totalShares to the numerator, it's increasing the required shares beyond what's necessary, leading to an overestimation. For example, if totalShares is 1000 and badgerSettBadgerBalance is 2000, then for an amount of 1, the calculation would be (1 * 1000 + 1000) / 2000 = 2000 / 2000 = 1 share. But the correct value would be (1 * 1000) / 2000 = 0.5, which would round down to 0. But since they add totalShares, it's causing the numerator to be higher, leading to a higher required shares. But then they subtract 1, so requiredSharesBalance becomes 0. Then the withdraw is called with 0 shares, which might not do anything, leading to zero tokens being redeemed. Wait, but that can't be. Let's take an example:

Suppose a user wants to redeem 1 Badger. The Sett has totalShares 1000 and balance 2000 Badger. Then requiredShares = (1*1000 + 1000) / 2000 = 2000/2000=1. requiredSharesBalance = 1-1=0. Then they withdraw 0 shares. That would redeem 0 Badger. So the user gets nothing. But they expected 1. That's a problem. Wait, but maybe the formula is trying to round up? Let me see. Maybe the formula is intended to be (amount * totalShares + badgerSettBadgerBalance -1 ) / badgerSettBadgerBalance to round up. But the current formula adds totalShares instead. That's incorrect.

Alternatively, maybe the formula is supposed to be something else. For example, shares = (amount * totalShares) / badgerSettBadgerBalance. To get enough shares to cover 'amount' tokens. But in the code, they have:

requiredShares = ((amount.mul(totalShares) + totalShares)).div(badgerSettBadgerBalance)

That seems like a mistake. Perhaps it was intended to add badgerSettBadgerBalance -1 to the numerator for rounding up. For example:

requiredShares = (amount * totalShares + badgerSettBadgerBalance - 1) / badgerSettBadgerBalance

Which would be the standard way to round up in integer division. But here, they added totalShares instead, which is a different value. This seems like an error in the formula, leading to incorrect calculation of required shares. As a result, the requiredShares could be much higher than necessary, leading to over-withdrawing from the user's balance. But wait, after calculating requiredShares, they subtract 1. So requiredSharesBalance = requiredShares -1. If requiredShares is overestimated, subtracting 1 might not be enough.

This would cause the contract to withdraw more shares than necessary, which would lead to transferring more tokens to the user than they are entitled to. Wait, let's think through:

If the formula for requiredShares is wrong and overestimates, then requiredSharesBalance is requiredShares -1. If requiredShares was supposed to be the correct value and the formula is wrong, then requiredSharesBalance could be higher than needed. For example, if the correct requiredShares is 5, but the code calculates 10, then requiredSharesBalance is 9. Withdrawing 9 shares would give more tokens than needed. Then, the user's balance is decreased by 9 shares, which would be more than what was needed for the 'amount', leading to a loss for the user. Wait, but the user is supposed to get 'amount' of tokens. So if the code miscalculates the required shares, the user's balance is reduced by more shares, but they receive more tokens. Wait, no: the code computes requiredShares based on the user's requested 'amount', but if the requiredShares is calculated incorrectly, the actual tokens redeemed (badgerBalanceDiff) could be more or less than 'amount'. Then, the user's balance is reduced by requiredSharesBalance, which is requiredShares-1. So this seems like a mathematical error that could lead to incorrect redemption amounts, possibly allowing users to redeem more tokens than they should, or causing the contract to lose funds.

Another issue: in redeemToken, after calculating badgerBalanceDiff (the difference in Badger balance before and after withdrawal), the contract transfers that amount to the user. However, if the Sett's withdrawal function doesn't transfer the exact amount expected (due to fees, rounding, or other factors), then badgerBalanceDiff might not match the intended 'amount'. But the code returns whatever the diff is. However, the problem is that the user's shares are reduced by requiredSharesBalance, which is based on an incorrect formula, leading to possible discrepancies between shares burned and tokens received.

Also, in redeemToken, if the calculated requiredShares is 0, the function returns 0. But if requiredShares is 1, then requiredSharesBalance is 0, and the withdraw is 0 shares, which might do nothing. Then, badgerBalanceDiff is 0, and the user's balance is decreased by 0 (since requiredSharesBalance is 0). But the code subtracts requiredSharesBalance from the user's balance. Wait, the code does:

balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);

If requiredSharesBalance is 0, then the user's balance is not changed, but they might have received some tokens. Wait, no: if requiredSharesBalance is 0, the withdraw call is made with 0 shares, which probably does nothing, so badgerBalanceDiff is 0. Then, the user's balance isn't reduced, and they get 0 tokens. So the user might call redeemToken with a small 'amount' that results in requiredShares of 1, leading to no tokens being redeemed, but their shares remain the same. However, the user's shares are in the balances mapping, so they can try again later. But this could be a problem if the user is unable to redeem small amounts due to rounding errors.

Another vulnerability: the supplyTokenTo function is external (since it's overriding an interface function, which is probably external). But it's marked as public, so that's okay. However, anyone can call supplyTokenTo and specify any 'to' address. So if I transfer tokens to the contract and specify someone else's address, I can increase their balance. That could be a problem if the system expects that only the user can deposit for themselves. But if the system allows depositing on behalf of others, that's a feature, not a bug. However, if the contract is intended to only allow users to deposit for themselves, then this is a vulnerability. For example, in some yield sources, you can only deposit to your own account. But since the function is called supplyTokenTo, maybe it's intended. So unless the contract has an access control issue here, it's not a vulnerability.

Reentrancy in supplyTokenTo: The function transfers tokens from the user, approves, deposits into Sett, and updates balances. The external calls here are transferFrom (which is a call to the Badger token), approve (another call to Badger), and deposit (call to Sett). If any of these calls to external contracts re-enter the supplyTokenTo function, could that cause issues? For example, during the transferFrom, if the Badger token is malicious and calls back into supplyTokenTo, the contract's state hasn't been updated yet (since the deposit and balance update happen after). But the user's tokens have already been transferred. However, the balances are updated after the deposit. So during a reentrancy, the attacker's balance would not have been updated yet. But maybe they could manipulate the shares calculation. Not sure, but possible. However, since the code uses SafeMath and the state is updated after external calls, there might be a reentrancy risk here as well. For example, if during the deposit into Sett, the Sett calls back into this contract, the attacker could perform a reentrant call before the balance is updated. But the impact is unclear.

Another thing: the contract uses Solidity 0.6.12, which is outdated. Known vulnerabilities in that version could exist, but the question is about the code's vulnerabilities, not the compiler. However, using an older compiler might mean missing safety features, but that's more of a general issue.

Also, the contract imports the console.sol from Hardhat, which is for debugging. But in production, that should be removed. However, that's not a vulnerability, just bad practice.

Check for front-running: Not sure if applicable here. The contract doesn't seem to have any auction mechanisms or things sensitive to transaction ordering.

Another possible issue: the balanceOfToken function can be manipulated if the badgerSett's balance changes during the transaction. Since it's not a view function, someone could call it and it executes a state-changing operation. Wait, but the function itself doesn't change the state, unless the badgerSett's totalSupply() or balanceOf() functions are state-changing. If those functions are view, then balanceOfToken is a view function mistakenly not marked as such. But since the interface requires it to be non-view, maybe that's intentional. However, if a function that is supposed to be view isn't, but the implementation is, that could cause issues with compatibility. But not a security vulnerability.

Let's summarize the potential vulnerabilities:

1. Incorrect calculation of requiredShares in redeemToken, leading to incorrect share amounts being withdrawn. This could result in users either receiving more tokens than they should (if shares are overestimated) or not being able to redeem small amounts (if shares are underestimated).

2. Reentrancy in redeemToken: The function performs external calls (badgerSett.withdraw and badger.transfer) after updating the user's balance. Wait, no—the user's balance is updated after the withdraw. Let's check the order again:

- badgerSett.withdraw(requiredSharesBalance); // external call
- balances[msg.sender] = balances[msg.sender].sub(requiredSharesBalance);
- badger.transfer(msg.sender, badgerBalanceDiff); // another external call

So the external calls happen before the balance is updated. This means that during the withdraw, if the Sett's withdraw function calls back into the contract, the user's balance hasn't been reduced yet. So an attacker could potentially call redeemToken again in a reentrant manner, and since their balance is still the original amount, they could withdraw multiple times, each time using the same balance, leading to draining of funds.

For example:

- Attacker has 100 shares.
- They call redeemToken(100). The contract calculates requiredShares and withdraws.
- During the withdraw, the attacker's contract is called, and they call redeemToken again.
- Since the balance hasn't been updated yet (it's done after withdraw), the second redeemToken would process the same 100 shares, leading to another withdrawal.
- After both calls, the attacker's balance is reduced by 100 shares (from the first call) and another requiredSharesBalance from the second, but they've received twice the tokens.

This is a classic reentrancy vulnerability. The state update (subtracting the shares) happens after the external call, which is unsafe.

3. Incorrect handling of ERC20 approvals in supplyTokenTo: The code approves the Sett for the exact 'amount' each time. If there was a previous approval, the new approval could be front-run. For example, if the contract previously approved the Sett to spend X tokens, and then a user calls supplyTokenTo with Y tokens, the approval is set to Y. If an attacker sees this and front-runs the approve transaction with a transferFrom, they could steal the Y tokens. However, this would require the contract to have an existing allowance, but since the code approves exactly 'amount', and then immediately deposits that amount, the window is small. Still, it's a known issue with the ERC20 approve function. To mitigate, it's better to set the allowance to zero first and then to the new amount. But the code doesn't do that, leading to a possible race condition.

4. Potential underflow in requiredSharesBalance calculation: If requiredShares is zero (due to the formula), but that's checked before. However, if requiredShares is 1, subtracting 1 would give zero. Withdrawing zero shares might not give any tokens, leading to the user not being able to redeem small amounts. But since requiredShares is calculated as (amount * totalShares + totalShares)/badgerSettBadgerBalance, it's possible that for small amounts, requiredShares rounds down to zero, but with the addition of totalShares, it becomes 1. Then subtracting 1 would be zero. So the code would withdraw zero shares, leading to no tokens redeemed. So the user's balance isn't decreased, but they might have expected to redeem some tokens.

5. The formula in redeemToken for requiredShares is mathematically incorrect, leading to incorrect redemption amounts. This could lead to loss of funds for users or the contract, depending on how the calculation deviates from the correct value.

6. Lack of access control on supplyTokenTo: The function allows anyone to deposit tokens on behalf of any address. If the system expects that users can only deposit for themselves, this is a vulnerability. But if it's intended, then it's not an issue. However, if the contract is part of a system where deposits are supposed to be self-service, this could allow malicious actors to inflate other users' balances, possibly leading to other issues (like rewards distribution based on balances).

So the main vulnerabilities here are:

- Reentrancy in redeemToken due to external calls before state updates.
- Incorrect calculation of requiredShares leading to incorrect redemptions.
- Potential ERC20 approval race condition in supplyTokenTo.
- Possible underflow in requiredSharesBalance (but prevented by SafeMath, which would revert, but requiredShares is checked for zero).
Wait, no: requiredShares is checked for zero. If requiredShares is zero, the function returns zero. Otherwise, requiredSharesBalance is requiredShares.sub(1). So if requiredShares is 1, subtracting 1 is allowed (since 1-1=0). But SafeMath would not underflow here. If requiredShares is zero, the code returns before subtracting. So no underflow. But when requiredShares is 1, requiredSharesBalance is zero, leading to withdrawing zero shares, which may not do anything, hence badgerBalanceDiff would be zero, and the user's balance is reduced by zero. So they can't redeem anything, but their balance remains. That's a problem for small redemptions.

So the key vulnerabilities are the reentrancy and the incorrect requiredShares calculation. Let's make sure.

Reentrancy example:

1. Attacker has 100 shares.
2. They call redeemToken(100), which calculates requiredShares and proceeds to call badgerSett.withdraw(requiredSharesBalance).
3. During the withdraw, the Sett transfers Badger to the contract, which triggers a call to the attacker's contract.
4. The attacker's contract calls redeemToken again with the same shares.
5. Since the attacker's balance hasn't been updated yet (it's done after the external call), the second redeemToken would process the same 100 shares.
6. The second withdraw would give more tokens, and after both calls, the attacker's balance is reduced by requiredSharesBalance twice, but they have already received tokens twice.

Wait, but the requiredShares is based on the current totalShares and badgerSett balance. So during reentrancy, the state of the Sett might have changed, but the initial calculation would still use the original values. This could complicate the attack, but the key point is that the balance is updated after the external call, allowing reentrancy.

Another possible issue: the balanceOfToken function is not a view function. If it's supposed to be a view function in the interface, then this implementation would cause errors when called. But since the function in the contract is not marked as view, and if the interface allows it, then it's not a vulnerability. However, if the function is expected to be view but isn't, it could cause reverts when called in certain contexts (e.g., from another view function).

So listing the vulnerabilities:

1. Reentrancy in redeemToken function due to external calls before updating the user's balance.

2. Incorrect calculation of requiredShares in redeemToken leading to potential over/under-withdrawal of shares and incorrect token redemption amounts.

3. Unsafe ERC20 approval in supplyTokenTo which could allow a race condition (front-running) if the contract's existing allowance is not zero.

4. Potential inability to redeem small amounts due to rounding errors in the requiredShares calculation.

5. Lack of access control on supplyTokenTo allowing any user to deposit tokens to any address, which may be unintended.

I think these are the main issues. The most critical ones are the reentrancy and the incorrect requiredShares calculation.","```
None.
```",0.0
PrizePool.sol,"// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";

/// @title Escrows assets and deposits them into a yield source.  Exposes interest to Prize Strategy.  Users deposit and withdraw from this contract to participate in Prize Pool.
/// @notice Accounting is managed using Controlled Tokens, whose mint and burn functions can only be called by this contract.
/// @dev Must be inherited to provide specific yield-bearing asset control, such as Compound cTokens
abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  /// @dev Emitted when an instance is initialized
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  /// @dev Event emitted when controlled token is added
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  /// @dev Emitted when reserve is captured.
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  /// @dev Event emitted when assets are deposited
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  /// @dev Event emitted when timelocked funds are re-deposited
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when interest is awarded to a winner
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are awarded to a winner
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC20s are transferred out
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  /// @dev Event emitted when external ERC721s are awarded to a winner
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  /// @dev Event emitted when assets are withdrawn instantly
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  /// @dev Event emitted upon a withdrawal with timelock
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  /// @dev Event emitted when timelocked funds are swept back to a user
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  /// @dev Event emitted when the Liquidity Cap is set
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  /// @dev Event emitted when the Credit plan is set
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  /// @dev Event emitted when the Prize Strategy is set
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  /// @dev Emitted when credit is minted
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  /// @dev Emitted when credit is burned
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  /// @dev Reserve to which reserve fees are sent
  RegistryInterface public reserveRegistry;

  /// @dev A linked list of all the controlled tokens
  MappedSinglyLinkedList.Mapping internal _tokens;

  /// @dev The Prize Strategy that this Prize Pool is bound to.
  TokenListenerInterface public prizeStrategy;

  /// @dev The maximum possible exit fee fraction as a fixed point 18 number.
  /// For example, if the maxExitFeeMantissa is ""0.1 ether"", then the maximum exit fee for a withdrawal of 100 Dai will be 10 Dai
  uint256 public maxExitFeeMantissa;

  /// @dev The maximum possible timelock duration for a timelocked withdrawal (in seconds).
  uint256 public maxTimelockDuration;

  /// @dev The total funds that are timelocked.
  uint256 public timelockTotalSupply;

  /// @dev The total funds that have been allocated to the reserve
  uint256 public reserveTotalSupply;

  /// @dev The total amount of funds that the prize pool can hold.
  uint256 public liquidityCap;

  /// @dev the The awardable balance
  uint256 internal _currentAwardBalance;

  /// @dev The timelocked balances for each user
  mapping(address => uint256) internal _timelockBalances;

  /// @dev The unlock timestamps for each user
  mapping(address => uint256) internal _unlockTimestamps;

  /// @dev Stores the credit plan for each token.
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  /// @dev Stores each users balance of credit per token.
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  /// @notice Initializes the Prize Pool
  /// @param _controlledTokens Array of ControlledTokens that are controlled by this Prize Pool.
  /// @param _maxExitFeeMantissa The maximum exit fee size
  /// @param _maxTimelockDuration The maximum length of time the withdraw timelock
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  /// @dev Returns the address of the underlying ERC20 asset
  /// @return The address of the asset
  function token() external override view returns (address) {
    return address(_token());
  }

  /// @dev Returns the total underlying balance of all assets. This includes both principal and interest.
  /// @return The underlying balance of assets
  function balance() external returns (uint256) {
    return _balance();
  }

  /// @dev Checks with the Prize Pool if a specific token type may be awarded as an external prize
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  /// @notice Deposits timelocked tokens for a user back into the Prize Pool as another asset.
  /// @param to The address receiving the tokens
  /// @param amount The amount of timelocked assets to re-deposit
  /// @param controlledToken The type of token to be minted in exchange (i.e. tickets or sponsorship)
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  /// @notice Deposit assets into the Prize Pool in exchange for tokens
  /// @param to The address receiving the newly minted tokens
  /// @param amount The amount of assets to deposit
  /// @param controlledToken The address of the type of token the user is minting
  /// @param referrer The referrer of the deposit
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  /// @notice Withdraw assets from the Prize Pool instantly.  A fairness fee may be charged for an early exit.
  /// @param from The address to redeem tokens from.
  /// @param amount The amount of tokens to redeem for assets.
  /// @param controlledToken The address of the token to redeem (i.e. ticket or sponsorship)
  /// @param maximumExitFee The maximum exit fee the caller is willing to pay.  This should be pre-calculated by the calculateExitFee() fxn.
  /// @return The actual exit fee paid
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    // burn the credit
    _burnCredit(from, controlledToken, burnedCredit);

    // burn the tickets
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    // redeem the tickets less the fee
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  /// @notice Limits the exit fee to the maximum as hard-coded into the contract
  /// @param withdrawalAmount The amount that is attempting to be withdrawn
  /// @param exitFee The exit fee to check against the limit
  /// @return The passed exit fee if it is less than the maximum, otherwise the maximum fee is returned.
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  /// @notice Withdraw assets from the Prize Pool by placing them into the timelock.
  /// The timelock is used to ensure that the tickets have contributed their fair share of the prize.
  /// @dev Note that if the user has previously timelocked funds then this contract will try to sweep them.
  /// If the existing timelocked funds are still locked, then the incoming
  /// balance is added to their existing balance and the new timelock unlock timestamp will overwrite the old one.
  /// @param from The address to withdraw from
  /// @param amount The amount to withdraw
  /// @param controlledToken The type of token being withdrawn
  /// @return The timestamp from which the funds can be swept
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    // return the block at which the funds will be available
    return unlockTimestamp;
  }

  /// @notice Adds to a user's timelock balance.  It will attempt to sweep before updating the balance.
  /// Note that this will overwrite the previous unlock timestamp.
  /// @param user The user whose timelock balance should increase
  /// @param amount The amount to increase by
  /// @param timestamp The new unlock timestamp
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    // Sweep the old balance, if any
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    // if the funds should already be unlocked
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  /// @notice Updates the Prize Strategy when tokens are transferred between holders.
  /// @param from The address the tokens are being transferred from (0 if minting)
  /// @param to The address the tokens are being transferred to (0 if burning)
  /// @param amount The amount of tokens being trasferred
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      // first accrue credit for their old balance
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        // if they are sending funds to someone else, we need to limit their accrued credit to their new balance
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    // if we aren't minting
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  /// @notice Returns the balance that is available to award.
  /// @dev captureAwardBalance() should be called first
  /// @return The total amount of assets to be awarded for the current prize
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  /// @notice Captures any available interest as award balance.
  /// @dev This function also captures the reserve fees.
  /// @return The total amount of assets to be awarded for the current prize
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    // it's possible for the balance to be slightly less due to rounding errors in the underlying yield source
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  /// @notice Called by the prize strategy to award prizes.
  /// @dev The amount awarded must be less than the awardBalance()
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of assets to be awarded
  /// @param controlledToken The address of the asset token being awarded
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  /// @notice Called by the Prize-Strategy to transfer out external ERC20 tokens
  /// @dev Used to transfer out tokens held by the Prize Pool.  Could be liquidated, or anything.
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  /// @notice Called by the Prize-Strategy to award external ERC20 prizes
  /// @dev Used to award any arbitrary tokens held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param amount The amount of external assets to be awarded
  /// @param externalToken The address of the external asset token being awarded
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  /// @notice Called to mint controlled tokens.  Ensures that token listener callbacks are fired.
  /// @param to The user who is receiving the tokens
  /// @param amount The amount of tokens they are receiving
  /// @param controlledToken The token that is going to be minted
  /// @param referrer The user who referred the minting
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  /// @notice Called by the prize strategy to award external ERC721 prizes
  /// @dev Used to award any arbitrary NFTs held by the Prize Pool
  /// @param to The address of the winner that receives the award
  /// @param externalToken The address of the external NFT token being awarded
  /// @param tokenIds An array of NFT Token IDs to be transferred
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  /// @notice Calculates the reserve portion of the given amount of funds.  If there is no reserve address, the portion will be zero.
  /// @param amount The prize amount
  /// @return The size of the reserve portion of the prize
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  /// @notice Sweep all timelocked balances and transfer unlocked assets to owner accounts
  /// @param users An array of account addresses to sweep balances for
  /// @return The total amount of assets swept from the Prize Pool
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  /// @notice Sweep available timelocked balances to their owners.  The full balances will be swept to the owners.
  /// @param users An array of owner addresses
  /// @return The total amount of assets swept from the Prize Pool
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    // if there is nothing to do, just quit
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  /// @notice Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  /// @dev Calculates a timelocked withdrawal duration and credit consumption.
  /// @param from The user who is withdrawing
  /// @param amount The amount the user is withdrawing
  /// @param controlledToken The type of collateral the user is withdrawing (i.e. ticket or sponsorship)
  /// @return durationSeconds The duration of the timelock in seconds
  /// @return burnedCredit The credit that was burned
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  /// @notice Calculates the early exit fee for the given amount
  /// @param from The user who is withdrawing
  /// @param controlledToken The type of collateral being withdrawn
  /// @param amount The amount of collateral to be withdrawn
  /// @return exitFee The exit fee
  /// @return burnedCredit The user's credit that was burned
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  /// @dev Calculates the early exit fee for the given amount
  /// @param amount The amount of collateral to be withdrawn
  /// @return Exit fee
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit.
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  /// @notice Estimates the amount of time it will take for a given amount of funds to accrue the given amount of credit
  /// @param _principal The principal amount on which interest is accruing
  /// @param _interest The amount of interest that must accrue
  /// @return durationSeconds The duration of time it will take to accrue the given amount of interest, in seconds.
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    // interest = credit rate * principal * time
    // => time = interest / (credit rate * principal)
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  /// @notice Burns a users credit.
  /// @param user The user whose credit should be burned
  /// @param credit The amount of credit to burn
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  /// @notice Accrues ticket credit for a user assuming their current balance is the passed balance.  May burn credit if they exceed their limit.
  /// @param user The user for whom to accrue credit
  /// @param controlledToken The controlled token whose balance we are checking
  /// @param controlledTokenBalance The balance to use for the user
  /// @param extra Additional credit to be added
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  /// @notice Applies the credit limit to a credit balance.  The balance cannot exceed the credit limit.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The users ticket balance (used to calculate credit limit)
  /// @param creditBalance The new credit balance to be checked
  /// @return The users new credit balance.  Will not exceed the credit limit.
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  /// @notice Calculates the accrued interest for a user
  /// @param user The user whose credit should be calculated.
  /// @param controlledToken The controlled token that the user holds
  /// @param controlledTokenBalance The user's current balance of the controlled tokens.
  /// @return The credit that has accrued since the last credit update.
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  /// @notice Returns the credit balance for a given user.  Not that this includes both minted credit and pending credit.
  /// @param user The user whose credit balance should be returned
  /// @return The balance of the users credit
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  /// @notice Sets the rate at which credit accrues per second.  The credit rate is a fixed point 18 number (like Ether).
  /// @param _controlledToken The controlled token for whom to set the credit plan
  /// @param _creditRateMantissa The credit rate to set.  Is a fixed point 18 decimal (like Ether).
  /// @param _creditLimitMantissa The credit limit to set.  Is a fixed point 18 decimal (like Ether).
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  /// @notice Returns the credit rate of a controlled token
  /// @param controlledToken The controlled token to retrieve the credit rates for
  /// @return creditLimitMantissa The credit limit fraction.  This number is used to calculate both the credit limit and early exit fee.
  /// @return creditRateMantissa The credit rate. This is the amount of tokens that accrue per second.
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  /// @notice Calculate the early exit for a user given a withdrawal amount.  The user's credit is taken into account.
  /// @param from The user who is withdrawing
  /// @param controlledToken The token they are withdrawing
  /// @param amount The amount of funds they are withdrawing
  /// @return earlyExitFee The additional exit fee that should be charged.
  /// @return creditBurned The amount of credit that will be burned
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    /*
    The credit is used *last*.  Always charge the fees up-front.

    How to calculate:

    Calculate their remaining exit fee.  I.e. full exit fee of their balance less their credit.

    If the exit fee on their withdrawal is greater than the remaining exit fee, then they'll have to pay the difference.
    */

    // Determine available usable credit based on withdraw amount
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    // Determine amount of credit to burn and amount of fees required
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  /// @notice Allows the Governor to set a cap on the amount of liquidity that he pool can hold
  /// @param _liquidityCap The new liquidity cap for the prize pool
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  /// @notice Adds a new controlled token
  /// @param _controlledToken The controlled token to add.  Cannot be a duplicate.
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  /// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.
  /// @param _prizeStrategy The new prize strategy
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  /// @notice An array of the Tokens controlled by the Prize Pool (ie. Tickets, Sponsorship)
  /// @return An array of controlled token addresses
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  /// @dev Gets the current time as represented by the current block
  /// @return The timestamp of the current block
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  /// @notice The timestamp at which an account's timelocked balance will be made available to sweep
  /// @param user The address of an account with timelocked assets
  /// @return The timestamp at which the locked assets will be made available
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  /// @notice The balance of timelocked assets for an account
  /// @param user The address of an account with timelocked assets
  /// @return The amount of assets that have been timelocked
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  /// @notice Delegate the votes for a Compound COMP-like token held by the prize pool
  /// @param compLike The COMP-like token held by the prize pool that should be delegated
  /// @param to The address to delegate to 
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  /// @notice The total of all controlled tokens and timelock.
  /// @return The current total of all tokens and timelock.
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  /// @dev Checks if the Prize Pool can receive liquidity based on the current cap
  /// @param _amount The amount of liquidity to be added to the Prize Pool
  /// @return True if the Prize Pool can receive the specified amount of liquidity
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  /// @dev Checks if a specific token is controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  /// @return True if the token is a controlled token, false otherwise
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  /// @notice Determines whether the passed token can be transferred out as an external award.
  /// @dev Different yield sources will hold the deposits as another kind of token: such a Compound's cToken.  The
  /// prize strategy should not be allowed to move those tokens.
  /// @param _externalToken The address of the token to check
  /// @return True if the token may be awarded, false otherwise
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  /// @notice Returns the ERC20 asset token used for deposits.
  /// @return The ERC20 asset token
  function _token() internal virtual view returns (IERC20Upgradeable);

  /// @notice Returns the total balance (in asset tokens).  This includes the deposits and interest.
  /// @return The underlying balance of asset tokens
  function _balance() internal virtual returns (uint256);

  /// @notice Supplies asset tokens to the yield source.
  /// @param mintAmount The amount of asset tokens to be supplied
  function _supply(uint256 mintAmount) internal virtual;

  /// @notice Redeems asset tokens from the yield source.
  /// @param redeemAmount The amount of yield-bearing tokens to be redeemed
  /// @return The actual amount of tokens that were redeemed.
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  /// @dev Function modifier to ensure usage of tokens controlled by the Prize Pool
  /// @param controlledToken The address of the token to check
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  /// @dev Function modifier to ensure caller is the prize-strategy
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  /// @dev Function modifier to ensure the deposit amount does not exceed the liquidity cap (if set)
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}",10191.0,1131.0,"[H-04] withdraw timelock can be circumvented
One can withdraw the entire PrizePool deposit by circumventing the timelock. Assume the user has no credits for ease of computation:
- user calls `withdrawWithTimelockFrom(user, amount=userBalance)` with their entire balance. This ""mints"" an equivalent amount of timelock and resets _unlockTimestamps[user] = timestamp = blockTime + lockDuration.
- user calls `withdrawWithTimelockFrom(user, amount=0)` again but this time withdrawing 0 amount. This will return a lockDuration of 0 and thus unlockTimestamp = blockTime. The inner _mintTimelock now resets _unlockTimestamps[user] = unlockTimestamp
- As if `(timestamp <= _currentTime())`  is true, the full users amount is now transferred out to the user in the `_sweepTimelockBalances` call.
Users don't need to wait for their deposit to contribute their fair share to the prize pool. They can join before the awards and leave right after without a penalty which leads to significant issues for the protocol. It's the superior strategy but it leads to no investments in the strategy to earn the actual interest.
  [M-07] Using transferFrom on ERC721 tokens
In the function `awardExternalERC721` of contract `PrizePool`, when awarding external ERC721 tokens to the winners, the `transferFrom` keyword is used instead of safeTransferFrom. If any winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be locked.",2.0,"pragma solidity >=0.6.0 <0.7.0;

import ""@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/SafeCastUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/introspection/ERC165CheckerUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol"";
import ""@pooltogether/fixed-point/contracts/FixedPoint.sol"";

import ""../external/compound/ICompLike.sol"";
import ""../reserve/RegistryInterface.sol"";
import ""../reserve/ReserveInterface.sol"";
import ""../token/TokenListenerInterface.sol"";
import ""../token/TokenListenerLibrary.sol"";
import ""../token/ControlledToken.sol"";
import ""../token/TokenControllerInterface.sol"";
import ""../utils/MappedSinglyLinkedList.sol"";
import ""./PrizePoolInterface.sol"";




abstract contract PrizePool is PrizePoolInterface, OwnableUpgradeable, ReentrancyGuardUpgradeable, TokenControllerInterface {
  using SafeMathUpgradeable for uint256;
  using SafeCastUpgradeable for uint256;
  using SafeERC20Upgradeable for IERC20Upgradeable;
  using MappedSinglyLinkedList for MappedSinglyLinkedList.Mapping;
  using ERC165CheckerUpgradeable for address;

  
  event Initialized(
    address reserveRegistry,
    uint256 maxExitFeeMantissa,
    uint256 maxTimelockDuration
  );

  
  event ControlledTokenAdded(
    ControlledTokenInterface indexed token
  );

  
  event ReserveFeeCaptured(
    uint256 amount
  );

  event AwardCaptured(
    uint256 amount
  );

  
  event Deposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount,
    address referrer
  );

  
  event TimelockDeposited(
    address indexed operator,
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event Awarded(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC20(
    address indexed winner,
    address indexed token,
    uint256 amount
  );

  
  event TransferredExternalERC20(
    address indexed to,
    address indexed token,
    uint256 amount
  );

  
  event AwardedExternalERC721(
    address indexed winner,
    address indexed token,
    uint256[] tokenIds
  );

  
  event InstantWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 redeemed,
    uint256 exitFee
  );

  
  event TimelockedWithdrawal(
    address indexed operator,
    address indexed from,
    address indexed token,
    uint256 amount,
    uint256 unlockTimestamp
  );

  event ReserveWithdrawal(
    address indexed to,
    uint256 amount
  );

  
  event TimelockedWithdrawalSwept(
    address indexed operator,
    address indexed from,
    uint256 amount,
    uint256 redeemed
  );

  
  event LiquidityCapSet(
    uint256 liquidityCap
  );

  
  event CreditPlanSet(
    address token,
    uint128 creditLimitMantissa,
    uint128 creditRateMantissa
  );

  
  event PrizeStrategySet(
    address indexed prizeStrategy
  );

  
  event CreditMinted(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  
  event CreditBurned(
    address indexed user,
    address indexed token,
    uint256 amount
  );

  struct CreditPlan {
    uint128 creditLimitMantissa;
    uint128 creditRateMantissa;
  }

  struct CreditBalance {
    uint192 balance;
    uint32 timestamp;
    bool initialized;
  }

  
  RegistryInterface public reserveRegistry;

  
  MappedSinglyLinkedList.Mapping internal _tokens;

  
  TokenListenerInterface public prizeStrategy;

  
  
  uint256 public maxExitFeeMantissa;

  
  uint256 public maxTimelockDuration;

  
  uint256 public timelockTotalSupply;

  
  uint256 public reserveTotalSupply;

  
  uint256 public liquidityCap;

  
  uint256 internal _currentAwardBalance;

  
  mapping(address => uint256) internal _timelockBalances;

  
  mapping(address => uint256) internal _unlockTimestamps;

  
  mapping(address => CreditPlan) internal _tokenCreditPlans;

  
  mapping(address => mapping(address => CreditBalance)) internal _tokenCreditBalances;

  
  
  
  
  function initialize (
    RegistryInterface _reserveRegistry,
    ControlledTokenInterface[] memory _controlledTokens,
    uint256 _maxExitFeeMantissa,
    uint256 _maxTimelockDuration
  )
    public
    initializer
  {
    require(address(_reserveRegistry) != address(0), ""PrizePool/reserveRegistry-not-zero"");
    _tokens.initialize();
    for (uint256 i = 0; i < _controlledTokens.length; i++) {
      _addControlledToken(_controlledTokens[i]);
    }
    __Ownable_init();
    __ReentrancyGuard_init();
    _setLiquidityCap(uint256(-1));

    reserveRegistry = _reserveRegistry;
    maxExitFeeMantissa = _maxExitFeeMantissa;
    maxTimelockDuration = _maxTimelockDuration;

    emit Initialized(
      address(_reserveRegistry),
      maxExitFeeMantissa,
      maxTimelockDuration
    );
  }

  
  
  function token() external override view returns (address) {
    return address(_token());
  }

  
  
  function balance() external returns (uint256) {
    return _balance();
  }

  
  
  
  function canAwardExternal(address _externalToken) external view returns (bool) {
    return _canAwardExternal(_externalToken);
  }

  
  
  
  
  function timelockDepositTo(
    address to,
    uint256 amount,
    address controlledToken
  )
    external
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();
    _mint(to, amount, controlledToken, address(0));
    _timelockBalances[operator] = _timelockBalances[operator].sub(amount);
    timelockTotalSupply = timelockTotalSupply.sub(amount);

    emit TimelockDeposited(operator, to, controlledToken, amount);
  }

  
  
  
  
  
  function depositTo(
    address to,
    uint256 amount,
    address controlledToken,
    address referrer
  )
    external override
    onlyControlledToken(controlledToken)
    canAddLiquidity(amount)
    nonReentrant
  {
    address operator = _msgSender();

    _mint(to, amount, controlledToken, referrer);

    _token().safeTransferFrom(operator, address(this), amount);
    _supply(amount);

    emit Deposited(operator, to, controlledToken, amount, referrer);
  }

  
  
  
  
  
  
  function withdrawInstantlyFrom(
    address from,
    uint256 amount,
    address controlledToken,
    uint256 maximumExitFee
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    (uint256 exitFee, uint256 burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    require(exitFee <= maximumExitFee, ""PrizePool/exit-fee-exceeds-user-maximum"");

    
    _burnCredit(from, controlledToken, burnedCredit);

    
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);

    
    uint256 amountLessFee = amount.sub(exitFee);
    uint256 redeemed = _redeem(amountLessFee);

    _token().safeTransfer(from, redeemed);

    emit InstantWithdrawal(_msgSender(), from, controlledToken, amount, redeemed, exitFee);

    return exitFee;
  }

  
  
  
  
  function _limitExitFee(uint256 withdrawalAmount, uint256 exitFee) internal view returns (uint256) {
    uint256 maxFee = FixedPoint.multiplyUintByMantissa(withdrawalAmount, maxExitFeeMantissa);
    if (exitFee > maxFee) {
      exitFee = maxFee;
    }
    return exitFee;
  }

  
  
  
  
  
  
  
  
  
  function withdrawWithTimelockFrom(
    address from,
    uint256 amount,
    address controlledToken
  )
    external override
    nonReentrant
    onlyControlledToken(controlledToken)
    returns (uint256)
  {
    uint256 blockTime = _currentTime();
    (uint256 lockDuration, uint256 burnedCredit) = _calculateTimelockDuration(from, controlledToken, amount);
    uint256 unlockTimestamp = blockTime.add(lockDuration);
    _burnCredit(from, controlledToken, burnedCredit);
    ControlledToken(controlledToken).controllerBurnFrom(_msgSender(), from, amount);
    _mintTimelock(from, amount, unlockTimestamp);
    emit TimelockedWithdrawal(_msgSender(), from, controlledToken, amount, unlockTimestamp);

    
    return unlockTimestamp;
  }

  
  
  
  
  
  function _mintTimelock(address user, uint256 amount, uint256 timestamp) internal {
    
    address[] memory users = new address[](1);
    users[0] = user;
    _sweepTimelockBalances(users);

    timelockTotalSupply = timelockTotalSupply.add(amount);
    _timelockBalances[user] = _timelockBalances[user].add(amount);
    _unlockTimestamps[user] = timestamp;

    
    if (timestamp <= _currentTime()) {
      _sweepTimelockBalances(users);
    }
  }

  
  
  
  
  function beforeTokenTransfer(address from, address to, uint256 amount) external override onlyControlledToken(msg.sender) {
    if (from != address(0)) {
      uint256 fromBeforeBalance = IERC20Upgradeable(msg.sender).balanceOf(from);
      
      uint256 newCreditBalance = _calculateCreditBalance(from, msg.sender, fromBeforeBalance, 0);

      if (from != to) {
        
        newCreditBalance = _applyCreditLimit(msg.sender, fromBeforeBalance.sub(amount), newCreditBalance);
      }

      _updateCreditBalance(from, msg.sender, newCreditBalance);
    }
    if (to != address(0) && to != from) {
      _accrueCredit(to, msg.sender, IERC20Upgradeable(msg.sender).balanceOf(to), 0);
    }
    
    if (from != address(0) && address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenTransfer(from, to, amount, msg.sender);
    }
  }

  
  
  
  function awardBalance() external override view returns (uint256) {
    return _currentAwardBalance;
  }

  
  
  
  function captureAwardBalance() external override nonReentrant returns (uint256) {
    uint256 tokenTotalSupply = _tokenTotalSupply();

    
    uint256 currentBalance = _balance();
    uint256 totalInterest = (currentBalance > tokenTotalSupply) ? currentBalance.sub(tokenTotalSupply) : 0;
    uint256 unaccountedPrizeBalance = (totalInterest > _currentAwardBalance) ? totalInterest.sub(_currentAwardBalance) : 0;

    if (unaccountedPrizeBalance > 0) {
      uint256 reserveFee = calculateReserveFee(unaccountedPrizeBalance);
      if (reserveFee > 0) {
        reserveTotalSupply = reserveTotalSupply.add(reserveFee);
        unaccountedPrizeBalance = unaccountedPrizeBalance.sub(reserveFee);
        emit ReserveFeeCaptured(reserveFee);
      }
      _currentAwardBalance = _currentAwardBalance.add(unaccountedPrizeBalance);

      emit AwardCaptured(unaccountedPrizeBalance);
    }

    return _currentAwardBalance;
  }

  function withdrawReserve(address to) external override onlyReserve returns (uint256) {

    uint256 amount = reserveTotalSupply;
    reserveTotalSupply = 0;
    uint256 redeemed = _redeem(amount);

    _token().safeTransfer(address(to), redeemed);

    emit ReserveWithdrawal(to, amount);

    return redeemed;
  }

  
  
  
  
  
  function award(
    address to,
    uint256 amount,
    address controlledToken
  )
    external override
    onlyPrizeStrategy
    onlyControlledToken(controlledToken)
  {
    if (amount == 0) {
      return;
    }

    require(amount <= _currentAwardBalance, ""PrizePool/award-exceeds-avail"");
    _currentAwardBalance = _currentAwardBalance.sub(amount);

    _mint(to, amount, controlledToken, address(0));

    uint256 extraCredit = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    _accrueCredit(to, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(to), extraCredit);

    emit Awarded(to, controlledToken, amount);
  }

  
  
  
  
  
  function transferExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit TransferredExternalERC20(to, externalToken, amount);
    }
  }

  
  
  
  
  
  function awardExternalERC20(
    address to,
    address externalToken,
    uint256 amount
  )
    external override
    onlyPrizeStrategy
  {
    if (_transferOut(to, externalToken, amount)) {
      emit AwardedExternalERC20(to, externalToken, amount);
    }
  }

  function _transferOut(
    address to,
    address externalToken,
    uint256 amount
  )
    internal
    returns (bool)
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (amount == 0) {
      return false;
    }

    IERC20Upgradeable(externalToken).safeTransfer(to, amount);

    return true;
  }

  
  
  
  
  
  function _mint(address to, uint256 amount, address controlledToken, address referrer) internal {
    if (address(prizeStrategy) != address(0)) {
      prizeStrategy.beforeTokenMint(to, amount, controlledToken, referrer);
    }
    ControlledToken(controlledToken).controllerMint(to, amount);
  }

  
  
  
  
  
  function awardExternalERC721(
    address to,
    address externalToken,
    uint256[] calldata tokenIds
  )
    external override
    onlyPrizeStrategy
  {
    require(_canAwardExternal(externalToken), ""PrizePool/invalid-external-token"");

    if (tokenIds.length == 0) {
      return;
    }

    for (uint256 i = 0; i < tokenIds.length; i++) {
      IERC721Upgradeable(externalToken).transferFrom(address(this), to, tokenIds[i]);
    }

    emit AwardedExternalERC721(to, externalToken, tokenIds);
  }

  
  
  
  function calculateReserveFee(uint256 amount) public view returns (uint256) {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    if (address(reserve) == address(0)) {
      return 0;
    }
    uint256 reserveRateMantissa = reserve.reserveRateMantissa(address(this));
    if (reserveRateMantissa == 0) {
      return 0;
    }
    return FixedPoint.multiplyUintByMantissa(amount, reserveRateMantissa);
  }

  
  
  
  function sweepTimelockBalances(
    address[] calldata users
  )
    external override
    nonReentrant
    returns (uint256)
  {
    return _sweepTimelockBalances(users);
  }

  
  
  
  function _sweepTimelockBalances(
    address[] memory users
  )
    internal
    returns (uint256)
  {
    address operator = _msgSender();

    uint256[] memory balances = new uint256[](users.length);

    uint256 totalWithdrawal;

    uint256 i;
    for (i = 0; i < users.length; i++) {
      address user = users[i];
      if (_unlockTimestamps[user] <= _currentTime()) {
        totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);
        balances[i] = _timelockBalances[user];
        delete _timelockBalances[user];
      }
    }

    
    if (totalWithdrawal == 0) {
      return 0;
    }

    timelockTotalSupply = timelockTotalSupply.sub(totalWithdrawal);

    uint256 redeemed = _redeem(totalWithdrawal);

    IERC20Upgradeable underlyingToken = IERC20Upgradeable(_token());

    for (i = 0; i < users.length; i++) {
      if (balances[i] > 0) {
        delete _unlockTimestamps[users[i]];
        uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);
        uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);
        underlyingToken.safeTransfer(users[i], transferAmount);
        emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);
      }
    }

    return totalWithdrawal;
  }

  
  
  
  
  
  function calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    return _calculateTimelockDuration(from, controlledToken, amount);
  }

  
  
  
  
  
  
  function _calculateTimelockDuration(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 durationSeconds,
      uint256 burnedCredit
    )
  {
    (uint256 exitFee, uint256 _burnedCredit) = _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
    uint256 duration = _estimateCreditAccrualTime(controlledToken, amount, exitFee);
    if (duration > maxTimelockDuration) {
      duration = maxTimelockDuration;
    }
    return (duration, _burnedCredit);
  }

  
  
  
  
  
  
  function calculateEarlyExitFee(
    address from,
    address controlledToken,
    uint256 amount
  )
    external override
    returns (
      uint256 exitFee,
      uint256 burnedCredit
    )
  {
    return _calculateEarlyExitFeeLessBurnedCredit(from, controlledToken, amount);
  }

  
  
  
  function _calculateEarlyExitFeeNoCredit(address controlledToken, uint256 amount) internal view returns (uint256) {
    return _limitExitFee(
      amount,
      FixedPoint.multiplyUintByMantissa(amount, _tokenCreditPlans[controlledToken].creditLimitMantissa)
    );
  }

  
  
  
  
  function estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    external override
    view
    returns (uint256 durationSeconds)
  {
    return _estimateCreditAccrualTime(
      _controlledToken,
      _principal,
      _interest
    );
  }

  
  
  
  
  function _estimateCreditAccrualTime(
    address _controlledToken,
    uint256 _principal,
    uint256 _interest
  )
    internal
    view
    returns (uint256 durationSeconds)
  {
    
    
    uint256 accruedPerSecond = FixedPoint.multiplyUintByMantissa(_principal, _tokenCreditPlans[_controlledToken].creditRateMantissa);
    if (accruedPerSecond == 0) {
      return 0;
    }
    return _interest.div(accruedPerSecond);
  }

  
  
  
  function _burnCredit(address user, address controlledToken, uint256 credit) internal {
    _tokenCreditBalances[controlledToken][user].balance = uint256(_tokenCreditBalances[controlledToken][user].balance).sub(credit).toUint128();

    emit CreditBurned(user, controlledToken, credit);
  }

  
  
  
  
  
  function _accrueCredit(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal {
    _updateCreditBalance(
      user,
      controlledToken,
      _calculateCreditBalance(user, controlledToken, controlledTokenBalance, extra)
    );
  }

  function _calculateCreditBalance(address user, address controlledToken, uint256 controlledTokenBalance, uint256 extra) internal view returns (uint256) {
    uint256 newBalance;
    CreditBalance storage creditBalance = _tokenCreditBalances[controlledToken][user];
    if (!creditBalance.initialized) {
      newBalance = 0;
    } else {
      uint256 credit = _calculateAccruedCredit(user, controlledToken, controlledTokenBalance);
      newBalance = _applyCreditLimit(controlledToken, controlledTokenBalance, uint256(creditBalance.balance).add(credit).add(extra));
    }
    return newBalance;
  }

  function _updateCreditBalance(address user, address controlledToken, uint256 newBalance) internal {
    uint256 oldBalance = _tokenCreditBalances[controlledToken][user].balance;

    _tokenCreditBalances[controlledToken][user] = CreditBalance({
      balance: newBalance.toUint128(),
      timestamp: _currentTime().toUint32(),
      initialized: true
    });

    if (oldBalance < newBalance) {
      emit CreditMinted(user, controlledToken, newBalance.sub(oldBalance));
    } else {
      emit CreditBurned(user, controlledToken, oldBalance.sub(newBalance));
    }
  }

  
  
  
  
  
  function _applyCreditLimit(address controlledToken, uint256 controlledTokenBalance, uint256 creditBalance) internal view returns (uint256) {
    uint256 creditLimit = FixedPoint.multiplyUintByMantissa(
      controlledTokenBalance,
      _tokenCreditPlans[controlledToken].creditLimitMantissa
    );
    if (creditBalance > creditLimit) {
      creditBalance = creditLimit;
    }

    return creditBalance;
  }

  
  
  
  
  
  function _calculateAccruedCredit(address user, address controlledToken, uint256 controlledTokenBalance) internal view returns (uint256) {
    uint256 userTimestamp = _tokenCreditBalances[controlledToken][user].timestamp;

    if (!_tokenCreditBalances[controlledToken][user].initialized) {
      return 0;
    }

    uint256 deltaTime = _currentTime().sub(userTimestamp);
    uint256 creditPerSecond = FixedPoint.multiplyUintByMantissa(controlledTokenBalance, _tokenCreditPlans[controlledToken].creditRateMantissa);
    return deltaTime.mul(creditPerSecond);
  }

  
  
  
  function balanceOfCredit(address user, address controlledToken) external override onlyControlledToken(controlledToken) returns (uint256) {
    _accrueCredit(user, controlledToken, IERC20Upgradeable(controlledToken).balanceOf(user), 0);
    return _tokenCreditBalances[controlledToken][user].balance;
  }

  
  
  
  
  function setCreditPlanOf(
    address _controlledToken,
    uint128 _creditRateMantissa,
    uint128 _creditLimitMantissa
  )
    external override
    onlyControlledToken(_controlledToken)
    onlyOwner
  {
    _tokenCreditPlans[_controlledToken] = CreditPlan({
      creditLimitMantissa: _creditLimitMantissa,
      creditRateMantissa: _creditRateMantissa
    });

    emit CreditPlanSet(_controlledToken, _creditLimitMantissa, _creditRateMantissa);
  }

  
  
  
  
  function creditPlanOf(
    address controlledToken
  )
    external override
    view
    returns (
      uint128 creditLimitMantissa,
      uint128 creditRateMantissa
    )
  {
    creditLimitMantissa = _tokenCreditPlans[controlledToken].creditLimitMantissa;
    creditRateMantissa = _tokenCreditPlans[controlledToken].creditRateMantissa;
  }

  
  
  
  
  
  
  function _calculateEarlyExitFeeLessBurnedCredit(
    address from,
    address controlledToken,
    uint256 amount
  )
    internal
    returns (
      uint256 earlyExitFee,
      uint256 creditBurned
    )
  {
    uint256 controlledTokenBalance = IERC20Upgradeable(controlledToken).balanceOf(from);
    require(controlledTokenBalance >= amount, ""PrizePool/insuff-funds"");
    _accrueCredit(from, controlledToken, controlledTokenBalance, 0);
    

    
    uint256 remainingExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, controlledTokenBalance.sub(amount));

    uint256 availableCredit;
    if (_tokenCreditBalances[controlledToken][from].balance >= remainingExitFee) {
      availableCredit = uint256(_tokenCreditBalances[controlledToken][from].balance).sub(remainingExitFee);
    }

    
    uint256 totalExitFee = _calculateEarlyExitFeeNoCredit(controlledToken, amount);
    creditBurned = (availableCredit > totalExitFee) ? totalExitFee : availableCredit;
    earlyExitFee = totalExitFee.sub(creditBurned);
    return (earlyExitFee, creditBurned);
  }

  
  
  function setLiquidityCap(uint256 _liquidityCap) external override onlyOwner {
    _setLiquidityCap(_liquidityCap);
  }

  function _setLiquidityCap(uint256 _liquidityCap) internal {
    liquidityCap = _liquidityCap;
    emit LiquidityCapSet(_liquidityCap);
  }

  
  
  function _addControlledToken(ControlledTokenInterface _controlledToken) internal {
    require(_controlledToken.controller() == this, ""PrizePool/token-ctrlr-mismatch"");
    _tokens.addAddress(address(_controlledToken));

    emit ControlledTokenAdded(_controlledToken);
  }

  
  
  function setPrizeStrategy(TokenListenerInterface _prizeStrategy) external override onlyOwner {
    _setPrizeStrategy(_prizeStrategy);
  }

  
  
  function _setPrizeStrategy(TokenListenerInterface _prizeStrategy) internal {
    require(address(_prizeStrategy) != address(0), ""PrizePool/prizeStrategy-not-zero"");
    require(address(_prizeStrategy).supportsInterface(TokenListenerLibrary.ERC165_INTERFACE_ID_TOKEN_LISTENER), ""PrizePool/prizeStrategy-invalid"");
    prizeStrategy = _prizeStrategy;

    emit PrizeStrategySet(address(_prizeStrategy));
  }

  
  
  function tokens() external override view returns (address[] memory) {
    return _tokens.addressArray();
  }

  
  
  function _currentTime() internal virtual view returns (uint256) {
    return block.timestamp;
  }

  
  
  
  function timelockBalanceAvailableAt(address user) external override view returns (uint256) {
    return _unlockTimestamps[user];
  }

  
  
  
  function timelockBalanceOf(address user) external override view returns (uint256) {
    return _timelockBalances[user];
  }

  
  
  function accountedBalance() external override view returns (uint256) {
    return _tokenTotalSupply();
  }

  
  
  
  function compLikeDelegate(ICompLike compLike, address to) external onlyOwner {
    if (compLike.balanceOf(address(this)) > 0) {
      compLike.delegate(to);
    }
  }

  
  
  function _tokenTotalSupply() internal view returns (uint256) {
    uint256 total = timelockTotalSupply.add(reserveTotalSupply);
    address currentToken = _tokens.start();
    while (currentToken != address(0) && currentToken != _tokens.end()) {
      total = total.add(IERC20Upgradeable(currentToken).totalSupply());
      currentToken = _tokens.next(currentToken);
    }
    return total;
  }

  
  
  
  function _canAddLiquidity(uint256 _amount) internal view returns (bool) {
    uint256 tokenTotalSupply = _tokenTotalSupply();
    return (tokenTotalSupply.add(_amount) <= liquidityCap);
  }

  
  
  
  function _isControlled(address controlledToken) internal view returns (bool) {
    return _tokens.contains(controlledToken);
  }

  
  
  
  
  
  function _canAwardExternal(address _externalToken) internal virtual view returns (bool);

  
  
  function _token() internal virtual view returns (IERC20Upgradeable);

  
  
  function _balance() internal virtual returns (uint256);

  
  
  function _supply(uint256 mintAmount) internal virtual;

  
  
  
  function _redeem(uint256 redeemAmount) internal virtual returns (uint256);

  
  
  modifier onlyControlledToken(address controlledToken) {
    require(_isControlled(controlledToken), ""PrizePool/unknown-token"");
    _;
  }

  
  modifier onlyPrizeStrategy() {
    require(_msgSender() == address(prizeStrategy), ""PrizePool/only-prizeStrategy"");
    _;
  }

  
  modifier canAddLiquidity(uint256 _amount) {
    require(_canAddLiquidity(_amount), ""PrizePool/exceeds-liquidity-cap"");
    _;
  }

  modifier onlyReserve() {
    ReserveInterface reserve = ReserveInterface(reserveRegistry.lookup());
    require(address(reserve) == msg.sender, ""PrizePool/only-reserve"");
    _;
  }
}",6300.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Dependence on External Registry**: The contract relies on `reserveRegistry` to determine the reserve address. If the registry is compromised or returns a malicious address, the `withdrawReserve` function could transfer funds to an attacker-controlled address.

2. **Prize Strategy Privileges**: The `prizeStrategy` has extensive privileges (e.g., awarding funds, transferring external tokens). If set to a malicious contract (via compromised owner), it could drain assets or manipulate awards.

3. **Unbounded Loops in ERC721 Awards**: The `awardExternalERC721` function loops over an array of token IDs. A large array could exceed gas limits, causing transaction failures (DoS).

4. **Timestamp Reliance**: The contract uses `block.timestamp` for timelock unlocks, which miners can manipulate within a small margin, potentially affecting withdrawal timing.

5. **Reentrancy Risk via ERC721 Transfers**: When transferring ERC721 tokens, a malicious NFT contract could reenter the PrizePool during `awardExternalERC721`, potentially interacting with unprotected functions.

6. **Admin Privilege Risks**: The owner can set critical parameters (e.g., `liquidityCap`, `prizeStrategy`). A compromised owner could disrupt operations or steal funds.

7. **Rounding Errors in Redemption**: During timelock sweeps (`_sweepTimelockBalances`), rounding in proportional distribution might leave residual funds (dust) in the contract unaccounted for.

8. **ERC20/ERC721 Compliance Risks**: Assumptions about external token behaviors (e.g., return values, standard compliance) could lead to failures if tokens deviate from expectations, despite using SafeERC20.

9. **Upgradeable Initialization Risks**: The `initialize` function is `public` and uses an `initializer` modifier. Improper handling in child contracts could allow reinitialization attacks.

10. **Unchecked External Calls in `compLikeDelegate`**: Delegating votes via `compLikeDelegate` assumes the COMP-like token is benign, but a malicious token could exploit this during delegation.

11. **Credit System Edge Cases**: The credit balance calculations depend on accurate time and rate settings. Misconfiguration (e.g., excessive rates) could lead to incorrect fee calculations or overflows (mitigated by SafeMath, but logic errors remain possible).

12. **Liquidity Cap Bypass via Malicious Tokens**: If a malicious controlled token is added (via compromised owner), its inflated supply could bypass the liquidity cap checks.

These vulnerabilities stem from trust assumptions, external interactions, and potential misconfigurations in the contract's dependencies and parameters.","### **Output**

---

**[H-04] Withdraw Timelock Can Be Circumvented**

**Report Description**:
The `withdrawWithTimelockFrom` function in the `PrizePool` contract allows users to circumvent the timelock mechanism. By first calling the function with their entire balance and then calling it again with an amount of `0`, users can reset the unlock timestamp to the current block time. This allows them to withdraw their entire deposit immediately, bypassing the intended timelock. This behavior undermines the protocol's fairness, as users can withdraw their funds without contributing to the prize pool, leading to significant issues for the protocol's investment strategy.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of timelock circumvention in the `withdrawWithTimelockFrom` function. While some responses touch on timestamp reliance and rounding errors, none specifically identify the vulnerability described in the issue report.

---

**[M-07] Using `transferFrom` on ERC721 Tokens**

**Report Description**:
In the `awardExternalERC721` function of the `PrizePool` contract, the `transferFrom` keyword is used instead of `safeTransferFrom` when transferring ERC721 tokens to winners. If a winner is a contract and is not aware of incoming ERC721 tokens, the sent tokens could be permanently locked, leading to a loss of assets.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Risk via ERC721 Transfers""**.

**Validation**:
**Partially Correct**. The response identifies the risk associated with ERC721 transfers but focuses on reentrancy rather than the specific issue of using `transferFrom` instead of `safeTransferFrom`. While reentrancy is a valid concern, the core issue here is the potential loss of tokens due to the use of `transferFrom`, which is not adequately addressed in the response.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- **[M-07] Using `transferFrom` on ERC721 Tokens**

**Missed Issues from Issue Report**:
- **[H-04] Withdraw Timelock Can Be Circumvented**

---

### **Analysis**

The response list covers a broad range of vulnerabilities but misses specific issues like the timelock circumvention in the `withdrawWithTimelockFrom` function. Additionally, while it touches on ERC721 transfer risks, it does not fully address the use of `transferFrom` instead of `safeTransferFrom`. This indicates gaps in the response list's coverage and accuracy regarding the issues reported.",0,1,1,12,"Okay, I need to analyze this smart contract and list all the vulnerabilities without suggesting mitigations. Let's start by reading through the code carefully.

First, looking at the imports and the contract structure. The contract is an abstract contract called PrizePool, inheriting from OwnableUpgradeable, ReentrancyGuardUpgradeable, and TokenControllerInterface. It uses several OpenZeppelin upgradeable contracts, which might have their own considerations.

Starting with the state variables. There are mappings like _timelockBalances and _unlockTimestamps. Also, there's a liquidityCap and functions related to deposits, withdrawals, and awards. The contract interacts with external tokens and has a prize strategy.

Looking for common vulnerabilities. Reentrancy is a big one. The contract uses ReentrancyGuardUpgradeable, so it's probably using the nonReentrant modifier. Checking where this modifier is applied. Functions like depositTo, withdrawInstantlyFrom, withdrawWithTimelockFrom, captureAwardBalance, etc., have nonReentrant. But are there any functions that should have it but don't? Let's check.

The sweepTimelockBalances function is external and nonReentrant. The _sweepTimelockBalances internal function handles transfers. That's probably safe.

Next, access control. The contract is Ownable, so functions with onlyOwner modifier are okay. But checking if any critical functions are missing access control. For example, setPrizeStrategy is onlyOwner, which is correct. The initialize function is public and has initializer, which is part of upgradeable contracts. But since it's using the initializer modifier, that's probably okay as it should be called only once.

Another area is ERC20 safe transfers. The contract uses SafeERC20Upgradeable, which is good. But looking for places where transfers might fail and not handled. For example, in awardExternalERC20, _transferOut uses safeTransfer, which should handle failures, but if the external token doesn't return a boolean, this could fail. However, since they're using SafeERC20, which works with both old and new ERC20 tokens, this should be handled.

Now, looking at the timelock functionality. The _mintTimelock function adds to _timelockBalances and sets _unlockTimestamps. When sweeping, it checks if unlockTimestamp is past, then redeems and transfers. But is there a possibility of reentrancy here? Since the function is nonReentrant, probably not.

Another thing: the contract uses _currentTime() which is based on block.timestamp. This could be manipulated by miners, but in most cases, it's acceptable unless strict time constraints are critical. The functions using this are related to unlocking timelocked funds, so minor manipulation might affect when withdrawals can happen, but it's a known trade-off.

Looking at the credit system. The credit balances are stored in _tokenCreditBalances, and functions like _calculateAccruedCredit compute based on time passed. Potential issues here could be related to integer overflow or underflow, but the contract uses SafeMathUpgradeable, so that's handled.

In the withdrawInstantlyFrom function, it calculates exitFee and burns credit. The exit fee is calculated based on the credit plan. If the credit limit or rate is set incorrectly, it could lead to incorrect fee calculations. However, that's a configuration issue rather than a code vulnerability.

Checking for possible division by zero. In _estimateCreditAccrualTime, accruedPerSecond could be zero, leading to division by zero. Wait, the code says: if accruedPerSecond is zero, return 0. So there's a check, which prevents division by zero. That's handled.

Another area is the liquidity cap. The _canAddLiquidity function checks if adding more would exceed the cap. But if the cap is set to uint256(-1), which is the case in initialize with _setLiquidityCap(uint256(-1)), then it's effectively no cap. But that's intentional.

Looking at the award functions. The award function mints tokens, but it checks that the amount is within _currentAwardBalance. However, if the prize strategy is malicious or compromised, it could drain funds. But the award function is only callable by the prizeStrategy, which is set by the owner. So if the owner sets a malicious prize strategy, that's a risk, but that's an admin privilege issue, not a code vulnerability.

In the withdrawReserve function, onlyReserve modifier is used. The reserve is looked up from reserveRegistry. If the reserveRegistry returns a malicious address, the reserve could be drained. But that depends on the registry's implementation, which is external. If the registry is compromised, this contract is affected. But that's an external dependency issue.

Another possible issue: the contract uses _token(), which is an internal view function that's supposed to return the underlying ERC20 token. Since this is an abstract contract, the actual implementation is in a child contract. If the _token() function is not correctly implemented, it could return a wrong token, leading to issues. But as an abstract contract, that's up to the concrete implementation.

Check for front-running possibilities. For example, in functions that modify state before transferring, but the use of nonReentrant should prevent some of that. Also, the functions seem to follow checks-effects-interactions pattern. For instance, in withdrawInstantlyFrom, the burn happens before transferring tokens out.

In the beforeTokenTransfer function, which is a hook from ControlledToken, it calls prizeStrategy.beforeTokenTransfer. If the prizeStrategy is malicious, it could re-enter, but since the function has the onlyControlledToken modifier and the prizeStrategy is set by the owner, it's again an admin trust issue.

Looking at the _supply and _redeem functions. These are internal and meant to be implemented in derived contracts. If they interact with external protocols (like depositing into a lending platform), there could be issues, but that's implementation-specific.

Another thing: the initialize function is public, but uses the initializer modifier. Since this is an upgradeable contract, as long as it's only initialized once, it's okay. But if a derived contract doesn't properly secure the initializer, it could be reinitialized, but that's a different context.

Check for ERC721 safety: in awardExternalERC721, it uses transferFrom, which could be unsafe if the ERC721 contract doesn't check if the recipient can handle the token. However, the contract transfers to the 'to' address specified by the prize strategy. It's up to the external contract to handle that.

Potential issue with the MappedSinglyLinkedList. If the _tokens list is not properly maintained, adding or removing tokens could cause inconsistencies. The _addControlledToken function adds tokens to the list, checking that the token's controller is this contract. That's a good check.

In the timelock functions: when _sweepTimelockBalances is called, it deletes _timelockBalances[user] and transfers the redeemed amount. If the underlying _redeem function doesn't handle the amount correctly, there could be loss of funds. But _redeem is an internal function to be implemented, so again, depends on the child contract.

Another thing: when capturing the award balance (captureAwardBalance), it calculates the total interest as currentBalance - tokenTotalSupply. If currentBalance is less than tokenTotalSupply, totalInterest becomes zero, so no fees are captured. That's correct.

In the credit calculations, using SafeMath to prevent overflows. All math operations use SafeMath functions, so that's covered.

Possible issues with the CreditBalance struct: uses uint192 for balance and uint32 for timestamp. If the balance exceeds uint192, which is a very large number (around 3e57), it's unlikely but possible. However, since tokens usually have 18 decimals, it's still a high limit. The same for the timestamp in uint32, which would overflow in 2106, but the code uses _currentTime() which is a uint256. However, when casting to uint32, it would truncate, but since the timestamp is stored as the current block time, which is a 32-bit value (as of now, block.timestamp is a uint256, but in practice, it's a 32-bit value until 2106). So storing it as uint32 is okay until then, but after that, it would cause incorrect time calculations. However, that's a long time away, so maybe not a concern now.

Another edge case: if a user has a timelock balance and the unlockTimestamp is exactly _currentTime(), it allows the sweep. If the timestamp is in the future by even a second, it doesn't. So the timing is strict, which is correct.

In the _calculateEarlyExitFeeLessBurnedCredit function, the calculation of availableCredit might underflow if remainingExitFee is greater than the user's credit balance. But the code checks if _tokenCreditBalances[controlledToken][from].balance >= remainingExitFee, and if not, availableCredit is 0. So no underflow.

Potential rounding errors in FixedPoint operations. For example, in _sweepTimelockBalances, when calculating shareMantissa, if the division isn't precise, there could be dust left. But the code uses FixedPoint functions which presumably handle this with appropriate rounding.

Also, in _sweepTimelockBalances, after redeeming the totalWithdrawal, the contract transfers out the redeemed amount proportionally to each user's balance. If there's a rounding error, the sum of transferAmount might not equal redeemed. However, the code uses FixedPoint.multiplyUintByMantissa, which multiplies by a fraction, and since all users are processed in a loop, the total should add up correctly. But in Solidity, due to integer division, sometimes there can be leftover amounts. However, the loop processes all users in one transaction, so if the redeemed amount is exactly distributed, it's okay. Otherwise, there could be a small amount left in the contract. But since the contract is redeeming the totalWithdrawal and then distributing it, any leftover due to rounding would stay in the contract, which could be considered a vulnerability (dust amounts accumulating). But the impact is minimal unless the amounts are significant.

Another possible issue: when setting the liquidity cap, if set to a value lower than the current total supply, it would prevent further deposits but existing funds are unaffected. The function setLiquidityCap is onlyOwner, so it's up to the owner to manage.

In the beforeTokenTransfer hook, when transferring tokens, it updates the credit balance. However, if the token transfer is part of a larger transaction that involves multiple state changes, there could be inconsistencies. But the hook is called before the actual transfer, and the code updates the credit balances based on the old balance. That seems correct.

Looking for any functions that allow arbitrary calls or delegate calls. The compLikeDelegate function allows the owner to delegate voting power for COMP-like tokens. It checks if the balance is >0 before delegating. Since it's onlyOwner, it's a privileged function, but if the owner is compromised, they could delegate to a malicious address. However, this is a feature, not a vulnerability in the code itself.

In summary, possible vulnerabilities I can identify:

1. **Dependence on External Registry**: The contract uses reserveRegistry to lookup the reserve address. If the registry is compromised or returns a malicious address, the withdrawReserve function could send funds to an attacker. However, this is an external dependency risk.

2. **Prize Strategy Privileges**: The prizeStrategy can call award functions, transfer external tokens, etc. If the prizeStrategy is malicious (set by a compromised owner), it could drain funds. But this is an admin trust issue.

3. **Timestamp Reliance**: Use of block.timestamp for unlock times, which can be slightly manipulated by miners, but the impact is low.

4. **Rounding Errors in Redemption**: When redeeming timelock balances, possible dust leftovers due to division, but impact is minimal.

5. **Upgradeable Contract Risks**: Since this is part of an upgradeable contract system, if the initialization is not handled properly in child contracts, it could lead to vulnerabilities. But this is more about the deployment setup.

6. **ERC20 Return Values**: Even though SafeERC20 is used, some tokens may not adhere strictly to the standard, leading to issues. But OpenZeppelin's SafeERC20 handles this.

7. **Unbounded Loops**: In functions like awardExternalERC721, looping over tokenIds array. If the array is too large, it could exceed gas limits, leading to failed transactions. This is a potential DoS risk.

Wait, in the awardExternalERC721 function, there's a loop over tokenIds. If someone passes a very large array, this could consume too much gas and revert. This could be a vulnerability if the prize strategy is allowed to award a large number of tokens in a single call, causing the transaction to fail. However, the function is only callable by the prizeStrategy, which is controlled by the owner. So it's up to the owner to ensure that calls are made with reasonable array sizes. But this is a potential denial-of-service if not handled.

Another point: the contract's _tokenTotalSupply sums all controlled tokens' total supplies plus timelock and reserve. If a controlled token's total supply is inflated maliciously, it could affect the liquidity cap. However, since controlled tokens are added by the owner, and each must have this contract as their controller, it's under the owner's control. If a malicious token is added, it could bypass the liquidity cap. The _addControlledToken function checks that the token's controller is this contract, so only tokens that are properly configured can be added. Therefore, this is a trust in the ControlledToken's implementation.

Other possible issues:

- **Reentrancy in ERC721 Transfers**: When awarding ERC721 tokens, the transferFrom could call back into the contract. However, since the contract doesn't implement onERC721Received, and the transfers are outgoing, the risk is low. But if the external ERC721 contract calls back into the PrizePool during transfer, it could interact with other functions. However, the PrizePool functions are protected by nonReentrant where necessary. Still, any function not protected could be vulnerable. For example, the awardExternalERC721 function doesn't have a nonReentrant modifier, but it's only callable by the prizeStrategy. If during the ERC721 transfer, a reentrant call is made to a function without nonReentrant, it could be exploited. So need to check which functions are callable during reentrancy.

The awardExternalERC721 function is external and onlyPrizeStrategy. If during the transferFrom, the ERC721 contract calls back into the PrizePool, and if the PrizePool has a function that can be called in this state, it could be an issue. For example, if during the transfer, the callback calls withdrawInstantlyFrom, which is nonReentrant, it would be blocked. But functions without nonReentrant could be called. So potential reentrancy here. However, since the prizeStrategy is supposed to be a trusted contract, this might be considered a low risk. But it's a possible attack vector if the ERC721 is malicious.

Another thing: the contract uses msg.sender in onlyControlledToken modifier. The modifier checks if the token is in the _tokens list. So functions with this modifier can only be called by the controlled tokens themselves. For example, the beforeTokenTransfer function is only callable by a controlled token. So when a controlled token is transferred, it calls this function. That's correct.

In the depositTo function, it calls _token().safeTransferFrom(operator, address(this), amount). The _token() is the underlying asset. If the underlying token is malicious (e.g., a fake deposit that doesn't actually transfer tokens), the PrizePool could be tricked into minting controlled tokens without receiving the underlying. However, since the _token() is set in the child contract, it's up to the implementation to ensure it's a legitimate token. But if the child contract uses a malicious token, that's a vulnerability there, not in this contract.

Overall, the main vulnerabilities I can spot are:

- **External Calls to Untrusted Contracts**: The contract interacts with external tokens (ERC20, ERC721) and the reserve registry. Malicious tokens or a compromised registry could lead to fund loss.

- **Unbounded Loops in awardExternalERC721**: Leading to potential DoS due to gas limits.

- **Dependence on block.timestamp**: Though the impact is low.

- **Admin Privileges**: If owner or prizeStrategy is compromised, leading to fund theft.

- **Potential Reentrancy in ERC721 Transfers**: If the external NFT contract reenters the PrizePool during transfer.

- **Rounding Issues in Redemption Distributions**: Possible dust amounts remaining in the contract.

However, since the question asks for vulnerabilities without mitigation, these are the points to list.","```
None.
```",0.0
,,,,,,,,5,5,,,2,1,7,32,,,
