nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
UToken.sol,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/IUErc20.sol"";
import ""../interfaces/IInterestRateModel.sol"";

/**
 *  @title UToken Contract
 *  @dev Union accountBorrows can borrow and repay thru this component.
 */
contract UToken is Controller, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IUErc20;

    bool public constant IS_UTOKEN = true;
    uint256 public constant WAD = 1e18;
    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; //Maximum borrow rate that can ever be applied (.0005% / block)
    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; //Maximum fraction of interest that can be set aside for reserves

    address public underlying;
    IInterestRateModel public interestRateModel;
    uint256 internal initialExchangeRateMantissa; //Initial exchange rate used when minting the first UTokens (used when totalSupply = 0)
    uint256 public reserveFactorMantissa; //Fraction of interest currently set aside for reserves
    uint256 public accrualBlockNumber; //Block number that interest was last accrued at
    uint256 public borrowIndex; //Accumulator of the total earned interest rate since the opening of the market
    uint256 public totalBorrows; //Total amount of outstanding borrows of the underlying in this market
    uint256 public totalReserves; //Total amount of reserves of the underlying held in this marke
    uint256 public totalRedeemable; //Calculates the exchange rate from the underlying to the uToken
    uint256 public overdueBlocks; //overdue duration, based on the number of blocks
    uint256 public originationFee;
    uint256 public debtCeiling; //The debt limit for the whole system
    uint256 public maxBorrow;
    uint256 public minBorrow;
    address public assetManager;
    address public userManager;
    IUErc20 public uErc20;

    struct BorrowSnapshot {
        uint256 principal;
        uint256 interest;
        uint256 interestIndex;
        uint256 lastRepay; //Calculate if it is overdue
    }

    /**
     * @notice Mapping of account addresses to outstanding borrow balances
     */
    mapping(address => BorrowSnapshot) internal accountBorrows;

    /**
     *  @dev Change of the interest rate model
     *  @param oldInterestRateModel Old interest rate model address
     *  @param newInterestRateModel New interest rate model address
     */
    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);

    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);

    event LogRedeem(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, uint256 redeemAmount);

    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);

    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);

    /**
     *  @dev Event borrow
     *  @param account Member address
     *  @param amount Borrow amount
     *  @param fee Origination fee
     */
    event LogBorrow(address indexed account, uint256 amount, uint256 fee);

    /**
     *  @dev Event repay
     *  @param account Member address
     *  @param amount Repay amount
     */
    event LogRepay(address indexed account, uint256 amount);

    /**
     *  @dev modifier limit member
     */
    modifier onlyMember(address account) {
        require(IUserManager(userManager).checkIsMember(account), ""UToken: caller is not a member"");
        _;
    }

    modifier onlyAssetManager() {
        require(msg.sender == assetManager, ""UToken: caller is not assetManager"");
        _;
    }

    modifier onlyUserManager() {
        require(msg.sender == userManager, ""UToken: caller is not userManager"");
        _;
    }

    function __UToken_init(
        IUErc20 uErc20_,
        address underlying_,
        uint256 initialExchangeRateMantissa_,
        uint256 reserveFactorMantissa_,
        uint256 originationFee_,
        uint256 debtCeiling_,
        uint256 maxBorrow_,
        uint256 minBorrow_,
        uint256 overdueBlocks_,
        address admin_
    ) public initializer {
        require(initialExchangeRateMantissa_ > 0, ""initial exchange rate must be greater than zero."");
        require(address(underlying_) != address(0), ""underlying token is zero"");
        require(
            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,
            ""reserveFactorMantissa error""
        );
        uErc20 = uErc20_;
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        underlying = underlying_;
        originationFee = originationFee_;
        debtCeiling = debtCeiling_;
        maxBorrow = maxBorrow_;
        minBorrow = minBorrow_;
        overdueBlocks = overdueBlocks_;
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        reserveFactorMantissa = reserveFactorMantissa_;
        accrualBlockNumber = getBlockNumber();
        borrowIndex = WAD;
    }

    function setAssetManager(address assetManager_) external onlyAdmin {
        assetManager = assetManager_;
    }

    function setUserManager(address userManager_) external onlyAdmin {
        userManager = userManager_;
    }

    /**
     *  @dev Change loan origination fee value
     *  Accept claims only from the admin
     *  @param originationFee_ Fees deducted for each loan transaction
     */
    function setOriginationFee(uint256 originationFee_) external onlyAdmin {
        originationFee = originationFee_;
    }

    /**
     *  @dev Update the market debt ceiling to a fixed amount, for example, 1 billion DAI etc.
     *  Accept claims only from the admin
     *  @param debtCeiling_ The debt limit for the whole system
     */
    function setDebtCeiling(uint256 debtCeiling_) external onlyAdmin {
        debtCeiling = debtCeiling_;
    }

    /**
     *  @dev Update the minimum loan size
     *  Accept claims only from the admin
     *  @param minBorrow_ Minimum loan amount per user
     */
    function setMinBorrow(uint256 minBorrow_) external onlyAdmin {
        minBorrow = minBorrow_;
    }

    /**
     *  @dev Update the max loan size
     *  Accept claims only from the admin
     *  @param maxBorrow_ Max loan amount per user
     */
    function setMaxBorrow(uint256 maxBorrow_) external onlyAdmin {
        maxBorrow = maxBorrow_;
    }

    /**
     *  @dev Change loan overdue duration, based on the number of blocks
     *  Accept claims only from the admin
     *  @param overdueBlocks_ Maximum late repayment block. The number of arrivals is a default
     */
    function setOverdueBlocks(uint256 overdueBlocks_) external onlyAdmin {
        overdueBlocks = overdueBlocks_;
    }

    /**
     *  @dev Change to a different interest rate model
     *  Accept claims only from the admin
     *  @param newInterestRateModel New interest rate model address
     */
    function setInterestRateModel(address newInterestRateModel) external onlyAdmin {
        _setInterestRateModelFresh(newInterestRateModel);
    }

    function setReserveFactor(uint256 reserveFactorMantissa_) external onlyAdmin {
        require(
            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,
            ""reserveFactorMantissa error""
        );
        reserveFactorMantissa = reserveFactorMantissa_;
    }

    /**
     *  @dev Returns the remaining amount that can be borrowed from the market.
     *  @return Remaining total amount
     */
    function getRemainingLoanSize() public view returns (uint256) {
        if (debtCeiling >= totalBorrows) {
            return debtCeiling - totalBorrows;
        } else {
            return 0;
        }
    }

    /**
     *  @dev Get the last repay block
     *  @param account Member address
     *  @return lastRepay
     */
    function getLastRepay(address account) public view returns (uint256 lastRepay) {
        lastRepay = accountBorrows[account].lastRepay;
    }

    /**
     *  @dev Get member interest index
     *  @param account Member address
     *  @return interestIndex
     */
    function getInterestIndex(address account) public view returns (uint256 interestIndex) {
        interestIndex = accountBorrows[account].interestIndex;
    }

    /**
     *  @dev Check if the member's loan is overdue
     *  @param account Member address
     *  @return isOverdue
     */
    function checkIsOverdue(address account) public view returns (bool isOverdue) {
        if (getBorrowed(account) == 0) {
            isOverdue = false;
        } else {
            uint256 lastRepay = getLastRepay(account);
            uint256 diff = getBlockNumber() - lastRepay;
            isOverdue = (overdueBlocks < diff);
        }
    }

    /**
     *  @dev Get the origination fee
     *  @param amount Amount to be calculated
     *  @return Handling fee
     */
    function calculatingFee(uint256 amount) public view returns (uint256) {
        return (originationFee * amount) / WAD;
    }

    /**
     *  @dev Get member loan data
     *  @param member Member address
     *  @return principal totalBorrowed asset apr limit isOverdue lastRepay
     */
    function getLoan(address member)
        public
        view
        returns (
            uint256 principal,
            uint256 totalBorrowed,
            address asset,
            uint256 apr,
            int256 limit,
            bool isOverdue,
            uint256 lastRepay
        )
    {
        principal = accountBorrows[msg.sender].principal;
        totalBorrowed = borrowBalanceStoredInternal(member);
        asset = underlying;
        apr = borrowRatePerBlock();
        lastRepay = getLastRepay(member);
        limit = _getCreditLimit(member);
        isOverdue = checkIsOverdue(member);
    }

    /**
     *  @dev Get the borrowed principle
     *  @param account Member address
     *  @return borrowed
     */
    function getBorrowed(address account) public view returns (uint256 borrowed) {
        borrowed = accountBorrows[account].principal;
    }

    /**
     *  @dev Get a member's current owed balance, including the principle and interest but without updating the user's states.
     *  @param account Member address
     *  @return Borrowed amount
     */
    function borrowBalanceView(address account) public view returns (uint256) {
        return accountBorrows[account].principal + calculatingInterest(account);
    }

    /**
     *  @dev Get a member's total owed, including the principle and the interest calculated based on the interest index.
     *  @param account Member address
     *  @return Borrowed amount
     */
    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {
        BorrowSnapshot memory loan = accountBorrows[account];

        /* If borrowBalance = 0 then borrowIndex is likely also 0.
         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.
         */
        if (loan.principal == 0) {
            return 0;
        }

        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;
        return principalTimesIndex / loan.interestIndex;
    }

    /**
     *  @dev Get the borrowing interest rate per block
     *  @return Borrow rate
     */
    function borrowRatePerBlock() public view returns (uint256) {
        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();
        require(borrowRateMantissa <= BORROW_RATE_MAX_MANTISSA, ""borrow rate is absurdly high"");
        return borrowRateMantissa;
    }

    /**
     * @notice Returns the current per-block supply interest rate for this UToken
     * @return The supply interest rate per block, scaled by 1e18
     */
    function supplyRatePerBlock() public view returns (uint256) {
        return interestRateModel.getSupplyRate(reserveFactorMantissa);
    }

    /**
     * @notice Accrue interest then return the up-to-date exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateCurrent() public nonReentrant returns (uint256) {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        return exchangeRateStored();
    }

    /**
     * @notice Calculates the exchange rate from the underlying to the UToken
     * @dev This function does not accrue interest before calculating the exchange rate
     * @return Calculated exchange rate scaled by 1e18
     */
    function exchangeRateStored() public view returns (uint256) {
        uint256 totalSupply_ = uErc20.totalSupply();
        if (totalSupply_ == 0) {
            return initialExchangeRateMantissa;
        } else {
            return (totalRedeemable * WAD) / totalSupply_;
        }
    }

    /**
     *  @dev Calculating member's borrowed interest
     *  @param account Member address
     *  @return Interest amount
     */
    function calculatingInterest(address account) public view returns (uint256) {
        BorrowSnapshot memory loan = accountBorrows[account];

        if (loan.principal == 0) {
            return 0;
        }

        uint256 borrowRate = borrowRatePerBlock();
        uint256 currentBlockNumber = getBlockNumber();
        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;
        uint256 simpleInterestFactor = borrowRate * blockDelta;
        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;

        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;
        uint256 balance = principalTimesIndex / loan.interestIndex;

        return balance - accountBorrows[account].principal;
    }

    /**
     *  @dev Borrowing from the market
     *  Accept claims only from the member
     *  Borrow amount must in the range of creditLimit, minBorrow, maxBorrow, debtCeiling and not overdue
     *  @param amount Borrow amount
     */
    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {
        IAssetManager assetManagerContract = IAssetManager(assetManager);
        require(amount >= minBorrow, ""UToken: amount less than loan size min"");

        require(amount <= getRemainingLoanSize(), ""UToken: amount more than loan global size max"");

        uint256 fee = calculatingFee(amount);
        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, ""UToken: amount large than borrow size max"");

        require(!checkIsOverdue(msg.sender), ""UToken: Member has loans overdue"");

        require(amount <= assetManagerContract.getLoanableAmount(underlying), ""UToken: Not enough to lend out"");
        require(
            uint256(_getCreditLimit(msg.sender)) >= amount + fee,
            ""UToken: The loan amount plus fee is greater than credit limit""
        );

        require(accrueInterest(), ""UToken: accrue interest failed"");

        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);

        //Set lastRepay init data
        if (accountBorrows[msg.sender].lastRepay == 0) {
            accountBorrows[msg.sender].lastRepay = getBlockNumber();
        }

        uint256 accountBorrowsNew = borrowedAmount + amount + fee;
        uint256 totalBorrowsNew = totalBorrows + amount + fee;
        uint256 oldPrincipal = accountBorrows[msg.sender].principal;

        accountBorrows[msg.sender].principal += amount + fee;
        uint256 newPrincipal = accountBorrows[msg.sender].principal;
        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);
        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;
        accountBorrows[msg.sender].interestIndex = borrowIndex;
        totalBorrows = totalBorrowsNew;
        // The origination fees contribute to the reserve
        totalReserves += fee;

        require(assetManagerContract.withdraw(underlying, msg.sender, amount), ""UToken: Failed to withdraw"");

        emit LogBorrow(msg.sender, amount, fee);
    }

    function repayBorrow(uint256 repayAmount) external whenNotPaused nonReentrant {
        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    function repayBorrowBehalf(address borrower, uint256 repayAmount) external whenNotPaused nonReentrant {
        _repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    /**
     *  @dev Repay the loan
     *  Accept claims only from the member
     *  Updated member lastPaymentEpoch only when the repayment amount is greater than interest
     *  @param payer Payer address
     *  @param borrower Borrower address
     *  @param amount Repay amount
     */
    function _repayBorrowFresh(
        address payer,
        address borrower,
        uint256 amount
    ) private {
        IUErc20 assetToken = IUErc20(underlying);
        //In order to prevent the state from being changed, put the value at the top
        bool isOverdue = checkIsOverdue(borrower);
        uint256 oldPrincipal = accountBorrows[borrower].principal;
        require(accrueInterest(), ""UToken: accrue interest failed"");
        require(accrualBlockNumber == getBlockNumber(), ""UToken: market not fresh"");

        uint256 interest = calculatingInterest(borrower);
        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);

        uint256 repayAmount;
        if (amount > borrowedAmount) {
            repayAmount = borrowedAmount;
        } else {
            repayAmount = amount;
        }

        require(repayAmount > 0, ""UToken: repay amount or owed amount is zero"");

        require(assetToken.allowance(payer, address(this)) >= repayAmount, ""UToken: Not enough allowance to repay"");

        uint256 toReserveAmount;
        uint256 toRedeemableAmount;
        if (repayAmount >= interest) {
            toReserveAmount = (interest * reserveFactorMantissa) / WAD;
            toRedeemableAmount = interest - toReserveAmount;

            if (isOverdue) {
                IUserManager(userManager).updateTotalFrozen(borrower, false);
                IUserManager(userManager).repayLoanOverdue(borrower, underlying, accountBorrows[borrower].lastRepay);
            }
            accountBorrows[borrower].principal = borrowedAmount - repayAmount;
            accountBorrows[borrower].interest = 0;

            if (accountBorrows[borrower].principal == 0) {
                //LastRepay is cleared when the arrears are paid off, and reinitialized the next time the loan is borrowed
                accountBorrows[borrower].lastRepay = 0;
            } else {
                accountBorrows[borrower].lastRepay = getBlockNumber();
            }
        } else {
            toReserveAmount = (repayAmount * reserveFactorMantissa) / WAD;
            toRedeemableAmount = repayAmount - toReserveAmount;
            accountBorrows[borrower].interest = interest - repayAmount;
        }

        totalReserves += toReserveAmount;
        totalRedeemable += toRedeemableAmount;

        uint256 newPrincipal = accountBorrows[borrower].principal;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows -= repayAmount;

        IUserManager(userManager).updateLockedData(borrower, oldPrincipal - newPrincipal, false);

        assetToken.safeTransferFrom(payer, address(this), repayAmount);

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, repayAmount);

        require(IAssetManager(assetManager).deposit(underlying, repayAmount), ""UToken: Deposit failed"");

        emit LogRepay(borrower, repayAmount);
    }

    function repayBorrowWithPermit(
        address borrower,
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUErc20 erc20Token = IUErc20(underlying);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        _repayBorrowFresh(msg.sender, borrower, amount);
    }

    /**
     *  @dev Accrue interest
     *  @return Accrue interest finished
     */
    function accrueInterest() public returns (bool) {
        uint256 borrowRate = borrowRatePerBlock();
        uint256 currentBlockNumber = getBlockNumber();
        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;

        uint256 simpleInterestFactor = borrowRate * blockDelta;
        uint256 interestAccumulated = (simpleInterestFactor * totalBorrows) / WAD;
        uint256 totalBorrowsNew = interestAccumulated + totalBorrows;
        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;

        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;

        return true;
    }

    /**
     * @notice Get the underlying balance of the `owner`
     * @dev This also accrues interest in a transaction
     * @param owner The address of the account to query
     * @return The amount of underlying owned by `owner`
     */
    function balanceOfUnderlying(address owner) external returns (uint256) {
        return exchangeRateCurrent() * uErc20.balanceOf(owner);
    }

    function mint(uint256 mintAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        uint256 exchangeRate = exchangeRateStored();
        IUErc20 assetToken = IUErc20(underlying);
        uint256 balanceBefore = assetToken.balanceOf(address(this));
        require(assetToken.allowance(msg.sender, address(this)) >= mintAmount, ""UToken: Not enough allowance"");
        assetToken.safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 balanceAfter = assetToken.balanceOf(address(this));
        uint256 actualMintAmount = balanceAfter - balanceBefore;
        totalRedeemable += actualMintAmount;
        uint256 mintTokens = (actualMintAmount * WAD) / exchangeRate;
        uErc20.mint(msg.sender, mintTokens);

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, actualMintAmount);

        require(IAssetManager(assetManager).deposit(underlying, actualMintAmount), ""UToken: Deposit failed"");

        emit LogMint(msg.sender, actualMintAmount, mintTokens);
    }

    /**
     * @notice Sender redeems uTokens in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of uTokens to redeem into underlying
     */
    function redeem(uint256 redeemTokens) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        _redeemFresh(payable(msg.sender), redeemTokens, 0);
    }

    /**
     * @notice Sender redeems uTokens in exchange for a specified amount of underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemAmount The amount of underlying to receive from redeeming uTokens
     */
    function redeemUnderlying(uint256 redeemAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        _redeemFresh(payable(msg.sender), 0, redeemAmount);
    }

    /**
     * @notice User redeems uTokens in exchange for the underlying asset
     * @dev Assumes interest has already been accrued up to the current block
     * @param redeemer The address of the account which is redeeming the tokens
     * @param redeemTokensIn The number of uTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     * @param redeemAmountIn The number of underlying tokens to receive from redeeming uTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)
     */
    function _redeemFresh(
        address payable redeemer,
        uint256 redeemTokensIn,
        uint256 redeemAmountIn
    ) internal {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one of redeemTokensIn or redeemAmountIn must be zero"");

        IAssetManager assetManagerContract = IAssetManager(assetManager);

        uint256 exchangeRate = exchangeRateStored();

        uint256 redeemTokens;
        uint256 redeemAmount;

        if (redeemTokensIn > 0) {
            /*
             * We calculate the exchange rate and the amount of underlying to be redeemed:
             *  redeemTokens = redeemTokensIn
             *  redeemAmount = redeemTokensIn x exchangeRateCurrent
             */
            redeemTokens = redeemTokensIn;
            redeemAmount = (redeemTokensIn * exchangeRate) / WAD;
        } else {
            /*
             * We get the current exchange rate and calculate the amount to be redeemed:
             *  redeemTokens = redeemAmountIn / exchangeRate
             *  redeemAmount = redeemAmountIn
             */
            redeemTokens = (redeemAmountIn * WAD) / exchangeRate;
            redeemAmount = redeemAmountIn;
        }

        require(totalRedeemable >= redeemAmount, ""redeem amount error"");
        totalRedeemable -= redeemAmount;
        uErc20.burn(redeemer, redeemTokens);

        require(assetManagerContract.withdraw(underlying, redeemer, redeemAmount), ""UToken: Failed to withdraw"");

        emit LogRedeem(redeemer, redeemTokensIn, redeemAmountIn, redeemAmount);
    }

    function addReserves(uint256 addAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        IUErc20 assetToken = IUErc20(underlying);
        uint256 balanceBefore = assetToken.balanceOf(address(this));
        require(assetToken.allowance(msg.sender, address(this)) >= addAmount, ""UToken: Not enough allowance"");
        assetToken.safeTransferFrom(msg.sender, address(this), addAmount);
        uint256 balanceAfter = assetToken.balanceOf(address(this));
        uint256 actualAddAmount = balanceAfter - balanceBefore;

        uint256 totalReservesNew = totalReserves + actualAddAmount;
        /* Revert on overflow */
        require(totalReservesNew >= totalReserves, ""add reserves unexpected overflow"");
        totalReserves = totalReservesNew;

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, balanceAfter);

        require(IAssetManager(assetManager).deposit(underlying, balanceAfter), ""UToken: Deposit failed"");

        emit LogReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function removeReserves(address receiver, uint256 reduceAmount) external whenNotPaused nonReentrant onlyAdmin {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        require(reduceAmount <= totalReserves, ""amount is large than totalReserves"");

        IAssetManager assetManagerContract = IAssetManager(assetManager);

        uint256 totalReservesNew = totalReserves - reduceAmount;
        // We checked reduceAmount <= totalReserves above, so this should never revert.
        require(totalReservesNew <= totalReserves, ""reduce reserves unexpected underflow"");

        totalReserves = totalReservesNew;

        require(assetManagerContract.withdraw(underlying, receiver, reduceAmount), ""UToken: Failed to withdraw"");

        emit LogReservesReduced(receiver, reduceAmount, totalReservesNew);
    }

    function debtWriteOff(address borrower, uint256 amount) external whenNotPaused onlyUserManager {
        uint256 oldPrincipal = accountBorrows[borrower].principal;
        uint256 repayAmount;
        if (amount > oldPrincipal) {
            repayAmount = oldPrincipal;
        } else {
            repayAmount = amount;
        }

        accountBorrows[borrower].principal = oldPrincipal - repayAmount;
        totalBorrows -= repayAmount;
    }

    /**
     * @dev Function to simply retrieve block number
     *  This exists mainly for inheriting test contracts to stub this result.
     */
    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function _setInterestRateModelFresh(address newInterestRateModel_) private {
        address oldInterestRateModel = address(interestRateModel);
        address newInterestRateModel = newInterestRateModel_;
        require(
            IInterestRateModel(newInterestRateModel).isInterestRateModel(),
            ""UToken: new model is not a interestRateModel""
        );
        interestRateModel = IInterestRateModel(newInterestRateModel);

        emit LogNewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);
    }

    /**
     *  @dev Update borrower overdue info
     *  @param account Borrower address
     */
    function updateOverdueInfo(address account) external whenNotPaused {
        if (checkIsOverdue(account)) {
            IUserManager(userManager).updateTotalFrozen(account, true);
        }
    }

    /**
     *  @dev Batch update borrower overdue info
     *  @param accounts Borrowers address
     */
    function batchUpdateOverdueInfos(address[] calldata accounts) external whenNotPaused {
        address[] memory overdueAccounts = new address[](accounts.length);
        bool[] memory isOverdues = new bool[](accounts.length);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (checkIsOverdue(accounts[i])) {
                overdueAccounts[i] = accounts[i];
                isOverdues[i] = true;
            }
        }
        IUserManager(userManager).batchUpdateTotalFrozen(overdueAccounts, isOverdues);
    }

    /**
     *  @dev Get a member's available credit limit
     *  @param account Member address
     *  @return Member credit limit
     */
    function _getCreditLimit(address account) private view returns (int256) {
        return IUserManager(userManager).getCreditLimit(account);
    }
}",6882.0,769.0,"[H-01] borrow must accrueInterest first
The `UToken.borrow` function first checks the borrowed balance and the old credit limit before accruing the actual interest on the market:
// @audit this uses the old value
require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, ""UToken: amount large than borrow size max"");

require(
    // @audit this calls uToken.calculateInterest(account) which returns old value
    uint256(_getCreditLimit(msg.sender)) >= amount + fee,
    ""UToken: The loan amount plus fee is greater than credit limit""
);

// @audit accrual only happens here
require(accrueInterest(), ""UToken: accrue interest failed"");

Thus the borrowed balance of the user does not include the latest interest as it uses the old global borrowIndex but the new borrowIndex is only set in accrueInterest.",1.0,"pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";

import ""../Controller.sol"";
import ""../interfaces/IUserManager.sol"";
import ""../interfaces/IAssetManager.sol"";
import ""../interfaces/IUErc20.sol"";
import ""../interfaces/IInterestRateModel.sol"";


contract UToken is Controller, ReentrancyGuardUpgradeable {
    using SafeERC20Upgradeable for IUErc20;

    bool public constant IS_UTOKEN = true;
    uint256 public constant WAD = 1e18;
    uint256 internal constant BORROW_RATE_MAX_MANTISSA = 0.0005e16; 
    uint256 internal constant RESERVE_FACTORY_MAX_MANTISSA = 1e18; 

    address public underlying;
    IInterestRateModel public interestRateModel;
    uint256 internal initialExchangeRateMantissa; 
    uint256 public reserveFactorMantissa; 
    uint256 public accrualBlockNumber; 
    uint256 public borrowIndex; 
    uint256 public totalBorrows; 
    uint256 public totalReserves; 
    uint256 public totalRedeemable; 
    uint256 public overdueBlocks; 
    uint256 public originationFee;
    uint256 public debtCeiling; 
    uint256 public maxBorrow;
    uint256 public minBorrow;
    address public assetManager;
    address public userManager;
    IUErc20 public uErc20;

    struct BorrowSnapshot {
        uint256 principal;
        uint256 interest;
        uint256 interestIndex;
        uint256 lastRepay; 
    }

    
    mapping(address => BorrowSnapshot) internal accountBorrows;

    
    event LogNewMarketInterestRateModel(address oldInterestRateModel, address newInterestRateModel);

    event LogMint(address minter, uint256 underlyingAmount, uint256 uTokenAmount);

    event LogRedeem(address redeemer, uint256 redeemTokensIn, uint256 redeemAmountIn, uint256 redeemAmount);

    event LogReservesAdded(address reserver, uint256 actualAddAmount, uint256 totalReservesNew);

    event LogReservesReduced(address receiver, uint256 reduceAmount, uint256 totalReservesNew);

    
    event LogBorrow(address indexed account, uint256 amount, uint256 fee);

    
    event LogRepay(address indexed account, uint256 amount);

    
    modifier onlyMember(address account) {
        require(IUserManager(userManager).checkIsMember(account), ""UToken: caller is not a member"");
        _;
    }

    modifier onlyAssetManager() {
        require(msg.sender == assetManager, ""UToken: caller is not assetManager"");
        _;
    }

    modifier onlyUserManager() {
        require(msg.sender == userManager, ""UToken: caller is not userManager"");
        _;
    }

    function __UToken_init(
        IUErc20 uErc20_,
        address underlying_,
        uint256 initialExchangeRateMantissa_,
        uint256 reserveFactorMantissa_,
        uint256 originationFee_,
        uint256 debtCeiling_,
        uint256 maxBorrow_,
        uint256 minBorrow_,
        uint256 overdueBlocks_,
        address admin_
    ) public initializer {
        require(initialExchangeRateMantissa_ > 0, ""initial exchange rate must be greater than zero."");
        require(address(underlying_) != address(0), ""underlying token is zero"");
        require(
            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,
            ""reserveFactorMantissa error""
        );
        uErc20 = uErc20_;
        Controller.__Controller_init(admin_);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        underlying = underlying_;
        originationFee = originationFee_;
        debtCeiling = debtCeiling_;
        maxBorrow = maxBorrow_;
        minBorrow = minBorrow_;
        overdueBlocks = overdueBlocks_;
        initialExchangeRateMantissa = initialExchangeRateMantissa_;
        reserveFactorMantissa = reserveFactorMantissa_;
        accrualBlockNumber = getBlockNumber();
        borrowIndex = WAD;
    }

    function setAssetManager(address assetManager_) external onlyAdmin {
        assetManager = assetManager_;
    }

    function setUserManager(address userManager_) external onlyAdmin {
        userManager = userManager_;
    }

    
    function setOriginationFee(uint256 originationFee_) external onlyAdmin {
        originationFee = originationFee_;
    }

    
    function setDebtCeiling(uint256 debtCeiling_) external onlyAdmin {
        debtCeiling = debtCeiling_;
    }

    
    function setMinBorrow(uint256 minBorrow_) external onlyAdmin {
        minBorrow = minBorrow_;
    }

    
    function setMaxBorrow(uint256 maxBorrow_) external onlyAdmin {
        maxBorrow = maxBorrow_;
    }

    
    function setOverdueBlocks(uint256 overdueBlocks_) external onlyAdmin {
        overdueBlocks = overdueBlocks_;
    }

    
    function setInterestRateModel(address newInterestRateModel) external onlyAdmin {
        _setInterestRateModelFresh(newInterestRateModel);
    }

    function setReserveFactor(uint256 reserveFactorMantissa_) external onlyAdmin {
        require(
            reserveFactorMantissa_ >= 0 && reserveFactorMantissa_ <= RESERVE_FACTORY_MAX_MANTISSA,
            ""reserveFactorMantissa error""
        );
        reserveFactorMantissa = reserveFactorMantissa_;
    }

    
    function getRemainingLoanSize() public view returns (uint256) {
        if (debtCeiling >= totalBorrows) {
            return debtCeiling - totalBorrows;
        } else {
            return 0;
        }
    }

    
    function getLastRepay(address account) public view returns (uint256 lastRepay) {
        lastRepay = accountBorrows[account].lastRepay;
    }

    
    function getInterestIndex(address account) public view returns (uint256 interestIndex) {
        interestIndex = accountBorrows[account].interestIndex;
    }

    
    function checkIsOverdue(address account) public view returns (bool isOverdue) {
        if (getBorrowed(account) == 0) {
            isOverdue = false;
        } else {
            uint256 lastRepay = getLastRepay(account);
            uint256 diff = getBlockNumber() - lastRepay;
            isOverdue = (overdueBlocks < diff);
        }
    }

    
    function calculatingFee(uint256 amount) public view returns (uint256) {
        return (originationFee * amount) / WAD;
    }

    
    function getLoan(address member)
        public
        view
        returns (
            uint256 principal,
            uint256 totalBorrowed,
            address asset,
            uint256 apr,
            int256 limit,
            bool isOverdue,
            uint256 lastRepay
        )
    {
        principal = accountBorrows[msg.sender].principal;
        totalBorrowed = borrowBalanceStoredInternal(member);
        asset = underlying;
        apr = borrowRatePerBlock();
        lastRepay = getLastRepay(member);
        limit = _getCreditLimit(member);
        isOverdue = checkIsOverdue(member);
    }

    
    function getBorrowed(address account) public view returns (uint256 borrowed) {
        borrowed = accountBorrows[account].principal;
    }

    
    function borrowBalanceView(address account) public view returns (uint256) {
        return accountBorrows[account].principal + calculatingInterest(account);
    }

    
    function borrowBalanceStoredInternal(address account) internal view returns (uint256) {
        BorrowSnapshot memory loan = accountBorrows[account];

        
        if (loan.principal == 0) {
            return 0;
        }

        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndex;
        return principalTimesIndex / loan.interestIndex;
    }

    
    function borrowRatePerBlock() public view returns (uint256) {
        uint256 borrowRateMantissa = interestRateModel.getBorrowRate();
        require(borrowRateMantissa <= BORROW_RATE_MAX_MANTISSA, ""borrow rate is absurdly high"");
        return borrowRateMantissa;
    }

    
    function supplyRatePerBlock() public view returns (uint256) {
        return interestRateModel.getSupplyRate(reserveFactorMantissa);
    }

    
    function exchangeRateCurrent() public nonReentrant returns (uint256) {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        return exchangeRateStored();
    }

    
    function exchangeRateStored() public view returns (uint256) {
        uint256 totalSupply_ = uErc20.totalSupply();
        if (totalSupply_ == 0) {
            return initialExchangeRateMantissa;
        } else {
            return (totalRedeemable * WAD) / totalSupply_;
        }
    }

    
    function calculatingInterest(address account) public view returns (uint256) {
        BorrowSnapshot memory loan = accountBorrows[account];

        if (loan.principal == 0) {
            return 0;
        }

        uint256 borrowRate = borrowRatePerBlock();
        uint256 currentBlockNumber = getBlockNumber();
        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;
        uint256 simpleInterestFactor = borrowRate * blockDelta;
        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;

        uint256 principalTimesIndex = (loan.principal + loan.interest) * borrowIndexNew;
        uint256 balance = principalTimesIndex / loan.interestIndex;

        return balance - accountBorrows[account].principal;
    }

    
    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {
        IAssetManager assetManagerContract = IAssetManager(assetManager);
        require(amount >= minBorrow, ""UToken: amount less than loan size min"");

        require(amount <= getRemainingLoanSize(), ""UToken: amount more than loan global size max"");

        uint256 fee = calculatingFee(amount);
        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, ""UToken: amount large than borrow size max"");

        require(!checkIsOverdue(msg.sender), ""UToken: Member has loans overdue"");

        require(amount <= assetManagerContract.getLoanableAmount(underlying), ""UToken: Not enough to lend out"");
        require(
            uint256(_getCreditLimit(msg.sender)) >= amount + fee,
            ""UToken: The loan amount plus fee is greater than credit limit""
        );

        require(accrueInterest(), ""UToken: accrue interest failed"");

        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);

        
        if (accountBorrows[msg.sender].lastRepay == 0) {
            accountBorrows[msg.sender].lastRepay = getBlockNumber();
        }

        uint256 accountBorrowsNew = borrowedAmount + amount + fee;
        uint256 totalBorrowsNew = totalBorrows + amount + fee;
        uint256 oldPrincipal = accountBorrows[msg.sender].principal;

        accountBorrows[msg.sender].principal += amount + fee;
        uint256 newPrincipal = accountBorrows[msg.sender].principal;
        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);
        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;
        accountBorrows[msg.sender].interestIndex = borrowIndex;
        totalBorrows = totalBorrowsNew;
        
        totalReserves += fee;

        require(assetManagerContract.withdraw(underlying, msg.sender, amount), ""UToken: Failed to withdraw"");

        emit LogBorrow(msg.sender, amount, fee);
    }

    function repayBorrow(uint256 repayAmount) external whenNotPaused nonReentrant {
        _repayBorrowFresh(msg.sender, msg.sender, repayAmount);
    }

    function repayBorrowBehalf(address borrower, uint256 repayAmount) external whenNotPaused nonReentrant {
        _repayBorrowFresh(msg.sender, borrower, repayAmount);
    }

    
    function _repayBorrowFresh(
        address payer,
        address borrower,
        uint256 amount
    ) private {
        IUErc20 assetToken = IUErc20(underlying);
        
        bool isOverdue = checkIsOverdue(borrower);
        uint256 oldPrincipal = accountBorrows[borrower].principal;
        require(accrueInterest(), ""UToken: accrue interest failed"");
        require(accrualBlockNumber == getBlockNumber(), ""UToken: market not fresh"");

        uint256 interest = calculatingInterest(borrower);
        uint256 borrowedAmount = borrowBalanceStoredInternal(borrower);

        uint256 repayAmount;
        if (amount > borrowedAmount) {
            repayAmount = borrowedAmount;
        } else {
            repayAmount = amount;
        }

        require(repayAmount > 0, ""UToken: repay amount or owed amount is zero"");

        require(assetToken.allowance(payer, address(this)) >= repayAmount, ""UToken: Not enough allowance to repay"");

        uint256 toReserveAmount;
        uint256 toRedeemableAmount;
        if (repayAmount >= interest) {
            toReserveAmount = (interest * reserveFactorMantissa) / WAD;
            toRedeemableAmount = interest - toReserveAmount;

            if (isOverdue) {
                IUserManager(userManager).updateTotalFrozen(borrower, false);
                IUserManager(userManager).repayLoanOverdue(borrower, underlying, accountBorrows[borrower].lastRepay);
            }
            accountBorrows[borrower].principal = borrowedAmount - repayAmount;
            accountBorrows[borrower].interest = 0;

            if (accountBorrows[borrower].principal == 0) {
                
                accountBorrows[borrower].lastRepay = 0;
            } else {
                accountBorrows[borrower].lastRepay = getBlockNumber();
            }
        } else {
            toReserveAmount = (repayAmount * reserveFactorMantissa) / WAD;
            toRedeemableAmount = repayAmount - toReserveAmount;
            accountBorrows[borrower].interest = interest - repayAmount;
        }

        totalReserves += toReserveAmount;
        totalRedeemable += toRedeemableAmount;

        uint256 newPrincipal = accountBorrows[borrower].principal;
        accountBorrows[borrower].interestIndex = borrowIndex;
        totalBorrows -= repayAmount;

        IUserManager(userManager).updateLockedData(borrower, oldPrincipal - newPrincipal, false);

        assetToken.safeTransferFrom(payer, address(this), repayAmount);

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, repayAmount);

        require(IAssetManager(assetManager).deposit(underlying, repayAmount), ""UToken: Deposit failed"");

        emit LogRepay(borrower, repayAmount);
    }

    function repayBorrowWithPermit(
        address borrower,
        uint256 amount,
        uint256 nonce,
        uint256 expiry,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public whenNotPaused {
        IUErc20 erc20Token = IUErc20(underlying);
        erc20Token.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);

        _repayBorrowFresh(msg.sender, borrower, amount);
    }

    
    function accrueInterest() public returns (bool) {
        uint256 borrowRate = borrowRatePerBlock();
        uint256 currentBlockNumber = getBlockNumber();
        uint256 blockDelta = currentBlockNumber - accrualBlockNumber;

        uint256 simpleInterestFactor = borrowRate * blockDelta;
        uint256 interestAccumulated = (simpleInterestFactor * totalBorrows) / WAD;
        uint256 totalBorrowsNew = interestAccumulated + totalBorrows;
        uint256 borrowIndexNew = (simpleInterestFactor * borrowIndex) / WAD + borrowIndex;

        accrualBlockNumber = currentBlockNumber;
        borrowIndex = borrowIndexNew;
        totalBorrows = totalBorrowsNew;

        return true;
    }

    
    function balanceOfUnderlying(address owner) external returns (uint256) {
        return exchangeRateCurrent() * uErc20.balanceOf(owner);
    }

    function mint(uint256 mintAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        uint256 exchangeRate = exchangeRateStored();
        IUErc20 assetToken = IUErc20(underlying);
        uint256 balanceBefore = assetToken.balanceOf(address(this));
        require(assetToken.allowance(msg.sender, address(this)) >= mintAmount, ""UToken: Not enough allowance"");
        assetToken.safeTransferFrom(msg.sender, address(this), mintAmount);
        uint256 balanceAfter = assetToken.balanceOf(address(this));
        uint256 actualMintAmount = balanceAfter - balanceBefore;
        totalRedeemable += actualMintAmount;
        uint256 mintTokens = (actualMintAmount * WAD) / exchangeRate;
        uErc20.mint(msg.sender, mintTokens);

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, actualMintAmount);

        require(IAssetManager(assetManager).deposit(underlying, actualMintAmount), ""UToken: Deposit failed"");

        emit LogMint(msg.sender, actualMintAmount, mintTokens);
    }

    
    function redeem(uint256 redeemTokens) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        _redeemFresh(payable(msg.sender), redeemTokens, 0);
    }

    
    function redeemUnderlying(uint256 redeemAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        _redeemFresh(payable(msg.sender), 0, redeemAmount);
    }

    
    function _redeemFresh(
        address payable redeemer,
        uint256 redeemTokensIn,
        uint256 redeemAmountIn
    ) internal {
        require(redeemTokensIn == 0 || redeemAmountIn == 0, ""one of redeemTokensIn or redeemAmountIn must be zero"");

        IAssetManager assetManagerContract = IAssetManager(assetManager);

        uint256 exchangeRate = exchangeRateStored();

        uint256 redeemTokens;
        uint256 redeemAmount;

        if (redeemTokensIn > 0) {
            
            redeemTokens = redeemTokensIn;
            redeemAmount = (redeemTokensIn * exchangeRate) / WAD;
        } else {
            
            redeemTokens = (redeemAmountIn * WAD) / exchangeRate;
            redeemAmount = redeemAmountIn;
        }

        require(totalRedeemable >= redeemAmount, ""redeem amount error"");
        totalRedeemable -= redeemAmount;
        uErc20.burn(redeemer, redeemTokens);

        require(assetManagerContract.withdraw(underlying, redeemer, redeemAmount), ""UToken: Failed to withdraw"");

        emit LogRedeem(redeemer, redeemTokensIn, redeemAmountIn, redeemAmount);
    }

    function addReserves(uint256 addAmount) external whenNotPaused nonReentrant {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        IUErc20 assetToken = IUErc20(underlying);
        uint256 balanceBefore = assetToken.balanceOf(address(this));
        require(assetToken.allowance(msg.sender, address(this)) >= addAmount, ""UToken: Not enough allowance"");
        assetToken.safeTransferFrom(msg.sender, address(this), addAmount);
        uint256 balanceAfter = assetToken.balanceOf(address(this));
        uint256 actualAddAmount = balanceAfter - balanceBefore;

        uint256 totalReservesNew = totalReserves + actualAddAmount;
        
        require(totalReservesNew >= totalReserves, ""add reserves unexpected overflow"");
        totalReserves = totalReservesNew;

        assetToken.safeApprove(assetManager, 0);
        assetToken.safeApprove(assetManager, balanceAfter);

        require(IAssetManager(assetManager).deposit(underlying, balanceAfter), ""UToken: Deposit failed"");

        emit LogReservesAdded(msg.sender, actualAddAmount, totalReservesNew);
    }

    function removeReserves(address receiver, uint256 reduceAmount) external whenNotPaused nonReentrant onlyAdmin {
        require(accrueInterest(), ""UToken: accrue interest failed"");
        require(reduceAmount <= totalReserves, ""amount is large than totalReserves"");

        IAssetManager assetManagerContract = IAssetManager(assetManager);

        uint256 totalReservesNew = totalReserves - reduceAmount;
        
        require(totalReservesNew <= totalReserves, ""reduce reserves unexpected underflow"");

        totalReserves = totalReservesNew;

        require(assetManagerContract.withdraw(underlying, receiver, reduceAmount), ""UToken: Failed to withdraw"");

        emit LogReservesReduced(receiver, reduceAmount, totalReservesNew);
    }

    function debtWriteOff(address borrower, uint256 amount) external whenNotPaused onlyUserManager {
        uint256 oldPrincipal = accountBorrows[borrower].principal;
        uint256 repayAmount;
        if (amount > oldPrincipal) {
            repayAmount = oldPrincipal;
        } else {
            repayAmount = amount;
        }

        accountBorrows[borrower].principal = oldPrincipal - repayAmount;
        totalBorrows -= repayAmount;
    }

    
    function getBlockNumber() internal view returns (uint256) {
        return block.number;
    }

    function _setInterestRateModelFresh(address newInterestRateModel_) private {
        address oldInterestRateModel = address(interestRateModel);
        address newInterestRateModel = newInterestRateModel_;
        require(
            IInterestRateModel(newInterestRateModel).isInterestRateModel(),
            ""UToken: new model is not a interestRateModel""
        );
        interestRateModel = IInterestRateModel(newInterestRateModel);

        emit LogNewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);
    }

    
    function updateOverdueInfo(address account) external whenNotPaused {
        if (checkIsOverdue(account)) {
            IUserManager(userManager).updateTotalFrozen(account, true);
        }
    }

    
    function batchUpdateOverdueInfos(address[] calldata accounts) external whenNotPaused {
        address[] memory overdueAccounts = new address[](accounts.length);
        bool[] memory isOverdues = new bool[](accounts.length);
        for (uint256 i = 0; i < accounts.length; i++) {
            if (checkIsOverdue(accounts[i])) {
                overdueAccounts[i] = accounts[i];
                isOverdues[i] = true;
            }
        }
        IUserManager(userManager).batchUpdateTotalFrozen(overdueAccounts, isOverdues);
    }

    
    function _getCreditLimit(address account) private view returns (int256) {
        return IUserManager(userManager).getCreditLimit(account);
    }
}",5025.0,1,0,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Credit Limit Check**:  
   The contract casts the credit limit from `int256` to `uint256` without verifying if the value is non-negative. A negative credit limit (e.g., `-1`) would underflow to an extremely large `uint256` value (`2^256 - 1`), allowing borrowers to bypass credit restrictions and borrow unlimited amounts.

2. **Fee Accrues Interest**:  
   Origination fees are added to the principal debt, causing the fee itself to accumulate interest over time. This leads to borrowers paying interest on the fee, potentially resulting in unexpectedly high repayment amounts.

3. **Reliance on External Contracts Without Validation**:  
   The contract depends on external contracts (`UserManager`, `AssetManager`) for critical operations (e.g., credit checks, asset management). Compromised or misconfigured external contracts could lead to fund loss, incorrect debt tracking, or unauthorized access.

4. **Admin-Controlled Risk Parameters**:  
   Sensitive parameters (e.g., `originationFee`, `debtCeiling`, `interestRateModel`) are settable by the admin without on-chain constraints. A malicious or compromised admin could exploit this to manipulate fees, interest rates, or borrowing limits.

5. **Inconsistent AccrueInterest Redundancy**:  
   The `accrueInterest` function unconditionally returns `true`, making `require(accrueInterest(), ...)` checks redundant. While not a direct vulnerability, it introduces code quality issues and potential confusion.

6. **Overdue Status Update Dependency**:  
   The `updateOverdueInfo` and `batchUpdateOverdueInfos` functions rely on external calls to `UserManager`. If `UserManager` fails to update frozen states correctly, overdue loans may not be properly enforced.

7. **Lack of Asset-Backing Guarantees**:  
   `totalRedeemable` tracks user redemptions but does not ensure the `AssetManager` holds sufficient underlying assets. If the `AssetManager` loses funds (e.g., due to slashing or errors), users may be unable to redeem their tokens.

8. **Unchecked Origination Fee Magnitude**:  
   The `originationFee` can be set to values exceeding `WAD` (e.g., `2e18`), resulting in fees larger than the borrowed amount. This is allowed without constraints beyond admin discretion, posing a risk of predatory fee structures.

9. **Debt Write-Off Privilege Escalation**:  
   The `debtWriteOff` function is callable only by `UserManager`. If the `UserManager` is compromised, it could arbitrarily erase debts, disrupting the protocol's financial integrity.

10. **Insufficient Validation of Interest Rate Model**:  
    While `_setInterestRateModelFresh` checks if the new model implements `isInterestRateModel()`, it does not validate the reasonableness of the rates returned, risking unstable or exploitable interest calculations.","### **[H-01] borrow must accrueInterest first**

**Report Description**:  
The `UToken.borrow` function in the smart contract checks the borrowed balance and the old credit limit **before** accruing the actual interest on the market. This means the borrowed balance of the user does not include the latest interest, as it uses the old `borrowIndex` value. The new `borrowIndex` is only set in the `accrueInterest` function, which is called after these checks. This could lead to incorrect calculations of the user's borrowing capacity and potential risks if the interest accrual is delayed or fails.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect interest accrual timing in the `borrow` function. While the list includes related issues like **Fee Accrues Interest** and **Inconsistent AccrueInterest Redundancy**, these do not cover the specific problem of using outdated interest values for critical checks. This issue is distinct and requires a separate response to address the timing of `accrueInterest` in the borrowing process.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] borrow must accrueInterest first**",0,0,1,10,"Okay, let's see. I need to list all vulnerabilities in this smart contract. Hmm, where to start. Let me go through the code step by step.

First, I notice that the contract uses ReentrancyGuardUpgradeable. But maybe there are places where reentrancy isn't properly guarded. Let me check the functions. The borrow and repay functions have nonReentrant modifiers, which is good. But maybe there's a place missing the modifier? Let me check other functions. The redeem functions also have nonReentrant. Maybe that's covered.

Next, looking at the accrueInterest function. It's public and returns a bool. If someone calls this and it fails, but the require is only in some functions. Wait, in functions like borrow, they require accrueInterest to return true. But if accrueInterest can fail, that could cause issues. Wait, the accrueInterest function just calculates and updates variables. The require in borrow is ""require(accrueInterest(), ""..."");"" so if accrueInterest returns false, the transaction would revert. But why would accrueInterest return false? Let me look. The accrueInterest function just does some math and returns true. Oh, wait! The function is declared as returns (bool), but the code always returns true. So that require is redundant because it's always true. That's a potential issue because if there's an error in the calculation, it might not be caught. But maybe not a vulnerability per se.

Another thing: the initializer function __UToken_init. They're using initializer from OpenZeppelin, which is correct. But are there any missing initializations? Maybe not.

Looking at the borrow function. They check if the amount is >= minBorrow, and <= remaining loan size. Then calculate fee. Then check if the new borrow balance plus amount and fee is <= maxBorrow. Also check if the user isn't overdue. Then check if there's enough loanable amount. Then check credit limit. Then accrue interest. Then proceed.

Wait, when they calculate accountBorrowsNew and totalBorrowsNew, they add amount + fee. But the fee is part of the total borrows. Then totalReserves is increased by fee. But the origination fee is added to the principal. So when you borrow, you're immediately charged a fee that's added to your principal. That could be a problem if the fee is high, but maybe that's intended. However, if the fee calculation isn't properly handled, maybe there's an overflow. Let's see. CalculatingFee is (originationFee * amount) / WAD. If originationFee is set too high, this could lead to a large fee. But since originationFee is set by admin, maybe that's an admin risk.

In the repayBorrow function, when repaying, they check if the amount is greater than the borrowedAmount. If so, use borrowedAmount. Then handle the repayment. But in the code, they have toReserveAmount and toRedeemableAmount. If repayAmount >= interest, then they take the interest and split into reserves and redeemable. But when repaying, if the amount is more than the total owed, the excess isn't returned. Wait, no. Because if the user repays more than owed, repayAmount is set to borrowedAmount. So the user can't overpay. But if they send more than needed, the code doesn't handle it. Wait, no, because the code uses the actual borrowedAmount. Let me check: in _repayBorrowFresh, they have:

uint256 repayAmount;
if (amount > borrowedAmount) {
    repayAmount = borrowedAmount;
} else {
    repayAmount = amount;
}

So the payer is only charged up to the borrowed amount. But the code transfers repayAmount from the payer. So even if they specify a higher amount, it only takes what's needed. That's okay.

Looking at the interest calculation. The calculatingInterest function uses borrowRatePerBlock, which is based on the current block. But accrueInterest is supposed to update the borrowIndex and totalBorrows. However, in the borrowBalanceStoredInternal, they use (loan.principal + loan.interest) * borrowIndex / loan.interestIndex. Wait, that might be incorrect. Because when a user borrows, their principal is increased by amount + fee, and the interest is set to 0? Or maybe when a new borrow is made, the interest is reset. Let's look at the borrow function:

After accrueInterest, they get borrowedAmount = borrowBalanceStoredInternal(msg.sender). Then accountBorrowsNew = borrowedAmount + amount + fee. Then:

accountBorrows[msg.sender].principal += amount + fee;
accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;
Wait, that's confusing. The accountBorrows.principal is being increased by amount + fee. Then accountBorrowsNew is borrowedAmount (which includes existing principal + interest) plus amount + fee. Then the new principal is set to the existing principal + amount + fee. The interest is set to accountBorrowsNew - principal, which would be (existing principal + interest + amount + fee) - (existing principal + amount + fee) = interest. So this seems to carry over the existing interest into the new principal. But maybe this is an error. Because when you borrow again, the existing interest should be capitalized into the principal. But perhaps this is intended. However, maybe this leads to incorrect interest calculations. For example, if a user has an existing loan with some interest, and then borrows more, the code adds the existing interest to the principal. But that's how compounding works. Hmm. Let me think. When you accrue interest before borrowing, the totalBorrows is updated with the interest. Then borrowBalanceStoredInternal would return the principal plus the interest. Then adding the new amount + fee, the new principal becomes previous principal + previous interest + amount + fee. So effectively, the interest is added to the principal, which is correct. So maybe that's okay.

Another point: the exchangeRateStored function uses totalRedeemable to calculate the exchange rate. But totalRedeemable is increased when someone mints, and decreased when redeeming. However, if there are reserves being added or removed, does that affect redeemable? Let's see: when you add reserves via addReserves, totalReserves increases, but totalRedeemable is not directly affected. Wait, the addReserves function transfers underlying tokens and adds to reserves. But in the code, when you add reserves, it calls IAssetManager deposit with the actualAddAmount. But in the UToken's totalRedeemable is separate from reserves. So the redeemable is the amount that can be redeemed by uToken holders. But how is that tracked? It seems that when you mint, the underlying is added to totalRedeemable, and when you redeem, it's subtracted. Also, when repaying, part of the repay is added to redeemable. For example, in repay, if repayAmount >= interest, then toRedeemableAmount is interest - toReserveAmount. So redeemable is the sum of deposits minus redemptions plus the interest that is allocated to redeemable. But the problem here is that totalRedeemable might not correctly represent the actual underlying held by the contract. Because the AssetManager is supposed to manage the underlying, but the UToken's totalRedeemable is a separate accounting. This could lead to discrepancies. For example, if the AssetManager loses funds (e.g., due to a hack or bad investment), the totalRedeemable would still suggest that users can redeem their uTokens, but the actual underlying might not be there. However, this is more of an integration issue with the AssetManager rather than a vulnerability in the UToken contract itself. But maybe the contract relies too much on the AssetManager's proper functioning.

Another possible vulnerability: the debtWriteOff function is only callable by the UserManager. If the UserManager is compromised, it could write off debts incorrectly. But that's a trust issue with the UserManager, which is an external contract. So if the UserManager has a vulnerability, this function could be abused. But since it's marked as onlyUserManager, it's up to the admin to ensure the UserManager is secure.

Looking at the setter functions (like setInterestRateModel, setReserveFactor), they are onlyAdmin, which is correct as they are using the Controller's admin. So that's okay.

In the calculatingFee function, originationFee is multiplied by amount and divided by WAD. But if originationFee is set to a value larger than WAD, the fee could be more than the amount borrowed. For example, if originationFee is 2e18, then the fee would be 2*amount. The require in __UToken_init checks that reserveFactorMantissa_ is <= RESERVE_FACTORY_MAX_MANTISSA (1e18), but originationFee is not checked in the same way. So if the admin sets originationFee to 2e18, the fee would be 200% of the amount. That's a possible issue if the admin is malicious or makes a mistake, but it's an admin risk rather than a code vulnerability.

In the borrow function, after calculating fee, they check that the new borrow balance (borrowBalanceView(msg.sender) + amount + fee) <= maxBorrow. But borrowBalanceView includes the current borrowed plus the fee. Wait, no. Let's see: borrowBalanceView is defined as accountBorrows[account].principal + calculatingInterest(account). But when a user is taking a new borrow, the code first accrues interest (which updates totalBorrows and borrowIndex), then computes borrowedAmount = borrowBalanceStoredInternal(msg.sender). Then accountBorrowsNew = borrowedAmount + amount + fee. So the fee is added to the principal. Therefore, the maxBorrow check is against the new total borrowed (existing + new amount + fee). So if maxBorrow is a limit per user, this is correct.

Another thing: the initialExchangeRateMantissa is set during initialization, and if the uErc20 token has a totalSupply of 0, the exchange rate uses initialExchangeRateMantissa. But when someone mints, the redeemable is increased, and the exchange rate is (totalRedeemable * WAD) / totalSupply. But if the initialExchangeRate is wrong, it could lead to incorrect minting. However, that's an initialization issue.

Possible arithmetic overflows/underflows: The contract uses SafeMath from OpenZeppelin via SafeERC20Upgradeable, but since Solidity 0.8, checked math is enabled by default. The pragma is ^0.8.4, so overflow checks are done automatically. So no need to worry about that unless there's unhandled division or something.

In the redeem function, when redeeming tokens, redeemAmount is calculated as (redeemTokensIn * exchangeRate) / WAD. If the exchange rate is very low, this could result in a redeemAmount of 0 even if redeemTokensIn is non-zero. But the code requires totalRedeemable >= redeemAmount, which would fail if redeemAmount is 0. So if someone tries to redeem when exchangeRate is very low, the transaction would revert. But that's expected behavior.

Another potential issue: the AssetManager's deposit and withdraw functions are called, but there's no check on their return values in all cases. For example, in the mint function, after transferring the tokens, they approve and call IAssetManager(assetManager).deposit(underlying, actualMintAmount). If deposit returns false, the transaction reverts. So that's handled. Similarly in other places, like repayBorrow, addReserves, etc.

Now, looking at reentrancy again: the nonReentrant modifier is used on borrow, repay, redeem, etc. But functions like accrueInterest are public and don't have the modifier. However, since accrueInterest only updates variables and doesn't call external contracts, it's safe.

What about the updateOverdueInfo and batchUpdateOverdueInfos functions? They call into the UserManager. If the UserManager is malicious, it could re-enter. But these functions are marked as whenNotPaused and call external functions after checks. But since they're using the nonReentrant modifier on other functions, but not here, but these functions don't modify state in a way that would be vulnerable. Hmm, maybe not a vulnerability here.

What about the debtCeiling check in borrow? The code checks if amount <= getRemainingLoanSize(), which is debtCeiling - totalBorrows. But totalBorrows includes the accrued interest. So if the debtCeiling is set without considering that totalBorrows increases with interest, the available borrows could exceed the ceiling over time. Wait, no. Because getRemainingLoanSize returns debtCeiling - totalBorrows. Since totalBorrows includes the principal plus accrued interest, the remaining size decreases as interest accrues. That's correct. So when a borrow happens, totalBorrows is increased by amount + fee, which is correct.

Another possible issue: the getCreditLimit function is called with _getCreditLimit(member), which returns an int256. Then the code checks if the amount + fee is <= the credit limit. But the credit limit could be negative, which would cause the require to fail. But since credit limit is determined by the UserManager, which should return a non-negative value, this is probably handled there.

Wait, the credit limit is stored as an int256. In the borrow function, there's a check:

require(
    uint256(_getCreditLimit(msg.sender)) >= amount + fee,
    ""UToken: The loan amount plus fee is greater than credit limit""
);

But _getCreditLimit returns an int256. If it returns a negative number, converting to uint256 would wrap around to a very large number, which could allow borrowing even if the credit limit is negative. That's a big problem!

For example, if the credit limit is -1, then uint256(-1) would be 2^256 - 1, which is way larger than any possible amount + fee. So the require would pass even though the actual credit limit is negative. That's a critical vulnerability.

Yes! That's a major issue. The code casts the int256 credit limit to uint256 without checking if it's non-negative. So even if the UserManager returns a negative credit limit, the code would treat it as a huge value, allowing the user to borrow beyond their actual limit.

Another problem: in the borrow function, the code adds the fee to the principal. However, the fee is also added to the totalBorrows and totalReserves. Wait, the code does:

totalReserves += fee;

But when the fee is part of the borrow, it's included in the totalBorrows. So the fee is considered as part of the borrowed amount, which is being charged interest. That means the origination fee itself accrues interest over time. Which could be intended, but if not, this is a problem. For example, if you borrow 100 with a 10% fee, your principal becomes 110, and you pay interest on 110. That's correct if the fee is part of the principal. But maybe the fee should be a one-time charge, not accruing interest. But according to the code, it's added to the principal, so it does accrue interest.

Other possible issues: The UserManager and AssetManager are external contracts that can be set by the admin. If these are malicious or have vulnerabilities, the UToken could be affected. But since these are set by admin, it's a trust issue.

So summarizing the vulnerabilities:

1. **Incorrect Credit Limit Check**: The credit limit is retrieved as an int256, but cast to uint256 without checking if it's non-negative. A negative credit limit would become a very large uint256, allowing unauthorized borrowing.

2. **Fee Accrues Interest**: The origination fee is added to the principal, causing the fee itself to accrue interest over time. While this might be intended, it could lead to unexpectedly high costs for borrowers if not properly communicated.

3. **Potential Inconsistency in totalRedeemable**: The totalRedeemable variable tracks the redeemable amount, but relies on correct interaction with the AssetManager. If the AssetManager doesn't hold sufficient funds, redeemable amounts may not be backed, leading to potential insolvency.

4. **Admin Privileges**: Functions like setInterestRateModel, setReserveFactor, etc., are controlled by the admin. If the admin is malicious or compromised, they could manipulate parameters to their advantage (e.g., setting high fees or interest rates).

5. **Overflow in calculatingFee**: If originationFee is set too high, calculatingFee could result in a very large fee. However, since originationFee is controlled by admin, this is an admin risk.

6. **No Check for Interest Accrual Failure**: The accrueInterest function always returns true, making the require statements in functions like borrow and repay redundant. If accrueInterest were to ever fail (though it currently can't), these checks wouldn't catch it, but as written, it's a code quality issue rather than a vulnerability.

The most critical issue is the incorrect handling of the credit limit's sign, allowing borrowers to exceed their actual credit limit if it's negative.","```
None.
```",0.0
CreditLimitByMedian.sol,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../interfaces/ICreditLimitModel.sol"";

contract CreditLimitByMedian is Ownable, ICreditLimitModel {
    using Math for uint256;

    bool public constant override isCreditLimitModel = true;
    uint256 public override effectiveNumber;

    constructor(uint256 effectiveNumber_) {
        effectiveNumber = effectiveNumber_;
    }

    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {
        if (vouchs.length >= effectiveNumber) {
            return _findMedian(vouchs);
        } else {
            return 0;
        }
    }

    function getLockedAmount(
        LockedInfo[] memory array,
        address account,
        uint256 amount,
        bool isIncrease
    ) public pure override returns (uint256) {
        if (array.length == 0) return 0;

        uint256 newLockedAmount;
        if (isIncrease) {
            for (uint256 i = 0; i < array.length; i++) {
                uint256 remainingVouchingAmount;
                if (array[i].vouchingAmount > array[i].lockedAmount) {
                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;
                } else {
                    remainingVouchingAmount = 0;
                }

                if (remainingVouchingAmount > array[i].availableStakingAmount) {
                    if (array[i].availableStakingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;
                    }
                } else {
                    if (remainingVouchingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;
                    }
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        } else {
            for (uint256 i = 0; i < array.length; i++) {
                if (array[i].lockedAmount > amount) {
                    newLockedAmount = array[i].lockedAmount - 1;
                } else {
                    newLockedAmount = 0;
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        }

        return 0;
    }

    function setEffectNumber(uint256 number) external onlyOwner {
        effectiveNumber = number;
    }

    /**
     *  @dev Find median from uint array
     *  @param array array
     *  @return uint256
     */
    function _findMedian(uint256[] memory array) private pure returns (uint256) {
        uint256[] memory arr = _sortArray(array);
        if (arr.length == 0) return 0;

        if (arr.length % 2 == 0) {
            uint256 num1 = arr[arr.length >> 1];
            uint256 num2 = arr[(arr.length >> 1) - 1];
            return num1.average(num2);
        } else {
            return arr[arr.length >> 1];
        }
    }

    /**
     *  @dev Sort uint array
     *  @param arr array
     *  @return uint256 array
     */
    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {
        uint256 length = arr.length;

        for (uint256 i = 0; i < length; i++) {
            for (uint256 j = i + 1; j < length; j++) {
                if (arr[i] < arr[j]) {
                    uint256 temp = arr[j];
                    arr[j] = arr[i];
                    arr[i] = temp;
                }
            }
        }

        return arr;
    }
}",861.0,122.0,"[H-02] Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` makes it unable to unlock `lockedAmount` in CreditLimitByMedian model
`getLockedAmount()` is used by `UserManager.sol#updateLockedData()` to update locked amounts.
Based on the context, at L66, `newLockedAmount = array[i].lockedAmount - 1;` should be newLockedAmount = array[i].lockedAmount - amount;.
The current implementation is wrong and makes it impossible to unlock `lockedAmount` in CreditLimitByMedian model
  [M-01] Wrong implementation of CreditLimitByMedian.sol#getLockedAmount() will lock a much bigger total amount of staked tokens than expected
`getLockedAmount()` is used by `UserManager.sol#updateLockedData()` to update locked amounts.
The current implementation is wrong and locks every staker for the amount of the borrowed amount or all the `vouchingAmount` if the `vouchingAmount` is smaller than the borrowed amount in CreditLimitByMedian model.",2.0,"pragma solidity ^0.8.4;

import ""@openzeppelin/contracts/utils/math/Math.sol"";
import ""@openzeppelin/contracts/access/Ownable.sol"";

import ""../interfaces/ICreditLimitModel.sol"";

contract CreditLimitByMedian is Ownable, ICreditLimitModel {
    using Math for uint256;

    bool public constant override isCreditLimitModel = true;
    uint256 public override effectiveNumber;

    constructor(uint256 effectiveNumber_) {
        effectiveNumber = effectiveNumber_;
    }

    function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {
        if (vouchs.length >= effectiveNumber) {
            return _findMedian(vouchs);
        } else {
            return 0;
        }
    }

    function getLockedAmount(
        LockedInfo[] memory array,
        address account,
        uint256 amount,
        bool isIncrease
    ) public pure override returns (uint256) {
        if (array.length == 0) return 0;

        uint256 newLockedAmount;
        if (isIncrease) {
            for (uint256 i = 0; i < array.length; i++) {
                uint256 remainingVouchingAmount;
                if (array[i].vouchingAmount > array[i].lockedAmount) {
                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;
                } else {
                    remainingVouchingAmount = 0;
                }

                if (remainingVouchingAmount > array[i].availableStakingAmount) {
                    if (array[i].availableStakingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;
                    }
                } else {
                    if (remainingVouchingAmount > amount) {
                        newLockedAmount = array[i].lockedAmount + amount;
                    } else {
                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;
                    }
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        } else {
            for (uint256 i = 0; i < array.length; i++) {
                if (array[i].lockedAmount > amount) {
                    newLockedAmount = array[i].lockedAmount - 1;
                } else {
                    newLockedAmount = 0;
                }

                if (account == array[i].staker) {
                    return newLockedAmount;
                }
            }
        }

        return 0;
    }

    function setEffectNumber(uint256 number) external onlyOwner {
        effectiveNumber = number;
    }

    
    function _findMedian(uint256[] memory array) private pure returns (uint256) {
        uint256[] memory arr = _sortArray(array);
        if (arr.length == 0) return 0;

        if (arr.length % 2 == 0) {
            uint256 num1 = arr[arr.length >> 1];
            uint256 num2 = arr[(arr.length >> 1) - 1];
            return num1.average(num2);
        } else {
            return arr[arr.length >> 1];
        }
    }

    
    function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {
        uint256 length = arr.length;

        for (uint256 i = 0; i < length; i++) {
            for (uint256 j = i + 1; j < length; j++) {
                if (arr[i] < arr[j]) {
                    uint256 temp = arr[j];
                    arr[j] = arr[i];
                    arr[i] = temp;
                }
            }
        }

        return arr;
    }
}",792.0,1,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Incorrect Locked Amount Adjustment in Decrease Case**  
   In `getLockedAmount`, when `isIncrease` is `false`, the code incorrectly subtracts `1` instead of the specified `amount` from the locked amount. For example, if `lockedAmount` is `100` and `amount` is `5`, the result becomes `99` instead of the expected `95`, leading to critical miscalculations.

2. **Inefficient Sorting Algorithm**  
   The `_sortArray` function implements a bubble sort (O(n²) complexity). Sorting large `vouchs` arrays can cause excessive gas consumption, risking transaction failures due to block gas limits.

3. **Unhandled Missing Staker in LockedInfo Array**  
   If the `account` is not found in the `LockedInfo[]` array, `getLockedAmount` returns `0`. This may reset legitimate locked amounts to zero if the staker’s entry is accidentally omitted, causing unintended behavior.

4. **Gas Exhaustion Risk in getCreditLimit**  
   Median calculation via `_findMedian` requires sorting potentially large arrays. This can lead to prohibitively high gas costs, making the function impractical for large datasets and risking denial of service.

5. **Truncation in Median Calculation for Even-Length Arrays**  
   When averaging two middle values for even-length arrays, integer division truncates fractional results (e.g., `3.5` becomes `3`). While expected in integer arithmetic, this may not align with the intended financial model precision.","### **Output**

---

**[H-02] Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` makes it unable to unlock `lockedAmount` in CreditLimitByMedian model**

**Report Description**:  
The `getLockedAmount()` function in `CreditLimitByMedian.sol` is incorrectly implemented. Specifically, at line 66, the calculation `newLockedAmount = array[i].lockedAmount - 1;` should be `newLockedAmount = array[i].lockedAmount - amount;`. This error prevents the proper unlocking of `lockedAmount` in the `CreditLimitByMedian` model, leading to incorrect locked amounts and potential issues in the `UserManager.sol#updateLockedData()` function.

**Match in Response List**:  
Matches with the issue titled **""Incorrect Locked Amount Adjustment in Decrease Case""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the incorrect adjustment of the locked amount in the `getLockedAmount` function. It correctly explains the miscalculation caused by subtracting `1` instead of the specified `amount`, which aligns with the reported issue and Solidity best practices for precise arithmetic operations.

---

**[M-01] Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` will lock a much bigger total amount of staked tokens than expected**

**Report Description**:  
The `getLockedAmount()` function in `CreditLimitByMedian.sol` is incorrectly implemented, leading to the locking of a much larger total amount of staked tokens than expected. Specifically, the function locks every staker for the borrowed amount or all the `vouchingAmount` if the `vouchingAmount` is smaller than the borrowed amount. This results in excessive locking of staked tokens, which could have significant financial implications for users.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. While it identifies the incorrect adjustment of locked amounts, it does not cover the broader impact of excessive locking of staked tokens, which is a critical aspect of the reported issue.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` makes it unable to unlock `lockedAmount` in CreditLimitByMedian model**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-01] Wrong implementation of `CreditLimitByMedian.sol#getLockedAmount()` will lock a much bigger total amount of staked tokens than expected**

--- 

This evaluation highlights that while the response list accurately addresses one of the reported issues, it misses a critical aspect of the second issue, leaving a significant gap in the coverage of vulnerabilities.",1,0,1,5,"Okay, let's take a look at this smart contract. The contract is called CreditLimitByMedian and it's implementing some kind of credit limit model based on the median of vouching amounts. First, I need to go through each function and check for possible vulnerabilities or issues.

Starting with the constructor, it sets the effectiveNumber. That's straightforward. Then there's the getCreditLimit function. It checks if the length of vouchs is at least effectiveNumber. If not, returns 0. Otherwise, computes the median. The median calculation uses a sorting function. Wait, the _sortArray function uses a nested loop which is a bubble sort. That's O(n^2) complexity. If the vouchs array is large, this could consume a lot of gas, maybe even exceed block gas limits. That's a problem because sorting large arrays in Solidity is expensive.

Next, the getLockedAmount function. Let's see. It takes an array of LockedInfo, an account, amount, and a boolean isIncrease. If the array is empty, returns 0. Then, depending on isIncrease, it loops through the array. In the isIncrease block, for each element, it calculates remainingVouchingAmount. Then there's a series of conditionals. But wait, in the loop, once it finds the staker matching the account, it returns newLockedAmount. However, the loop starts at 0 and returns on the first match. So if there are multiple entries with the same staker, it returns the first one. But maybe the array is supposed to have unique stakers? Not sure if that's an issue.

Looking at the decrease case (isIncrease is false), the code checks if lockedAmount > amount. If so, newLockedAmount is lockedAmount minus 1? Wait, the code says newLockedAmount = array[i].lockedAmount - 1; but the parameter is amount. Wait, this seems like a bug. If we're decreasing, then when isIncrease is false, the code should subtract the amount, not 1. Because the code here says if array[i].lockedAmount > amount, then subtract 1. That's incorrect. For example, if lockedAmount is 100 and amount is 5, then newLockedAmount would be 99, but the correct should be 95. This is definitely a vulnerability. So in the else block (isIncrease is false), the code is subtracting 1 instead of the amount. That's a critical error.

Another thing in getLockedAmount: when isIncrease is true, the loop checks for each staker. If the staker is the account, returns the newLockedAmount. But if the staker isn't found, the function returns 0. But maybe the staker should be in the array? If the account isn't found, returning 0 might be incorrect, but that depends on the requirements. However, if the function is supposed to update the lockedAmount for the given account, but the account isn't in the array, returning 0 might not be intended. For example, if someone calls this function with an account not present in the array, they could reset the locked amount to 0, which might not be desired.

Looking at the setEffectNumber function, it's external and onlyOwner. That's okay, but changing effectiveNumber could affect the credit limit calculations. However, since the owner is allowed, that's a design choice, not a vulnerability.

Back to the sorting function: using bubble sort is inefficient. For example, if there's a large array of vouchs, like hundreds of elements, the gas cost would be extremely high. This could lead to denial of service or failed transactions due to out-of-gas errors.

Another possible issue is integer underflow/overflow. The contract uses Solidity 0.8.x, which has built-in checks, so that's probably not an issue. For example, in the line where remainingVouchingAmount is calculated as array[i].vouchingAmount - array[i].lockedAmount, since Solidity 0.8.x reverts on underflow, but there's a check if vouchingAmount > lockedAmount. So that's safe.

In the getLockedAmount function, when isIncrease is true, there are nested conditionals. Let me parse through them:

If remainingVouchingAmount (which is vouchingAmount - lockedAmount if vouchingAmount > lockedAmount else 0) is greater than availableStakingAmount. Then, if availableStakingAmount > amount, add amount to lockedAmount. Else, add availableStakingAmount. Wait, this logic seems off. Let me think. The code is trying to calculate how much can be added to the lockedAmount based on the remaining vouching and available staking amounts.

But maybe there's an issue here. For example, if remainingVouchingAmount is greater than availableStakingAmount, then the maximum that can be added is the minimum of availableStakingAmount and the amount. But the code first checks if availableStakingAmount > amount. If yes, adds amount; else adds availableStakingAmount. But maybe the intended logic is to cap the increase by the availableStakingAmount. Wait, if remainingVouchingAmount > availableStakingAmount, then the code adds either amount or availableStakingAmount, whichever is smaller. That seems correct. But perhaps the logic should be taking the minimum of availableStakingAmount and amount. For example, availableStakingAmount > amount: then add amount. Else add availableStakingAmount. That's correct.

But in the else case (remainingVouchingAmount <= availableStakingAmount), the code checks if remainingVouchingAmount > amount. If yes, add amount. Else, add remainingVouchingAmount. Which is correct. So maybe the logic here is okay, but I need to verify.

Another thing: in the loop for isIncrease, once the account is found (account == array[i].staker), it returns newLockedAmount immediately. But in the loop, newLockedAmount is calculated for each iteration, regardless of whether the staker is the target account. So even if the staker is at position 5, the code calculates newLockedAmount for positions 0-4 before reaching 5. However, since it's a view function, this doesn't modify state, but it's a gas inefficiency. However, that's not a vulnerability, just a gas optimization.

Back to the decrease case (isIncrease is false): the code checks if array[i].lockedAmount > amount. If so, subtract 1. Otherwise, set to 0. That's definitely a bug. It should subtract the amount, not 1. For example, if a user wants to decrease the locked amount by 5, but their current locked amount is 10, the code would set it to 9 instead of 5. This is a critical flaw in the logic. The line should be newLockedAmount = array[i].lockedAmount - amount, but instead, it's subtracting 1. That's a major vulnerability.

Another possible issue: the getLockedAmount function returns 0 if the staker is not found in the array. But perhaps if the staker isn't present, the function should revert or return the original locked amount. However, according to the code, if the staker isn't found after looping through all elements, it returns 0. Depending on how this function is used elsewhere, this could lead to incorrect calculations. For example, if a staker's LockedInfo isn't in the array, their locked amount would be considered 0, which might not be correct.

In the _findMedian function, when the array length is even, it averages the two middle numbers. But since we're dealing with integers, the average could be a fractional number, but Solidity truncates it. For example, if the two numbers are 3 and 4, the average is 3.5, which would be 3 in Solidity. But depending on the context, this might be acceptable or not. However, since the function returns a uint256, this truncation is expected. It's a design choice, not necessarily a vulnerability.

Another thing: the code uses Math.average, which is from OpenZeppelin's Math library. That's safe.

Potential Reentrancy? Since getLockedAmount is a pure function and doesn't modify state, reentrancy isn't an issue here. Similarly, getCreditLimit is a view function. So no reentrancy vulnerabilities.

Ownable: The contract inherits Ownable, so only the owner can set the effective number. That's fine as per design.

So summarizing the vulnerabilities:

1. **Incorrect Decrement in getLockedAmount**: When decreasing the locked amount (isIncrease=false), the code subtracts 1 instead of the specified amount. This is a critical logical error leading to incorrect calculations.

2. **Inefficient Sorting Algorithm**: The _sortArray function uses a bubble sort with O(n^2) time complexity. For large arrays, this can cause excessive gas consumption and potentially make the function unusable due to block gas limits.

3. **Unhandled Staker Not Found in getLockedAmount**: If the specified account is not found in the LockedInfo array, the function returns 0, which might not be the intended behavior. This could lead to incorrect locked amounts if the staker's info is missing from the array.

4. **Potential Gas Exhaustion in getCreditLimit**: Since the median calculation requires sorting an array that could be large, the function may consume too much gas, leading to failed transactions or denial of service.

5. **Possible Incorrect Median Calculation for Even-Length Arrays**: Using integer division when averaging two middle numbers could lead to truncation errors. However, this is inherent to integer arithmetic and may be acceptable based on requirements.

The most severe issues here are the incorrect decrement in the decrease case and the inefficient sorting leading to gas issues.","```
1. Incorrect Locked Amount Adjustment in Decrease Case
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Incorrect Locked Amount Adjustment in Decrease Case"".
   - This appears at rank 1 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 1 (\( P@1 \)) is calculated as the number of true positives up to rank 1 divided by the rank itself.
   - Since there is 1 true positive at rank 1, \( P@1 = \frac{1}{1} = 1.0 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at that rank.
   - Therefore, \( AP = 1.0 \).

**Output**:
```
1.0
```"
AssetManager.sol,"//SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""../Controller.sol"";
import ""../interfaces/IMarketRegistry.sol"";
import ""../interfaces/IMoneyMarketAdapter.sol"";
import ""../interfaces/IAssetManager.sol"";

/**
 *  @title AssetManager
 *  @dev Manage the token assets deposited by components and admins, and invest tokens to the integrated underlying lending protocols.
 */
contract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;

    IMoneyMarketAdapter[] public moneyMarkets;
    mapping(address => Market) public supportedMarkets;
    address[] public supportedTokensList;
    //record admin or userManager balance
    mapping(address => mapping(address => uint256)) public balances; //1 user 2 token
    mapping(address => uint256) public totalPrincipal; //total stake amount
    address public marketRegistry;
    // slither-disable-next-line uninitialized-state
    uint256[] public withdrawSeq; // Priority sequence of money market indices for processing withdraws

    struct Market {
        bool isSupported;
    }

    modifier checkMarketSupported(address token) {
        require(isMarketSupported(token), ""AssetManager: token not support"");
        _;
    }

    modifier onlyAuth(address token) {
        require(
            _isUToken(msg.sender, token) || _isUserManager(msg.sender, token),
            ""AssetManager: sender must uToken or userManager""
        );
        _;
    }

    /**
     *  @dev Emit when making a deposit
     *  @param token Depositing token address
     *  @param account Account address
     *  @param amount Deposit amount, in wei
     */
    event LogDeposit(address indexed token, address indexed account, uint256 amount);
    /**
     *  @dev Emit when withdrawing from AssetManager
     *  @param token Depositing token address
     *  @param account Account address
     *  @param amount Withdraw amount, in wei
     *  @param remaining The amount cannot be withdrawn
     */
    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);
    /**
     *  @dev Emit when rebalancing among the integrated money markets
     *  @param tokenAddress The address of the token to be rebalanced
     *  @param percentages Array of the percentages of the tokens to deposit to the money markets
     */
    event LogRebalance(address tokenAddress, uint256[] percentages);

    function __AssetManager_init(address _marketRegistry) public initializer {
        Controller.__Controller_init(msg.sender);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        marketRegistry = _marketRegistry;
    }

    function setMarketRegistry(address _marketRegistry) external onlyAdmin {
        marketRegistry = _marketRegistry;
    }

    /**
     *  @dev Get the balance of asset manager, plus the total amount of tokens deposited to all the underlying lending protocols
     *  @param tokenAddress ERC20 token address
     *  @return Pool balance
     */
    function getPoolBalance(address tokenAddress) public view override returns (uint256) {
        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);
        uint256 balance = poolToken.balanceOf(address(this));
        if (isMarketSupported(tokenAddress)) {
            return totalSupplyView(tokenAddress) + balance;
        } else {
            return balance;
        }
    }

    /**
     *  @dev Returns the amount of the lending pool balance minus the amount of total staked.
     *  @param tokenAddress ERC20 token address
     *  @return Amount can be borrowed
     */
    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {
        uint256 poolBalance = getPoolBalance(tokenAddress);
        if (poolBalance > totalPrincipal[tokenAddress]) return poolBalance - totalPrincipal[tokenAddress];
        return 0;
    }

    /**
     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols without side effects.
     *  @param tokenAddress ERC20 token address
     *  @return Total market balance
     */
    function totalSupply(address tokenAddress) public override returns (uint256) {
        if (isMarketSupported(tokenAddress)) {
            uint256 tokenSupply = 0;
            for (uint256 i = 0; i < moneyMarkets.length; i++) {
                if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                    continue;
                }
                tokenSupply += moneyMarkets[i].getSupply(tokenAddress);
            }

            return tokenSupply;
        } else {
            return 0;
        }
    }

    /**
     *  @dev Get the total amount of tokens deposited to all the integrated underlying protocols, but without side effects. Safe to call anytime, but may not get the most updated number for the current block. Call totalSupply() for that purpose.
     *  @param tokenAddress ERC20 token address
     *  @return Total market balance
     */
    function totalSupplyView(address tokenAddress) public view override returns (uint256) {
        if (isMarketSupported(tokenAddress)) {
            uint256 tokenSupply = 0;
            for (uint256 i = 0; i < moneyMarkets.length; i++) {
                if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                    continue;
                }
                tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);
            }

            return tokenSupply;
        } else {
            return 0;
        }
    }

    /**
     *  @dev Check if there is an underlying protocol available for the given ERC20 token.
     *  @param tokenAddress ERC20 token address
     *  @return Whether is supported
     */
    function isMarketSupported(address tokenAddress) public view override returns (bool) {
        return supportedMarkets[tokenAddress].isSupported;
    }

    /**
     *  @dev Deposit tokens to AssetManager, and those tokens will be passed along to adapters to deposit to integrated asset protocols if any is available.
     *  @param token ERC20 token address
     *  @param amount ERC20 token address
     *  @return Deposited amount
     */
    function deposit(address token, uint256 amount)
        external
        override
        whenNotPaused
        onlyAuth(token)
        nonReentrant
        returns (bool)
    {
        IERC20Upgradeable poolToken = IERC20Upgradeable(token);
        require(amount > 0, ""AssetManager: amount can not be zero"");

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] += amount;
            totalPrincipal[token] += amount;
        }

        bool remaining = true;
        if (isMarketSupported(token)) {
            // assumption: markets are arranged in order of decreasing liquidity
            // iterate markets till floors are filled
            // floors define minimum amount to maintain confidence in liquidity
            for (uint256 i = 0; i < moneyMarkets.length && remaining; i++) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[i];

                if (!moneyMarket.supportsToken(token)) continue;
                if (moneyMarket.floorMap(token) <= moneyMarket.getSupply(token)) continue;

                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);
                moneyMarket.deposit(token);
                remaining = false;
            }

            // assumption: less liquid markets provide more yield
            // iterate markets in reverse to optimize for yield
            // do this only if floors are filled i.e. min liquidity satisfied
            // dposit in the market where ceiling is not being exceeded
            for (uint256 j = moneyMarkets.length; j > 0 && remaining; j--) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[j - 1];
                if (!moneyMarket.supportsToken(token)) continue;

                uint256 supply = moneyMarket.getSupply(token);
                uint256 ceiling = moneyMarket.ceilingMap(token);
                if (ceiling <= supply) continue;
                if (supply + amount > ceiling) continue;

                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);
                moneyMarket.deposit(token);
                remaining = false;
            }
        }

        if (remaining) {
            poolToken.safeTransferFrom(msg.sender, address(this), amount);
        }

        emit LogDeposit(token, msg.sender, amount);

        return true;
    }

    /**
     *  @dev Withdraw from AssetManager
     *  @param token ERC20 token address
     *  @param account User address
     *  @param amount ERC20 token address
     *  @return Withdraw amount
     */
    function withdraw(
        address token,
        address account,
        uint256 amount
    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {
        require(_checkSenderBalance(msg.sender, token, amount), ""AssetManager: balance not enough to withdraw"");

        uint256 remaining = amount;

        // If there are tokens in Asset Manager then transfer them on priority
        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));
        if (selfBalance > 0) {
            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;
            remaining -= withdrawAmount;
            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);
        }

        if (isMarketSupported(token)) {
            // iterate markets according to defined sequence and withdraw
            for (uint256 i = 0; i < withdrawSeq.length && remaining > 0; i++) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];
                if (!moneyMarket.supportsToken(token)) continue;

                uint256 supply = moneyMarket.getSupply(token);
                if (supply == 0) continue;

                uint256 withdrawAmount = supply < remaining ? supply : remaining;
                remaining -= withdrawAmount;
                moneyMarket.withdraw(token, account, withdrawAmount);
            }
        }

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;
            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;
        }

        emit LogWithdraw(token, account, amount, remaining);

        return true;
    }

    function debtWriteOff(address token, uint256 amount) external override {
        require(balances[msg.sender][token] >= amount, ""AssetManager: balance not enough"");
        balances[msg.sender][token] -= amount;
        totalPrincipal[token] -= amount;
    }

    /**
     *  @dev Add a new ERC20 token to support in AssetManager
     *  @param tokenAddress ERC20 token address
     */
    function addToken(address tokenAddress) external override onlyAdmin {
        require(!supportedMarkets[tokenAddress].isSupported, ""AssetManager: token is exist"");
        supportedTokensList.push(tokenAddress);
        supportedMarkets[tokenAddress].isSupported = true;

        approveAllMarketsMax(tokenAddress);
    }

    /**
     *  @dev For a give token set allowance for all integrated money markets
     *  @param tokenAddress ERC20 token address
     */
    function approveAllMarketsMax(address tokenAddress) public override onlyAdmin {
        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);
        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            poolToken.safeApprove(address(moneyMarkets[i]), 0);
            poolToken.safeApprove(address(moneyMarkets[i]), type(uint256).max);
        }
    }

    /**
     *  @dev Add a new adapter for the underlying lending protocol
     *  @param adapterAddress adapter address
     */
    function addAdapter(address adapterAddress) external override onlyAdmin {
        bool isExist = false;
        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            if (adapterAddress == address(moneyMarkets[i])) isExist = true;
        }

        if (!isExist) moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));

        approveAllTokensMax(adapterAddress);
    }

    function overwriteAdapters(address[] calldata adapters) external onlyAdmin {
        moneyMarkets = new IMoneyMarketAdapter[](adapters.length);
        for (uint256 i = 0; i < adapters.length; i++) {
            moneyMarkets[i] = IMoneyMarketAdapter(adapters[i]);
        }
    }

    /**
     *  @dev For a give moeny market set allowance for all underlying tokens
     *  @param adapterAddress Address of adaptor for money market
     */
    function approveAllTokensMax(address adapterAddress) public override onlyAdmin {
        for (uint256 i = 0; i < supportedTokensList.length; i++) {
            IERC20Upgradeable poolToken = IERC20Upgradeable(supportedTokensList[i]);
            poolToken.safeApprove(adapterAddress, 0);
            poolToken.safeApprove(adapterAddress, type(uint256).max);
        }
    }

    /**
     *  @dev Set withdraw sequence
     *  @param newSeq priority sequence of money market indices to be used while withdrawing
     */
    function changeWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {
        withdrawSeq = newSeq;
    }

    /**
     * @dev Take all the supply of `tokenAddress` and redistribute it according to `percentages`.
     *
     * Rejects if the token is not supported.
     *
     * @param tokenAddress Address of the token that is going to be rebalanced
     * @param percentages A list of percentages, expressed as units in 10000, indicating how to deposit the tokens in
     * each underlying money market. The length of this array is one less than the amount of money markets: the last
     * money market will receive the remaining tokens. For example, if there are 3 money markets, and you want to
     * rebalance so that the first one has 10.5% of the tokens, the second one 55%, and the third one 34.5%, this param
     * will be [1050, 5500].
     */
    function rebalance(address tokenAddress, uint256[] calldata percentages)
        external
        override
        checkMarketSupported(tokenAddress)
        onlyAdmin
    {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        require(percentages.length + 1 == moneyMarkets.length, ""AssetManager: percentages error"");

        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            moneyMarkets[i].withdrawAll(tokenAddress, address(this));
        }

        uint256 tokenSupply = token.balanceOf(address(this));

        for (uint256 i = 0; i < percentages.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;
            if (amountToDeposit == 0) {
                continue;
            }
            token.safeTransfer(address(moneyMarkets[i]), amountToDeposit);
            moneyMarkets[i].deposit(tokenAddress);
        }

        uint256 remainingTokens = token.balanceOf(address(this));
        if (moneyMarkets[moneyMarkets.length - 1].supportsToken(tokenAddress) && remainingTokens > 0) {
            token.safeTransfer(address(moneyMarkets[moneyMarkets.length - 1]), remainingTokens);
            moneyMarkets[moneyMarkets.length - 1].deposit(tokenAddress);
        }

        require(token.balanceOf(address(this)) == 0, ""AssetManager: there are remaining funds in the fund pool"");

        emit LogRebalance(tokenAddress, percentages);
    }

    /**
     *  @dev Claim the tokens left on AssetManager balance, in case there are tokens get stuck here.
     *  @param tokenAddress ERC20 token address
     *  @param recipient Recipient address
     */
    function claimTokens(address tokenAddress, address recipient) external override onlyAdmin {
        require(recipient != address(0), ""AsstManager: recipient can not be zero"");
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(recipient, balance);
    }

    /**
     *  @dev Claim the tokens stuck in the integrated adapters
     *  @param index MoneyMarkets array index
     *  @param tokenAddress ERC20 token address
     *  @param recipient Recipient address
     */
    function claimTokensFromAdapter(
        uint256 index,
        address tokenAddress,
        address recipient
    ) external override onlyAdmin {
        IMoneyMarketAdapter moneyMarket = moneyMarkets[index];
        moneyMarket.claimTokens(tokenAddress, recipient);
    }

    /**
     *  @dev Get the number of supported underlying protocols.
     *  @return MoneyMarkets length
     */
    function moneyMarketsCount() external view override returns (uint256) {
        return moneyMarkets.length;
    }

    /**
     *  @dev Get the count of supported tokens
     *  @return Number of supported tokens
     */
    function supportedTokensCount() external view override returns (uint256) {
        return supportedTokensList.length;
    }

    /**
     *  @dev Get the supported lending protocol
     *  @param tokenAddress ERC20 token address
     *  @param marketId MoneyMarkets array index
     *  @return rate tokenSupply, rate(compound is supplyRatePerBlock 1e18, aave is supplyRatePerYear 1e27)
     */
    function getMoneyMarket(address tokenAddress, uint256 marketId)
        external
        view
        override
        returns (uint256 rate, uint256 tokenSupply)
    {
        rate = moneyMarkets[marketId].getRate(tokenAddress);
        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);
    }

    function _checkSenderBalance(
        address sender,
        address tokenAddress,
        uint256 amount
    ) private view returns (bool) {
        if (_isUToken(sender, tokenAddress)) {
            // For all the lending markets, which have no deposits, return the tokens from the pool
            return getLoanableAmount(tokenAddress) >= amount;
        } else {
            return balances[sender][tokenAddress] >= amount;
        }
    }

    function _isUToken(address sender, address token) private view returns (bool) {
        (address uTokenAddress, ) = IMarketRegistry(marketRegistry).tokens(token);
        return uTokenAddress == sender;
    }

    function _isUserManager(address sender, address token) private view returns (bool) {
        (, address userManagerAddress) = IMarketRegistry(marketRegistry).tokens(token);
        return userManagerAddress == sender;
    }
}",4121.0,481.0,"[M-02] Rebalance will fail due to low precision of percentages
The `AssetManager.rebalance` function has a check at the end to ensure that all tokens are deposited again:
“require(token.balanceOf(address(this)) == 0, ""AssetManager: there are remaining funds in the fund pool”);""
The idea is that the last market deposits all `remainingTokens` but the last market does not have to support the token in which case the transaction will fail, or the `percentages` parameter needs to be chosen to distribute all tokens before the last one (they need to add up to 1e4). However, these percentages have a low precision as they are in base points, i.e, the lowest unit is `1 = 0.01%`. This will leave dust in the contract in most cases as the tokens have much higher precision.",1.0,"pragma solidity ^0.8.4;
pragma abicoder v1;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol"";
import ""@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol"";
import ""../Controller.sol"";
import ""../interfaces/IMarketRegistry.sol"";
import ""../interfaces/IMoneyMarketAdapter.sol"";
import ""../interfaces/IAssetManager.sol"";


contract AssetManager is Controller, ReentrancyGuardUpgradeable, IAssetManager {
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;

    IMoneyMarketAdapter[] public moneyMarkets;
    mapping(address => Market) public supportedMarkets;
    address[] public supportedTokensList;
    
    mapping(address => mapping(address => uint256)) public balances; 
    mapping(address => uint256) public totalPrincipal; 
    address public marketRegistry;
    
    uint256[] public withdrawSeq; 

    struct Market {
        bool isSupported;
    }

    modifier checkMarketSupported(address token) {
        require(isMarketSupported(token), ""AssetManager: token not support"");
        _;
    }

    modifier onlyAuth(address token) {
        require(
            _isUToken(msg.sender, token) || _isUserManager(msg.sender, token),
            ""AssetManager: sender must uToken or userManager""
        );
        _;
    }

    
    event LogDeposit(address indexed token, address indexed account, uint256 amount);
    
    event LogWithdraw(address indexed token, address indexed account, uint256 amount, uint256 remaining);
    
    event LogRebalance(address tokenAddress, uint256[] percentages);

    function __AssetManager_init(address _marketRegistry) public initializer {
        Controller.__Controller_init(msg.sender);
        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();
        marketRegistry = _marketRegistry;
    }

    function setMarketRegistry(address _marketRegistry) external onlyAdmin {
        marketRegistry = _marketRegistry;
    }

    
    function getPoolBalance(address tokenAddress) public view override returns (uint256) {
        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);
        uint256 balance = poolToken.balanceOf(address(this));
        if (isMarketSupported(tokenAddress)) {
            return totalSupplyView(tokenAddress) + balance;
        } else {
            return balance;
        }
    }

    
    function getLoanableAmount(address tokenAddress) public view override returns (uint256) {
        uint256 poolBalance = getPoolBalance(tokenAddress);
        if (poolBalance > totalPrincipal[tokenAddress]) return poolBalance - totalPrincipal[tokenAddress];
        return 0;
    }

    
    function totalSupply(address tokenAddress) public override returns (uint256) {
        if (isMarketSupported(tokenAddress)) {
            uint256 tokenSupply = 0;
            for (uint256 i = 0; i < moneyMarkets.length; i++) {
                if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                    continue;
                }
                tokenSupply += moneyMarkets[i].getSupply(tokenAddress);
            }

            return tokenSupply;
        } else {
            return 0;
        }
    }

    
    function totalSupplyView(address tokenAddress) public view override returns (uint256) {
        if (isMarketSupported(tokenAddress)) {
            uint256 tokenSupply = 0;
            for (uint256 i = 0; i < moneyMarkets.length; i++) {
                if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                    continue;
                }
                tokenSupply += moneyMarkets[i].getSupplyView(tokenAddress);
            }

            return tokenSupply;
        } else {
            return 0;
        }
    }

    
    function isMarketSupported(address tokenAddress) public view override returns (bool) {
        return supportedMarkets[tokenAddress].isSupported;
    }

    
    function deposit(address token, uint256 amount)
        external
        override
        whenNotPaused
        onlyAuth(token)
        nonReentrant
        returns (bool)
    {
        IERC20Upgradeable poolToken = IERC20Upgradeable(token);
        require(amount > 0, ""AssetManager: amount can not be zero"");

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] += amount;
            totalPrincipal[token] += amount;
        }

        bool remaining = true;
        if (isMarketSupported(token)) {
            
            
            
            for (uint256 i = 0; i < moneyMarkets.length && remaining; i++) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[i];

                if (!moneyMarket.supportsToken(token)) continue;
                if (moneyMarket.floorMap(token) <= moneyMarket.getSupply(token)) continue;

                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);
                moneyMarket.deposit(token);
                remaining = false;
            }

            
            
            
            
            for (uint256 j = moneyMarkets.length; j > 0 && remaining; j--) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[j - 1];
                if (!moneyMarket.supportsToken(token)) continue;

                uint256 supply = moneyMarket.getSupply(token);
                uint256 ceiling = moneyMarket.ceilingMap(token);
                if (ceiling <= supply) continue;
                if (supply + amount > ceiling) continue;

                poolToken.safeTransferFrom(msg.sender, address(moneyMarket), amount);
                moneyMarket.deposit(token);
                remaining = false;
            }
        }

        if (remaining) {
            poolToken.safeTransferFrom(msg.sender, address(this), amount);
        }

        emit LogDeposit(token, msg.sender, amount);

        return true;
    }

    
    function withdraw(
        address token,
        address account,
        uint256 amount
    ) external override whenNotPaused nonReentrant onlyAuth(token) returns (bool) {
        require(_checkSenderBalance(msg.sender, token, amount), ""AssetManager: balance not enough to withdraw"");

        uint256 remaining = amount;

        
        uint256 selfBalance = IERC20Upgradeable(token).balanceOf(address(this));
        if (selfBalance > 0) {
            uint256 withdrawAmount = selfBalance < remaining ? selfBalance : remaining;
            remaining -= withdrawAmount;
            IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);
        }

        if (isMarketSupported(token)) {
            
            for (uint256 i = 0; i < withdrawSeq.length && remaining > 0; i++) {
                IMoneyMarketAdapter moneyMarket = moneyMarkets[withdrawSeq[i]];
                if (!moneyMarket.supportsToken(token)) continue;

                uint256 supply = moneyMarket.getSupply(token);
                if (supply == 0) continue;

                uint256 withdrawAmount = supply < remaining ? supply : remaining;
                remaining -= withdrawAmount;
                moneyMarket.withdraw(token, account, withdrawAmount);
            }
        }

        if (!_isUToken(msg.sender, token)) {
            balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;
            totalPrincipal[token] = totalPrincipal[token] - amount + remaining;
        }

        emit LogWithdraw(token, account, amount, remaining);

        return true;
    }

    function debtWriteOff(address token, uint256 amount) external override {
        require(balances[msg.sender][token] >= amount, ""AssetManager: balance not enough"");
        balances[msg.sender][token] -= amount;
        totalPrincipal[token] -= amount;
    }

    
    function addToken(address tokenAddress) external override onlyAdmin {
        require(!supportedMarkets[tokenAddress].isSupported, ""AssetManager: token is exist"");
        supportedTokensList.push(tokenAddress);
        supportedMarkets[tokenAddress].isSupported = true;

        approveAllMarketsMax(tokenAddress);
    }

    
    function approveAllMarketsMax(address tokenAddress) public override onlyAdmin {
        IERC20Upgradeable poolToken = IERC20Upgradeable(tokenAddress);
        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            poolToken.safeApprove(address(moneyMarkets[i]), 0);
            poolToken.safeApprove(address(moneyMarkets[i]), type(uint256).max);
        }
    }

    
    function addAdapter(address adapterAddress) external override onlyAdmin {
        bool isExist = false;
        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            if (adapterAddress == address(moneyMarkets[i])) isExist = true;
        }

        if (!isExist) moneyMarkets.push(IMoneyMarketAdapter(adapterAddress));

        approveAllTokensMax(adapterAddress);
    }

    function overwriteAdapters(address[] calldata adapters) external onlyAdmin {
        moneyMarkets = new IMoneyMarketAdapter[](adapters.length);
        for (uint256 i = 0; i < adapters.length; i++) {
            moneyMarkets[i] = IMoneyMarketAdapter(adapters[i]);
        }
    }

    
    function approveAllTokensMax(address adapterAddress) public override onlyAdmin {
        for (uint256 i = 0; i < supportedTokensList.length; i++) {
            IERC20Upgradeable poolToken = IERC20Upgradeable(supportedTokensList[i]);
            poolToken.safeApprove(adapterAddress, 0);
            poolToken.safeApprove(adapterAddress, type(uint256).max);
        }
    }

    
    function changeWithdrawSequence(uint256[] calldata newSeq) external override onlyAdmin {
        withdrawSeq = newSeq;
    }

    
    function rebalance(address tokenAddress, uint256[] calldata percentages)
        external
        override
        checkMarketSupported(tokenAddress)
        onlyAdmin
    {
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        require(percentages.length + 1 == moneyMarkets.length, ""AssetManager: percentages error"");

        for (uint256 i = 0; i < moneyMarkets.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            moneyMarkets[i].withdrawAll(tokenAddress, address(this));
        }

        uint256 tokenSupply = token.balanceOf(address(this));

        for (uint256 i = 0; i < percentages.length; i++) {
            if (!moneyMarkets[i].supportsToken(tokenAddress)) {
                continue;
            }
            uint256 amountToDeposit = (tokenSupply * percentages[i]) / 10000;
            if (amountToDeposit == 0) {
                continue;
            }
            token.safeTransfer(address(moneyMarkets[i]), amountToDeposit);
            moneyMarkets[i].deposit(tokenAddress);
        }

        uint256 remainingTokens = token.balanceOf(address(this));
        if (moneyMarkets[moneyMarkets.length - 1].supportsToken(tokenAddress) && remainingTokens > 0) {
            token.safeTransfer(address(moneyMarkets[moneyMarkets.length - 1]), remainingTokens);
            moneyMarkets[moneyMarkets.length - 1].deposit(tokenAddress);
        }

        require(token.balanceOf(address(this)) == 0, ""AssetManager: there are remaining funds in the fund pool"");

        emit LogRebalance(tokenAddress, percentages);
    }

    
    function claimTokens(address tokenAddress, address recipient) external override onlyAdmin {
        require(recipient != address(0), ""AsstManager: recipient can not be zero"");
        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);
        uint256 balance = token.balanceOf(address(this));
        token.safeTransfer(recipient, balance);
    }

    
    function claimTokensFromAdapter(
        uint256 index,
        address tokenAddress,
        address recipient
    ) external override onlyAdmin {
        IMoneyMarketAdapter moneyMarket = moneyMarkets[index];
        moneyMarket.claimTokens(tokenAddress, recipient);
    }

    
    function moneyMarketsCount() external view override returns (uint256) {
        return moneyMarkets.length;
    }

    
    function supportedTokensCount() external view override returns (uint256) {
        return supportedTokensList.length;
    }

    
    function getMoneyMarket(address tokenAddress, uint256 marketId)
        external
        view
        override
        returns (uint256 rate, uint256 tokenSupply)
    {
        rate = moneyMarkets[marketId].getRate(tokenAddress);
        tokenSupply += moneyMarkets[marketId].getSupplyView(tokenAddress);
    }

    function _checkSenderBalance(
        address sender,
        address tokenAddress,
        uint256 amount
    ) private view returns (bool) {
        if (_isUToken(sender, tokenAddress)) {
            
            return getLoanableAmount(tokenAddress) >= amount;
        } else {
            return balances[sender][tokenAddress] >= amount;
        }
    }

    function _isUToken(address sender, address token) private view returns (bool) {
        (address uTokenAddress, ) = IMarketRegistry(marketRegistry).tokens(token);
        return uTokenAddress == sender;
    }

    function _isUserManager(address sender, address token) private view returns (bool) {
        (, address userManagerAddress) = IMarketRegistry(marketRegistry).tokens(token);
        return userManagerAddress == sender;
    }
}",2812.0,0,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Unauthorized Debt Write-Off**:  
   The `debtWriteOff` function lacks access control, allowing any user to reduce their own balance and `totalPrincipal` without authorization. Attackers can exploit this to erase their liabilities, leading to incorrect accounting and potential fund loss.

2. **Missing Token Approvals in `overwriteAdapters`**:  
   The `overwriteAdapters` function replaces the `moneyMarkets` array but fails to approve the new adapters for supported tokens. This results in failed deposits/withdrawals when interacting with the new adapters due to insufficient ERC20 allowances.

3. **Insecure `withdrawSeq` Configuration**:  
   The `withdrawSeq` array (set via `changeWithdrawSequence`) is not validated for out-of-bounds indices. If the admin configures invalid indices, withdrawals will revert, causing denial-of-service (DoS) for legitimate users.

4. **Unsafe Rebalance Percentage Handling**:  
   The `rebalance` function does not enforce that the sum of `percentages` is ≤ 10000. If the admin provides invalid percentages, arithmetic overflows/underflows could occur, though Solidity 0.8.x's checked math would revert the transaction. This could still lead to DoS during rebalancing.

5. **Inconsistent Balance Updates in `withdraw`**:  
   The `withdraw` function subtracts `amount` and adds `remaining` to `balances` and `totalPrincipal` in a single operation. While mathematically correct, this pattern risks errors in future modifications and lacks clarity, increasing the potential for unintended behavior.

6. **Reliance on Admin-Controlled Adapters**:  
   The contract assumes that all `moneyMarkets` added by the admin are secure. Malicious or buggy adapters (e.g., draining approved tokens or blocking withdrawals) could lead to fund loss, but this is an administrative trust issue rather than a code flaw.","### **[M-02] Rebalance will fail due to low precision of percentages**

**Report Description**:  
The `AssetManager.rebalance` function includes a check to ensure all tokens are deposited again:  
`require(token.balanceOf(address(this)) == 0, ""AssetManager: there are remaining funds in the fund pool"");`  
The function attempts to deposit all `remainingTokens` into the last market, but if the last market does not support the token, the transaction will fail. Additionally, the `percentages` parameter, which is in base points (1 = 0.01%), has low precision. This often leaves dust in the contract because tokens typically have much higher precision, causing the `require` check to fail in most cases.

**Match in Response List**:  
Matches with the issue titled **""Unsafe Rebalance Percentage Handling""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with the `percentages` parameter in the `rebalance` function but focuses on the risk of arithmetic overflows/underflows due to invalid percentages. While this is a valid concern, it misses the core issue described in the report: the low precision of percentages leading to dust remaining in the contract and causing the `require` check to fail. The response does not address the precision mismatch or the potential for transaction failure due to unsupported tokens in the last market. Thus, it partially covers the issue but lacks critical details.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-02] Rebalance will fail due to low precision of percentages**

**Missed Issues from Issue Report**:  
- *None*

---

### **Analysis**  
The response list partially addresses the issue but fails to fully capture the precision mismatch and its implications for the `rebalance` function. While it correctly identifies a related risk (arithmetic overflows/underflows), it does not address the core problem of dust accumulation and transaction failure due to low precision. This highlights a gap in the response's coverage of the issue.",0,1,0,6,"Okay, let's take a look at this smart contract and see what vulnerabilities I can find. I'm not very experienced, but I'll try to go through the code step by step.

First, the contract is named AssetManager and it's using OpenZeppelin upgradeable contracts. Oh wait, that might be an issue because upgradeable contracts can have proxy storage collisions if not handled properly. But maybe that's not directly a vulnerability here, just a note.

Looking at the imports, they're using ReentrancyGuardUpgradeable, which is good. The nonReentrant modifier is used in deposit and withdraw functions. That should prevent reentrancy attacks, but maybe there are other places where it's missing? Let me check.

The deposit function has the nonReentrant modifier. Withdraw also has it. So maybe that's covered. But maybe there are external calls that could be problematic. Let's see.

In the deposit function, after transferring tokens to the moneyMarket adapter, it calls moneyMarket.deposit(token). If the moneyMarket is a malicious contract, could that call back into AssetManager? But since deposit is protected by nonReentrant, maybe that's okay. But if the deposit function in the adapter is untrusted, there might be issues. However, the adapters are added by admin, so if the admin is compromised, that's a problem. But that's more of an admin trust issue.

Looking at the withdraw function. It loops through the withdrawSeq and calls moneyMarket.withdraw(token, account, withdrawAmount). Again, if the moneyMarket's withdraw function is malicious, could that lead to reentrancy? But since the withdraw function is nonReentrant, maybe that's handled. But perhaps there's a way to reenter through another function? Not sure yet.

Another thing: the withdraw function has a loop that iterates over withdrawSeq. If the withdrawSeq is not properly validated, maybe it can have indexes beyond the moneyMarkets array length. But in the changeWithdrawSequence function, the admin can set any array. So if the admin sets a sequence with indexes that don't exist, like higher than moneyMarkets.length - 1, then when withdraw is called, it will try to access moneyMarkets[invalidIndex], which would revert. But that's an admin mistake, not a vulnerability per se. Unless an attacker can manipulate the admin to set a bad sequence.

What about the rebalance function? It withdraws all tokens from each moneyMarket, then distributes them according to percentages. Let's see: it first withdraws all, then calculates tokenSupply based on balance. Then transfers amounts to each market. Wait, the percentages are applied to tokenSupply, which is the total after withdrawing all. Then, after distributing to the first percentages.length markets, the remaining tokens go to the last market. But if the sum of percentages is more than 100%, then it could cause an underflow? Let me check the code. The percentages are divided by 10000, so 10000 would be 100%. The code requires that percentages.length +1 == moneyMarkets.length. So for example, if there are 3 moneyMarkets, percentages should have 2 elements. Then the first two get (percentages[0] and percentages[1]) of the total, and the remaining goes to the third. But if the sum of percentages is more than 10000, then the first two would take more than 100%, and the third would get the remaining, which could be negative. Wait, but tokenSupply is the balance after withdrawing all, so when they calculate amountToDeposit as (tokenSupply * percentages[i]) / 10000, the sum could exceed 100%, but then remainingTokens would be tokenSupply minus sum(amountToDeposit). If the sum is more than tokenSupply, remainingTokens would underflow. But since percentages are provided by the admin, this could happen. However, Solidity 0.8.x has default overflow checks, so this would revert. So the admin must ensure the percentages sum up to <=10000. If not, the rebalance function will revert. So that's a potential issue if the admin provides incorrect percentages, but the code would revert, which is safe. So maybe not a vulnerability, just a possible admin mistake.

Another point: the deposit function has a loop over moneyMarkets. It first checks for floors, then ceilings. If a moneyMarket has a floor that's higher than the current supply, then the deposit goes there. Otherwise, it checks the ceiling. But if the moneyMarket's floor is not properly managed, maybe it could lead to funds being stuck. But that's dependent on the adapter's implementation.

Looking at the approveAllMarketsMax function, which approves the moneyMarkets to spend the tokens. The problem here is that if a moneyMarket is malicious, it could drain the tokens approved to it. But since the admin adds the adapters, this is a trust issue. If the admin adds a malicious adapter, that's a problem. But that's more of an admin privilege risk.

Another thing: in the deposit function, when remaining is true after the loops, the tokens are transferred to the AssetManager itself. So if none of the moneyMarkets can accept the deposit, the tokens stay in the contract. Then, when someone calls withdraw, those tokens can be withdrawn. But if the moneyMarkets are full, deposits might accumulate in the contract. Not sure if that's a vulnerability, but could affect functionality.

In the withdraw function, the line:

balances[msg.sender][token] = balances[msg.sender][token] - amount + remaining;

Wait, if the remaining is the amount that couldn't be withdrawn, then the user's balance is reduced by (amount - remaining). Because the original amount is subtracted, and then remaining is added back. For example, if amount is 100 and remaining is 20, then balance is balance -100 +20 = balance -80. That's correct because 80 was actually withdrawn. But the syntax here is a bit confusing. However, the math seems correct.

What about the debtWriteOff function? It subtracts from balances and totalPrincipal. But there's no check that msg.sender is allowed to do this. The function is external, but there's no modifier. Wait, the function is declared as:

function debtWriteOff(address token, uint256 amount) external override {

But there's no modifier. So any user can call this function and reduce their own balance and totalPrincipal. Wait, but the require statement checks that balances[msg.sender][token] >= amount. So a user can call this function to reduce their balance. But why would they do that? This seems like a privilege escalation. For example, if a user has a balance, they can call debtWriteOff to reduce it, possibly avoiding liabilities. This is a vulnerability because it allows anyone to write off their own debts without authorization. The function should have a modifier to restrict access, like onlyAuth(token) or similar. Since the function is part of the IAssetManager interface, maybe it's intended to be called by the UserManager or uToken, but as written, anyone can call it. That's a critical issue.

Another vulnerability: in the addToken function, when adding a new token, it calls approveAllMarketsMax, which approves all existing moneyMarkets for the new token. However, if a new moneyMarket is added later, it won't have approval unless approveAllMarketsMax is called again. But in the addAdapter function, after adding a new moneyMarket, approveAllTokensMax is called, which approves the new adapter for all existing tokens. Wait, no: in addAdapter, after adding the new adapter to moneyMarkets, it calls approveAllTokensMax(adapterAddress), which for each supported token, approves the new adapter. So that's okay. But when a new token is added via addToken, approveAllMarketsMax is called, which for each existing moneyMarket, approves the token. So when a new token is added, existing adapters are approved. When a new adapter is added, existing tokens are approved. So that should be okay. But maybe if a token is added and then an adapter is added later, the new adapter isn't approved for the existing token. Wait, no: when a new adapter is added, approveAllTokensMax is called, which loops through all supportedTokensList and approves the new adapter for each. So that should handle it.

What about the overwriteAdapters function? It replaces the entire moneyMarkets array with new adapters. But after doing so, are the approvals set correctly? Because overwriteAdapters doesn't call approveAllTokensMax for the new adapters. So if the admin overwrites the adapters, the new adapters may not have approvals for the supported tokens. This would mean that deposits to those new adapters would fail because the AssetManager hasn't approved the adapters to spend its tokens. So this is a vulnerability because the overwriteAdapters function doesn't set the necessary approvals, leading to possible failures in deposit and rebalance functions. The function should loop through the new adapters and call approveAllTokensMax for each, but it doesn't. So this is an issue.

Another thing: the withdrawSeq array is set by the admin. If the admin sets an invalid sequence (e.g., indexes that don't exist in moneyMarkets), then during withdrawal, the contract would try to access moneyMarkets[withdrawSeq[i]], which could be out of bounds, causing a revert. But since the admin controls this, it's a potential denial of service if the sequence is incorrect. However, this is an admin mistake rather than a vulnerability, unless an attacker can manipulate the admin.

In the rebalance function, after withdrawing all tokens, it redistributes based on percentages. But if during the deposit phase, a moneyMarket's deposit fails (e.g., due to a ceiling), the tokens would remain in the AssetManager. The code requires that after redistribution, the AssetManager's balance is zero. If a deposit fails, the remainingTokens would be transferred to the last moneyMarket. But if that also fails, then the require at the end would fail, reverting the transaction. So the function is safe in that case. However, if a moneyMarket's deposit function doesn't consume all the tokens sent to it (e.g., due to fees or other deductions), the AssetManager's balance could be non-zero, causing the require to fail. That could be a problem if the moneyMarket adapter doesn't handle deposits correctly.

Looking at the getLoanableAmount function: it returns poolBalance - totalPrincipal if poolBalance > totalPrincipal. But poolBalance is totalSupplyView(tokenAddress) + balance of the contract. However, totalPrincipal is the sum of balances from non-uToken senders. The uToken's deposits are not counted in totalPrincipal. So when calculating loanable amount, it's possible that the actual available funds are different. For example, if uToken deposits are part of the poolBalance but not part of totalPrincipal, then loanableAmount could include those funds. But since uToken is allowed to withdraw based on loanableAmount, maybe that's intended. Not sure if that's a vulnerability, but maybe a design choice.

Another issue: the AssetManager uses the checkMarketSupported modifier in some functions, but for example, in deposit, after checking the token is supported, but when remaining is true (i.e., couldn't deposit into any moneyMarket), the tokens are sent to the contract itself. However, if the token is not supported, the deposit would have reverted. So that's okay.

Wait, in deposit, the code checks if the token is supported. If not, then the else path just transfers the tokens to the contract. But the deposit function has the checkMarketSupported modifier via onlyAuth? Wait, no: the deposit function's modifiers are whenNotPaused, onlyAuth(token), nonReentrant. The checkMarketSupported modifier is not present here. Wait, looking at the deposit function:

modifier onlyAuth(address token) {
    require(
        _isUToken(msg.sender, token) || _isUserManager(msg.sender, token),
        ""AssetManager: sender must uToken or userManager""
    );
    _;
}

So the deposit function is onlyAuth(token), which checks if the sender is uToken or UserManager for that token. But the token itself could be unsupported. Wait, the code in deposit says:

if (isMarketSupported(token)) {
    // do the money market deposits
} else {
    // transfer to self
}

But the function doesn't have a modifier that checks if the market is supported. So it's possible to deposit into a token that is not supported. However, the onlyAuth modifier would require that the sender is the uToken or UserManager for that token. Which would be set in the MarketRegistry. So even if the token is not supported, but the sender is authorized, they can deposit, which would send the tokens to the contract (since the market is not supported). But when the token is not supported, the totalSupply and totalSupplyView functions return 0, so getPoolBalance would include the contract's balance. But the getLoanableAmount would subtract totalPrincipal, which for a non-supported token, the totalPrincipal is tracked only if the sender is not uToken. Wait, in deposit, if the sender is not uToken (i.e., UserManager), then balances and totalPrincipal are updated. But for a non-supported token, those balances are still tracked, but the moneyMarkets aren't used. So maybe that's allowed. However, allowing deposits into unsupported tokens could lead to funds being stuck in the contract, as they can't be deployed to moneyMarkets. But since the onlyAuth modifier restricts who can deposit, maybe that's intentional. Not sure if that's a vulnerability, but possibly a misconfiguration issue.

Another thing: the initializer function __AssetManager_init is public. But in OpenZeppelin's upgradeable contracts, the initializer should be called only once. However, since the function uses the initializer modifier, that's handled. But if someone else calls it again, it would fail because of the initializer modifier. So that's okay.

In the withdraw function, the line:

IERC20Upgradeable(token).safeTransfer(account, withdrawAmount);

But if the token is a contract that doesn't return a boolean on transfer (like some old ERC20 tokens), the safeTransfer would fail. However, since the contract is using SafeERC20Upgradeable which is designed for ERC20s that return booleans, this could be an issue if interacting with non-compliant tokens. But the code uses IERC20Upgradeable from OpenZeppelin, which assumes compliant tokens. So if a non-supported token (e.g., non-ERC20) is added, this would cause failures. But that's more of an integration issue.

In the rebalance function, after withdrawing all tokens from the moneyMarkets, it's possible that some adapters don't return all the tokens (e.g., due to fees or interest mechanisms). This could lead to an inconsistency in the tokenSupply calculation. For example, if an adapter's withdrawAll function doesn't actually return all tokens, the remaining balance in the AssetManager would be less than expected, causing the redistribution to not account for the lost tokens. But this depends on the adapter's implementation.

The debtWriteOff function allows any user to reduce their own balance and totalPrincipal without any authorization beyond having a sufficient balance. This is a critical vulnerability because users can maliciously reduce their debt without any consequences. For example, a user who has a balance of 1000 tokens can call debtWriteOff with 1000, setting their balance to 0, even if they haven't actually repaid the debt. This breaks the accounting system and allows users to erase their liabilities.

Another possible issue is that the moneyMarkets array can be modified by the admin via addAdapter and overwriteAdapters. If a malicious or buggy adapter is added, it could lead to loss of funds. But since the admin is a privileged account, this is more of an administrative risk rather than a code vulnerability.

In the withdraw function, after transferring from the contract's balance, it loops through the withdrawSeq. If the withdrawSeq is not properly ordered, it might withdraw from less optimal markets first, leading to inefficiencies but not necessarily a vulnerability.

The AssetManager contract also inherits from Controller, which has an onlyAdmin modifier. If the admin account is compromised, the attacker can perform critical actions like adding/removing adapters, changing withdraw sequences, etc., leading to potential fund theft. But again, this is an admin key compromise issue rather than a code flaw.

Another thing to note is the use of the SafeERC20Upgradeable library for safe transfers and approvals. This should prevent some common ERC20 issues, like transfers that don't return a boolean.

In summary, the main vulnerabilities I can identify are:

1. **Unauthorized Debt Write-Off**: The debtWriteOff function allows any user to reduce their own balance without proper authorization, leading to loss of funds or incorrect accounting.

2. **Missing Approvals in overwriteAdapters**: The overwriteAdapters function replaces the moneyMarkets array but doesn't approve the new adapters for the supported tokens, leading to failed deposits or transfers when interacting with these new adapters.

3. **Incorrect Withdraw Sequence Handling**: If the withdrawSeq contains invalid indices, withdrawals could revert, causing denial of service. However, this depends on admin configuration.

4. **Rebalance Percentage Validation**: The rebalance function doesn't validate that the sum of percentages is <= 10000, which could lead to an underflow if not properly handled. However, Solidity's checked math would revert, making it a potential DoS if the admin provides invalid percentages.

But according to the problem statement, we don't need to provide mitigations, just list the vulnerabilities. So focusing on the clear vulnerabilities:

- Unauthorized access to debtWriteOff.
- Missing token approvals when overwriting adapters.","```
None.
```",0.0
,,,,,,,,2,2,,,1,1,2,21,,,
