nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
LongShort.sol,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/ITokenFactory.sol"";
import ""./interfaces/ISyntheticToken.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IYieldManager.sol"";
import ""./interfaces/IOracleManager.sol"";

/**
 **** visit https://float.capital *****
 */

/// @title Core logic of Float Protocal markets
/// @author float.capital
/// @notice visit https://float.capital for more info
/// @dev All functions in this file are currently `virtual`. This is NOT to encourage inheritance.
/// It is merely for convenince when unit testing.
/// @custom:auditors This contract balances long and short sides.
contract LongShort is ILongShort, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  /// @notice this is the address that permanently locked initial liquidity for markets is held by.
  /// These tokens will never move so market can never have zero liquidity on a side.
  /// @dev f10a7 spells float in hex - for fun - important part is that the private key for this address in not known.
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  /// @dev an empty allocation of storage for use in future upgrades - inspiration from OZ:
  ///      https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/10f0f1a95b1b0fd5520351886bae7a03490f1056/contracts/token/ERC20/ERC20Upgradeable.sol#L361
  uint256[45] private __constantsGap;

  /* ══════ Global state ══════ */
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  /* ══════ Market specific ══════ */
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  /* ══════ Market + position (long/short) specific ══════ */
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  /// @notice synthetic token prices of a given market of a (long/short) at every previous price update
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, ""only admin"");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], ""market doesn't exist"");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /// @notice Initializes the contract.
  /// @dev Calls OpenZeppelin's initializer modifier.
  /// @param _admin Address of the admin role.
  /// @param _treasury Address of the treasury.
  /// @param _tokenFactory Address of the contract which creates synthetic asset tokens.
  /// @param _staker Address of the contract which handles synthetic asset stakes.
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /// @notice Changes the admin address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _admin Address of the new admin.
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }

  /// @notice Changes the treasury contract address for this contract.
  /// @dev Can only be called by the current admin.
  /// @param _treasury Address of the treasury contract
  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }

  /// @notice Update oracle for a market
  /// @dev Can only be called by the current admin.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param _newOracleManager Address of the replacement oracle manager.
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    // If not a oracle contract this would break things.. Test's arn't validating this
    // Ie require isOracle interface - ERC165
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  /// @notice changes the gradient of the line for determining the yield split between market and treasury.
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  /*╔═════════════════════════════╗
    ║       MARKET CREATION       ║
    ╚═════════════════════════════╝*/

  /// @notice Creates an entirely new long/short market tracking an underlying oracle price.
  ///  Make sure the synthetic names/symbols are unique.
  /// @dev This does not make the market active.
  /// The `initializeMarket` function was split out separately to this function to reduce costs.
  /// @param syntheticName Name of the synthetic asset
  /// @param syntheticSymbol Symbol for the synthetic asset
  /// @param _paymentToken The address of the erc20 token used to buy this synthetic asset
  /// this will likely always be DAI
  /// @param _oracleManager The address of the oracle manager that provides the price feed for this market
  /// @param _yieldManager The contract that manages depositing the paymentToken into a yield bearing protocol
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    // Create new synthetic long token.
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Up "", syntheticName)),
      string(abi.encodePacked(""fu"", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    // Create new synthetic short token.
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Down "", syntheticName)),
      string(abi.encodePacked(""fd"", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    // Initial market state.
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  /// @notice Seeds a new market with initial capital.
  /// @dev Only called when initializing a market.
  /// @param initialMarketSeedForEachMarketSide Amount in wei for which to seed both sides of the market.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      // You require at least 1e18 (1 payment token with 18 decimal places) of the underlying payment token to seed the market.
      initialMarketSeedForEachMarketSide >= 1e18,
      ""Insufficient market seed""
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  /// @notice Sets a market as active once it has already been setup by createNewSyntheticMarket.
  /// @dev Seperated from createNewSyntheticMarket due to gas considerations.
  /// @param marketIndex An int32 which uniquely identifies the market.
  /// @param kInitialMultiplier Linearly decreasing multiplier for Float token issuance for the market when staking synths.
  /// @param kPeriod Time which kInitialMultiplier will last
  /// @param unstakeFee_e18 Base 1e18 percentage fee levied when unstaking for the market.
  /// @param balanceIncentiveCurve_exponent Sets the degree to which Float token issuance differs
  /// for market sides in unbalanced markets. See Staker.sol
  /// @param balanceIncentiveCurve_equilibriumOffset An offset to account for naturally imbalanced markets
  /// when Float token issuance should differ for market sides. See Staker.sol
  /// @param initialMarketSeedForEachMarketSide Amount of payment token that will be deposited in each market side to seed the market.
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], ""already initialized"");
    require(marketIndex <= latestMarket, ""index too high"");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    marketUpdateIndex[marketIndex] = 1;

    // Add new staker funds with fresh synthetic tokens.
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  /*╔══════════════════════════════╗
    ║       GETTER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice Return the minimum of the 2 parameters. If they are equal return the first parameter.
  /// @param a Any uint256
  /// @param b Any uint256
  /// @return min The minimum of the 2 parameters.
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  /// @notice Calculates the conversion rate from synthetic tokens to payment tokens.
  /// @dev Synth tokens have a fixed 18 decimals.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @return syntheticTokenPrice The calculated conversion rate in base 1e18.
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  /// @notice Converts synth token amounts to payment token amounts at a synth token price.
  /// @dev Price assumed base 1e18.
  /// @param amountSyntheticToken Amount of synth token in wei.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountPaymentToken The calculated amount of payment tokens in token's lowest denomination.
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  /// @notice Converts payment token amounts to synth token amounts at a synth token price.
  /// @dev  Price assumed base 1e18.
  /// @param amountPaymentTokenBackingSynth Amount of payment tokens in that token's lowest denomination.
  /// @param syntheticTokenPriceInPaymentTokens The conversion rate from synth to payment tokens in base 1e18.
  /// @return amountSyntheticToken The calculated amount of synthetic token in wei.
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  /**
  @notice Calculate the amount of target side synthetic tokens that are worth the same
          amount of payment tokens as X many synthetic tokens on origin side.
          The resulting equation comes from simplifying this function

            _getAmountSyntheticToken(
              _getAmountPaymentToken(
                amountOriginSynth,
                priceOriginSynth
              ),
              priceTargetSynth)

            Unpacking the function we get:
            ((amountOriginSynth * priceOriginSynth) / 1e18) * 1e18 / priceTargetSynth
              And simplifying this we get:
            (amountOriginSynth * priceOriginSynth) / priceTargetSynth
  @param amountSyntheticTokens_originSide Amount of synthetic tokens on origin side
  @param syntheticTokenPrice_originSide Price of origin side's synthetic token
  @param syntheticTokenPrice_targetSide Price of target side's synthetic token
  @return equivalentAmountSyntheticTokensOnTargetSide Amount of synthetic token on target side
  */
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  /// @notice Given an executed next price shift from tokens on one market side to the other,
  /// determines how many other side tokens the shift was worth.
  /// @dev Intended for use primarily by Staker.sol
  /// @param marketIndex An uint32 which uniquely identifies a market.
  /// @param amountSyntheticToken_redeemOnOriginSide Amount of synth token in wei.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  /// @param priceSnapshotIndex Index which identifies which synth prices to use.
  /// @return amountSyntheticTokensToMintOnTargetSide The amount in wei of tokens for the other side that the shift was worth.
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  /**
  @notice The amount of a synth token a user is owed following a batch execution.
    4 possible states for next price actions:
        - ""Pending"" - means the next price update hasn't happened or been enacted on by the updateSystemState function.
        - ""Confirmed"" - means the next price has been updated by the updateSystemState function. There is still
        -               outstanding (lazy) computation that needs to be executed per user in the batch.
        - ""Settled"" - there is no more computation left for the user.
        - ""Non-existant"" - user has no next price actions.
    This function returns a calculated value only in the case of 'confirmed' next price actions.
    It should return zero for all other types of next price actions.
  @dev Used in SyntheticToken.sol balanceOf to allow for automatic reflection of next price actions.
  @param user The address of the user for whom to execute the function for.
  @param marketIndex An int32 which uniquely identifies a market.
  @param isLong Whether it is for the long synthetic asset or the short synthetic asset.
  @return confirmedButNotSettledBalance The amount in wei of tokens that the user is owed.
  */
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  /**
   @notice Calculates the percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   @dev For gas considerations also returns whether the long side is imbalanced.
   @dev For gas considerations totalValueLockedInMarket is passed as a parameter as the function
   calling this function has pre calculated the value
   @param longValue The current total payment token value of the long side of the market.
   @param shortValue The current total payment token value of the short side of the market.
   @param totalValueLockedInMarket Total payment token value of both sides of the market.
   @return isLongSideUnderbalanced Whether the long side initially had less value than the short side.
   @return treasuryYieldPercent_e18 The percentage in base 1e18 of how much of the accrued yield
   for a market should be allocated to treasury.
   */
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    // marketTreasurySplitGradient_e18 may be adjusted to ensure yield is given
    // to the market at a desired rate e.g. if a market tends to become imbalanced
    // frequently then the gradient can be increased to funnel yield to the market
    // quicker.
    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmXsW4cHtxpJ5BFwRcMSUw7s5G11Qkte13NTEfPLTKEx4x
    // Interact with this equation: https://www.desmos.com/calculator/pnl43tfv5b
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  /*╔══════════════════════════════╗
    ║       HELPER FUNCTIONS       ║
    ╚══════════════════════════════╝*/

  /// @notice First gets yield from the yield manager and allocates it to market and treasury.
  /// It then allocates the full market yield portion to the underbalanced side of the market.
  /// NB this function also adjusts the value of the long and short side based on the latest
  /// price of the underlying asset received from the oracle. This function should ideally be
  /// called everytime there is an price update from the oracle. We have built a bot that does this.
  /// The system is still perectly safe if not called every price update, the synthetic will just
  /// less closely track the underlying asset.
  /// @dev In one function as yield should be allocated before rebalancing.
  /// This prevents an attack whereby the user imbalances a side to capture all accrued yield.
  /// @param marketIndex The market for which to execute the function for.
  /// @param newAssetPrice The new asset price.
  /// @param oldAssetPrice The old asset price.
  /// @return longValue The value of the long side after rebalancing.
  /// @return shortValue The value of the short side after rebalancing.
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    // Claiming and distributing the yield
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    // Adjusting value of long and short pool based on price movement
    // The side/position with less liquidity has 100% percent exposure to the price movement.
    // The side/position with more liquidity will have exposure < 100% to the price movement.
    // I.e. Imagine $100 in longValue and $50 shortValue
    // long side would have $50/$100 = 50% exposure to price movements based on the liquidity imbalance.
    // min(longValue, shortValue) = $50 , therefore if the price change was -10% then
    // $50 * 10% = $5 gained for short side and conversely $5 lost for long side.
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    // See this equation in latex: https://gateway.pinata.cloud/ipfs/QmPeJ3SZdn1GfxqCD4GDYyWTJGPMSHkjPJaxrzk2qTTPSE
    // Interact with this equation: https://www.desmos.com/calculator/t8gr6j5vsq
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  /*╔═══════════════════════════════╗
    ║     UPDATING SYSTEM STATE     ║
    ╚═══════════════════════════════╝*/

  /// @notice Updates the value of the long and short sides to account for latest oracle price updates
  /// and batches all next price actions.
  /// @dev To prevent front-running only executes on price change from an oracle.
  /// We assume the function will be called for each market at least once per price update.
  /// Note Even if not called on every price update, this won't affect security, it will only affect how closely
  /// the synthetic asset actually tracks the underlying asset.
  /// @param marketIndex The market index for which to update.
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    // If a negative int is return this should fail.
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      // if there is a price change and the 'staker' contract has pending updates, push the stakers price snapshot index to the staker
      // (so the staker can handle its internal accounting)
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          // This variable could allow users to do any next price actions in the future (not just synthetic side shifts)
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      // function will return here if the staker called this simply for the
      // purpose of adding a state point required in staker.sol for our rewards calculation
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  /// @notice Updates the state of a market to account for the latest oracle price update.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  /// @notice Updates the state of multiples markets to account for their latest oracle price updates.
  /// @param marketIndexes An array of int32s which uniquely identify markets.
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  /*╔════════════════════════════════╗
    ║           DEPOSIT              ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers payment tokens for a market from msg.sender to this contract.
  /// @dev Tokens are transferred directly to this contract to be deposited by the yield manager in the batch to earn yield.
  ///      Since we check the return value of the transferFrom method, all payment tokens we use must conform to the ERC20 standard.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationto deposit.
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  /*╔═══════════════════════════╗
    ║       MINT POSITION       ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to mint synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @dev Called by external functions to mint either long or short. If a user mints multiple times before a price update, these are treated as a single mint.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  /// @param isLong Whether the mint is for a long or short synth.
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice Allows users to mint long synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  /// @notice Allows users to mint short synthetic assets for a market. To prevent front-running these mints are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amount Amount of payment tokens in that token's lowest denominationfor which to mint synthetic assets at next price.
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  /*╔═══════════════════════════╗
    ║      REDEEM POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice Allows users to redeem their synthetic tokens for payment tokens. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @dev Called by external functions to redeem either long or short. Payment tokens are actually transferred to the user when executeOutstandingNextPriceSettlements is called from a function call by the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem.
  /// @param isLong Whether this redeem is for a long or short synth.
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  /// @notice  Allows users to redeem long synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  /// @notice  Allows users to redeem short synthetic assets for a market. To prevent front-running these redeems are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param tokens_redeem Amount in wei of synth tokens to redeem at the next oracle price.
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  /*╔═══════════════════════════╗
    ║       SHIFT POSITION      ║
    ╚═══════════════════════════╝*/

  /// @notice  Allows users to shift their position from one side of the market to the other in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @dev Called by external functions to shift either way. Intended for primary use by Staker.sol
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the one side to the other at the next oracle price update.
  /// @param isShiftFromLong Whether the token shift is from long to short (true), or short to long (false).
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  /// @notice Allows users to shift their position from long to short in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from long to short the next oracle price update.
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  /// @notice Allows users to shift their position from short to long in a single transaction. To prevent front-running these shifts are executed on the next price update from the oracle.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param amountSyntheticTokensToShift Amount in wei of synthetic tokens to shift from the short to long at the next oracle price update.
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  /*╔════════════════════════════════╗
    ║     NEXT PRICE SETTLEMENTS     ║
    ╚════════════════════════════════╝*/

  /// @notice Transfers outstanding synth tokens from a next price mint to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  /// @notice Transfers outstanding payment tokens from a next price redemption to the user.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isLong Whether this is for the long or short synth for the market.
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  /// @notice Transfers outstanding synth tokens from a next price position shift to the user.
  /// @dev The outstanding synths should already be reflected for the user due to balanceOf in SyntheticToken.sol, this just does the accounting.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param user The address of the user for whom to execute the function for.
  /// @param isShiftFromLong Whether the token shift was from long to short (true), or short to long (false).
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @dev Once the market has updated for the next price, should be guaranteed (through modifiers) to execute for a user before user initiation of new next price actions.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  /// @notice After markets have been batched updated on a new oracle price, transfers any owed tokens to a user from their next price actions for that update to that user.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndex An int32 which uniquely identifies a market.
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  /// @notice Executes outstanding next price settlements for a user for multiple markets.
  /// @param user The address of the user for whom to execute the function for.
  /// @param marketIndexes An array of int32s which each uniquely identify a market.
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  /*╔═══════════════════════════════════════════╗
    ║   BATCHED NEXT PRICE SETTLEMENT ACTIONS   ║
    ╚═══════════════════════════════════════════╝*/

  /// @notice Either transfers funds from the yield manager to this contract if redeems > deposits,
  /// and visa versa. The yield manager handles depositing and withdrawing the funds from a yield market.
  /// @dev When all batched next price actions are handled the total value in the market can either increase or decrease based on the value of mints and redeems.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param totalPaymentTokenValueChangeForMarket An int256 which indicates the magnitude and direction of the change in market value.
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      // NB there will be issues here if not enough liquidity exists to withdraw
      // Boolean should be returned from yield manager and think how to appropriately handle this
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  /// @notice Given a desired change in synth token supply, either mints or burns tokens to achieve that desired change.
  /// @dev When all batched next price actions are executed total supply for a synth can either increase or decrease.
  /// @param marketIndex An int32 which uniquely identifies a market.
  /// @param isLong Whether this function should execute for the long or short synth for the market.
  /// @param changeInSyntheticTokensTotalSupply The amount in wei by which synth token supply should change.
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  /**
  @notice Performs all batched next price actions on an oracle price update.
  @dev Mints or burns all synthetic tokens for this contract.

    After this function is executed all user actions in that batch are confirmed and can be settled individually by
      calling _executeOutstandingNexPriceSettlements for a given user.

    The maths here is safe from rounding errors since it always over estimates on the batch with division.
      (as an example (5/3) + (5/3) = 2 but (5+5)/3 = 10/3 = 3, so the batched action would mint one more)
  @param marketIndex An int32 which uniquely identifies a market.
  @param syntheticTokenPrice_inPaymentTokens_long The long synthetic token price for this oracle price update.
  @param syntheticTokenPrice_inPaymentTokens_short The short synthetic token price for this oracle price update.
  @return long_changeInMarketValue_inPaymentToken The total value change for the long side after all batched actions are executed.
  @return short_changeInMarketValue_inPaymentToken The total value change for the short side after all batched actions are executed.
  */
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    // NOTE: the only reason we are re-uising amountForCurrentAction_workingVariable for all actions (redeemLong, redeemShort, mintLong, mintShort, shiftFromLong, shiftFromShort) is to reduce stack usage
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    // Handle batched deposits LONG
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    // Handle batched deposits SHORT
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    // Handle shift tokens from LONG to SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle shift tokens from SHORT to LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    // Handle batched redeems LONG
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    // Handle batched redeems SHORT
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    // Batch settle payment tokens
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    // Batch settle synthetic tokens
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}",13680.0,1243.0,"[H-01] copy paste error in `_batchConfirmOutstandingPendingActions`
The function `_batchConfirmOutstandingPendingActions` of `LongShort.sol` processes the variable `batched_amountSyntheticToken_toShiftAwayFrom_marketSide`, and sets it to 0 after processing. However, probably due to a copy/paste error, in the second instance, where `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed, the wrong version is set to 0: `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]` = 0
This means the next time the `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed again. As it is never reset, it keeps increasing. The result is that the internal administration will be off and far too many tokens will be shifted tokens from SHORT to LONG.
  [M-01] `latestMarket` used where `marketIndex` should have been used The functions `initializeMarket` and `_seedMarketInitially` use the variable `latestMarket`. If these functions would be called seperately from `createNewSyntheticMarket`, then `latestMarket` would have the same value for each call of initializeMarket and `_seedMarketInitially`
This would mean that the `latestMarket` is initialized multiple times and the previous market(s) are not initialized properly. Note: the call to addNewStakingFund could have prevented this issue, but also allows this, see separate issue.
Note: the functions can only be called by the admin, so if `createNewSyntheticMarket` and `initializeMarket` are called in combination, then it would not lead to problems, but in future release of the software the calls to createNewSyntheticMarket and initializeMarket might get separated.   [M-06] Prevent markets getting stuck when prices don't move Suppose there is a synthetic token where the price stays constant, for example:
- synthetic DAI (with a payment token of DAI the price will not move)
- binary option token (for example tracking the USA elections; after the election results there will be no more price movements)
In that case `assetPriceHasChanged` will never be true (again) and `marketUpdateIndex[marketIndex]` will never increase. This means the _executeOutstandingNextPrice* functions will never be executed, which means the market effectively will be stuck. LongShort.sol L669
`_updateSystemStateInternal`(uint32 marketIndex) internal virtual requireMarketExists(marketIndex)`",3.0,"pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol"";
import ""@openzeppelin/contracts/token/ERC20/IERC20.sol"";

import ""./interfaces/ITokenFactory.sol"";
import ""./interfaces/ISyntheticToken.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IYieldManager.sol"";
import ""./interfaces/IOracleManager.sol"";


contract LongShort is ILongShort, Initializable {
  
  address public constant PERMANENT_INITIAL_LIQUIDITY_HOLDER = 0xf10A7_F10A7_f10A7_F10a7_F10A7_f10a7_F10A7_f10a7;

  uint256[45] private __constantsGap;

  
  address public admin;
  address public treasury;
  uint32 public latestMarket;

  address public staker;
  address public tokenFactory;
  uint256[45] private __globalStateGap;

  
  mapping(uint32 => bool) public marketExists;
  mapping(uint32 => uint256) public assetPrice;
  mapping(uint32 => uint256) public marketUpdateIndex;
  mapping(uint32 => address) public paymentTokens;
  mapping(uint32 => address) public yieldManagers;
  mapping(uint32 => address) public oracleManagers;
  mapping(uint32 => uint256) public marketTreasurySplitGradient_e18;

  
  mapping(uint32 => mapping(bool => address)) public syntheticTokens;
  mapping(uint32 => mapping(bool => uint256)) public marketSideValueInPaymentToken;

  
  mapping(uint32 => mapping(bool => mapping(uint256 => uint256))) public syntheticToken_priceSnapshot;

  mapping(uint32 => mapping(bool => uint256)) public batched_amountPaymentToken_deposit;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_redeem;
  mapping(uint32 => mapping(bool => uint256)) public batched_amountSyntheticToken_toShiftAwayFrom_marketSide;

  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_currentUpdateIndex;

  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_paymentToken_depositAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256))) public userNextPrice_syntheticToken_redeemAmount;
  mapping(uint32 => mapping(bool => mapping(address => uint256)))
    public userNextPrice_syntheticToken_toShiftAwayFrom_marketSide;

  

  event LongShortV1(address admin, address treasury, address tokenFactory, address staker);

  event SystemStateUpdated(
    uint32 marketIndex,
    uint256 updateIndex,
    int256 underlyingAssetPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 longPrice,
    uint256 shortPrice
  );

  event SyntheticMarketCreated(
    uint32 marketIndex,
    address longTokenAddress,
    address shortTokenAddress,
    address paymentToken,
    uint256 initialAssetPrice,
    string name,
    string symbol,
    address oracleAddress,
    address yieldManagerAddress
  );

  event NextPriceRedeem(
    uint32 marketIndex,
    bool isLong,
    uint256 synthRedeemed,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceSyntheticPositionShift(
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 synthShifted,
    address user,
    uint256 oracleUpdateIndex
  );

  event NextPriceDeposit(
    uint32 marketIndex,
    bool isLong,
    uint256 depositAdded,
    address user,
    uint256 oracleUpdateIndex
  );

  event OracleUpdated(uint32 marketIndex, address oldOracleAddress, address newOracleAddress);

  event NewMarketLaunchedAndSeeded(uint32 marketIndex, uint256 initialSeed);

  event ExecuteNextPriceMintSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceRedeemSettlementUser(address user, uint32 marketIndex, bool isLong, uint256 amount);

  event ExecuteNextPriceMarketSideShiftSettlementUser(
    address user,
    uint32 marketIndex,
    bool isShiftFromLong,
    uint256 amount
  );

  event ExecuteNextPriceSettlementsUser(address user, uint32 marketIndex);


  function adminOnlyModifierLogic() internal virtual {
    require(msg.sender == admin, ""only admin"");
  }

  modifier adminOnly() {
    adminOnlyModifierLogic();
    _;
  }

  function requireMarketExistsModifierLogic(uint32 marketIndex) internal view virtual {
    require(marketExists[marketIndex], ""market doesn't exist"");
  }

  modifier requireMarketExists(uint32 marketIndex) {
    requireMarketExistsModifierLogic(marketIndex);
    _;
  }

  modifier executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
    _;
  }

  modifier updateSystemStateMarket(uint32 marketIndex) {
    _updateSystemStateInternal(marketIndex);
    _;
  }
  
  function initialize(
    address _admin,
    address _treasury,
    address _tokenFactory,
    address _staker
  ) external virtual initializer {
    admin = _admin;
    treasury = _treasury;
    tokenFactory = _tokenFactory;
    staker = _staker;

    emit LongShortV1(_admin, _treasury, _tokenFactory, _staker);
  }


  
  function changeAdmin(address _admin) external adminOnly {
    admin = _admin;
  }


  function changeTreasury(address _treasury) external adminOnly {
    treasury = _treasury;
  }


  
  function updateMarketOracle(uint32 marketIndex, address _newOracleManager) external adminOnly {
    
    
    address previousOracleManager = oracleManagers[marketIndex];
    oracleManagers[marketIndex] = _newOracleManager;
    emit OracleUpdated(marketIndex, previousOracleManager, _newOracleManager);
  }

  
  function changeMarketTreasurySplitGradient(uint32 marketIndex, uint256 _marketTreasurySplitGradient_e18)
    external
    adminOnly
  {
    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;
  }

  

  
  
  
  
  
  
  
  
  
  
  function createNewSyntheticMarket(
    string calldata syntheticName,
    string calldata syntheticSymbol,
    address _paymentToken,
    address _oracleManager,
    address _yieldManager
  ) external adminOnly {
    latestMarket++;

    
    syntheticTokens[latestMarket][true] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Up "", syntheticName)),
      string(abi.encodePacked(""fu"", syntheticSymbol)),
      staker,
      latestMarket,
      true
    );

    
    syntheticTokens[latestMarket][false] = ITokenFactory(tokenFactory).createSyntheticToken(
      string(abi.encodePacked(""Float Down "", syntheticName)),
      string(abi.encodePacked(""fd"", syntheticSymbol)),
      staker,
      latestMarket,
      false
    );

    
    paymentTokens[latestMarket] = _paymentToken;
    yieldManagers[latestMarket] = _yieldManager;
    oracleManagers[latestMarket] = _oracleManager;
    assetPrice[latestMarket] = uint256(IOracleManager(oracleManagers[latestMarket]).updatePrice());

    emit SyntheticMarketCreated(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      _paymentToken,
      assetPrice[latestMarket],
      syntheticName,
      syntheticSymbol,
      _oracleManager,
      _yieldManager
    );
  }

  
  
  
  
  function _seedMarketInitially(uint256 initialMarketSeedForEachMarketSide, uint32 marketIndex) internal virtual {
    require(
      
      initialMarketSeedForEachMarketSide >= 1e18,
      ""Insufficient market seed""
    );

    uint256 amountToLockInYieldManager = initialMarketSeedForEachMarketSide * 2;
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amountToLockInYieldManager);
    IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(amountToLockInYieldManager);

    ISyntheticToken(syntheticTokens[latestMarket][true]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );
    ISyntheticToken(syntheticTokens[latestMarket][false]).mint(
      PERMANENT_INITIAL_LIQUIDITY_HOLDER,
      initialMarketSeedForEachMarketSide
    );

    marketSideValueInPaymentToken[marketIndex][true] = initialMarketSeedForEachMarketSide;
    marketSideValueInPaymentToken[marketIndex][false] = initialMarketSeedForEachMarketSide;

    emit NewMarketLaunchedAndSeeded(marketIndex, initialMarketSeedForEachMarketSide);
  }

  
  
  
  
  
  
  
  
  
  
  
  function initializeMarket(
    uint32 marketIndex,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 initialMarketSeedForEachMarketSide,
    uint256 balanceIncentiveCurve_exponent,
    int256 balanceIncentiveCurve_equilibriumOffset,
    uint256 _marketTreasurySplitGradient_e18
  ) external adminOnly {
    require(!marketExists[marketIndex], ""already initialized"");
    require(marketIndex <= latestMarket, ""index too high"");

    marketExists[marketIndex] = true;

    marketTreasurySplitGradient_e18[marketIndex] = _marketTreasurySplitGradient_e18;

    
    marketUpdateIndex[marketIndex] = 1;

    
    IStaker(staker).addNewStakingFund(
      latestMarket,
      syntheticTokens[latestMarket][true],
      syntheticTokens[latestMarket][false],
      kInitialMultiplier,
      kPeriod,
      unstakeFee_e18,
      balanceIncentiveCurve_exponent,
      balanceIncentiveCurve_equilibriumOffset
    );

    _seedMarketInitially(initialMarketSeedForEachMarketSide, marketIndex);
  }

  

  
  
  
  
  function _getMin(uint256 a, uint256 b) internal pure virtual returns (uint256) {
    if (a > b) {
      return b;
    } else {
      return a;
    }
  }

  
  
  
  
  
  function _getSyntheticTokenPrice(uint256 amountPaymentTokenBackingSynth, uint256 amountSyntheticToken)
    internal
    pure
    virtual
    returns (uint256 syntheticTokenPrice)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken;
  }

  
  
  
  
  
  function _getAmountPaymentToken(uint256 amountSyntheticToken, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountPaymentToken)
  {
    return (amountSyntheticToken * syntheticTokenPriceInPaymentTokens) / 1e18;
  }

  
  
  
  
  
  function _getAmountSyntheticToken(uint256 amountPaymentTokenBackingSynth, uint256 syntheticTokenPriceInPaymentTokens)
    internal
    pure
    virtual
    returns (uint256 amountSyntheticToken)
  {
    return (amountPaymentTokenBackingSynth * 1e18) / syntheticTokenPriceInPaymentTokens;
  }

  
  function _getEquivalentAmountSyntheticTokensOnTargetSide(
    uint256 amountSyntheticTokens_originSide,
    uint256 syntheticTokenPrice_originSide,
    uint256 syntheticTokenPrice_targetSide
  ) internal pure virtual returns (uint256 equivalentAmountSyntheticTokensOnTargetSide) {
    equivalentAmountSyntheticTokensOnTargetSide =
      (amountSyntheticTokens_originSide * syntheticTokenPrice_originSide) /
      syntheticTokenPrice_targetSide;
  }

  
  
  
  
  
  
  
  
  function getAmountSyntheticTokenToMintOnTargetSide(
    uint32 marketIndex,
    uint256 amountSyntheticToken_redeemOnOriginSide,
    bool isShiftFromLong,
    uint256 priceSnapshotIndex
  ) public view virtual override returns (uint256 amountSyntheticTokensToMintOnTargetSide) {
    uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][isShiftFromLong][
      priceSnapshotIndex
    ];
    uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][!isShiftFromLong][
      priceSnapshotIndex
    ];

    amountSyntheticTokensToMintOnTargetSide = _getEquivalentAmountSyntheticTokensOnTargetSide(
      amountSyntheticToken_redeemOnOriginSide,
      syntheticTokenPriceOnOriginSide,
      syntheticTokenPriceOnTargetSide
    );
  }

  
  function getUsersConfirmedButNotSettledSynthBalance(
    address user,
    uint32 marketIndex,
    bool isLong
  ) external view virtual override requireMarketExists(marketIndex) returns (uint256 confirmedButNotSettledBalance) {
    uint256 currentMarketUpdateIndex = marketUpdateIndex[marketIndex];
    if (
      userNextPrice_currentUpdateIndex[marketIndex][user] != 0 &&
      userNextPrice_currentUpdateIndex[marketIndex][user] <= currentMarketUpdateIndex
    ) {
      uint256 amountPaymentTokenDeposited = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];

      if (amountPaymentTokenDeposited > 0) {
        uint256 syntheticTokenPrice = syntheticToken_priceSnapshot[marketIndex][isLong][currentMarketUpdateIndex];

        confirmedButNotSettledBalance = _getAmountSyntheticToken(amountPaymentTokenDeposited, syntheticTokenPrice);
      }


        uint256 amountSyntheticTokensToBeShiftedAwayFromOriginSide
       = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][!isLong][user];

      if (amountSyntheticTokensToBeShiftedAwayFromOriginSide > 0) {
        uint256 syntheticTokenPriceOnOriginSide = syntheticToken_priceSnapshot[marketIndex][!isLong][
          currentMarketUpdateIndex
        ];
        uint256 syntheticTokenPriceOnTargetSide = syntheticToken_priceSnapshot[marketIndex][isLong][
          currentMarketUpdateIndex
        ];

        confirmedButNotSettledBalance += _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountSyntheticTokensToBeShiftedAwayFromOriginSide,
          syntheticTokenPriceOnOriginSide,
          syntheticTokenPriceOnTargetSide
        );
      }
    }
  }

  
  function _getYieldSplit(
    uint32 marketIndex,
    uint256 longValue,
    uint256 shortValue,
    uint256 totalValueLockedInMarket
  ) internal view virtual returns (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) {
    isLongSideUnderbalanced = longValue < shortValue;
    uint256 imbalance;

    if (isLongSideUnderbalanced) {
      imbalance = shortValue - longValue;
    } else {
      imbalance = longValue - shortValue;
    }

    
    
    
    
    
    
    uint256 marketPercentCalculated_e18 = (imbalance * marketTreasurySplitGradient_e18[marketIndex]) /
      totalValueLockedInMarket;

    uint256 marketPercent_e18 = _getMin(marketPercentCalculated_e18, 1e18);

    treasuryYieldPercent_e18 = 1e18 - marketPercent_e18;
  }

  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  function _claimAndDistributeYieldThenRebalanceMarket(
    uint32 marketIndex,
    int256 newAssetPrice,
    int256 oldAssetPrice
  ) internal virtual returns (uint256 longValue, uint256 shortValue) {
    
    longValue = marketSideValueInPaymentToken[marketIndex][true];
    shortValue = marketSideValueInPaymentToken[marketIndex][false];
    uint256 totalValueLockedInMarket = longValue + shortValue;

    (bool isLongSideUnderbalanced, uint256 treasuryYieldPercent_e18) = _getYieldSplit(
      marketIndex,
      longValue,
      shortValue,
      totalValueLockedInMarket
    );

    uint256 marketAmount = IYieldManager(yieldManagers[marketIndex])
    .distributeYieldForTreasuryAndReturnMarketAllocation(totalValueLockedInMarket, treasuryYieldPercent_e18);

    if (marketAmount > 0) {
      if (isLongSideUnderbalanced) {
        longValue += marketAmount;
      } else {
        shortValue += marketAmount;
      }
    }

    
    
    
    
    
    
    
    int256 underbalancedSideValue = int256(_getMin(longValue, shortValue));

    
    
    int256 valueChange = ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice;

    if (valueChange > 0) {
      longValue += uint256(valueChange);
      shortValue -= uint256(valueChange);
    } else {
      longValue -= uint256(-valueChange);
      shortValue += uint256(-valueChange);
    }
  }

  

  
  
  
  
  
  
  
  function _updateSystemStateInternal(uint32 marketIndex) internal virtual requireMarketExists(marketIndex) {
    
    int256 newAssetPrice = IOracleManager(oracleManagers[marketIndex]).updatePrice();
    int256 oldAssetPrice = int256(assetPrice[marketIndex]);

    bool assetPriceHasChanged = oldAssetPrice != newAssetPrice;

    if (assetPriceHasChanged || msg.sender == staker) {
      uint256 syntheticTokenPrice_inPaymentTokens_long = syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ];
      uint256 syntheticTokenPrice_inPaymentTokens_short = syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ];
      
      
      if (
        userNextPrice_currentUpdateIndex[marketIndex][staker] == marketUpdateIndex[marketIndex] + 1 &&
        assetPriceHasChanged
      ) {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          
          userNextPrice_currentUpdateIndex[marketIndex][staker]
        );
      } else {
        IStaker(staker).pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
          marketIndex,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short,
          marketSideValueInPaymentToken[marketIndex][true],
          marketSideValueInPaymentToken[marketIndex][false],
          0
        );
      }

      
      
      if (!assetPriceHasChanged) {
        return;
      }

      (uint256 newLongPoolValue, uint256 newShortPoolValue) = _claimAndDistributeYieldThenRebalanceMarket(
        marketIndex,
        newAssetPrice,
        oldAssetPrice
      );

      syntheticTokenPrice_inPaymentTokens_long = _getSyntheticTokenPrice(
        newLongPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][true]).totalSupply()
      );
      syntheticTokenPrice_inPaymentTokens_short = _getSyntheticTokenPrice(
        newShortPoolValue,
        ISyntheticToken(syntheticTokens[marketIndex][false]).totalSupply()
      );

      assetPrice[marketIndex] = uint256(newAssetPrice);
      marketUpdateIndex[marketIndex] += 1;

      syntheticToken_priceSnapshot[marketIndex][true][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_long;

      syntheticToken_priceSnapshot[marketIndex][false][
        marketUpdateIndex[marketIndex]
      ] = syntheticTokenPrice_inPaymentTokens_short;

      (
        int256 long_changeInMarketValue_inPaymentToken,
        int256 short_changeInMarketValue_inPaymentToken
      ) = _batchConfirmOutstandingPendingActions(
        marketIndex,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );

      newLongPoolValue = uint256(int256(newLongPoolValue) + long_changeInMarketValue_inPaymentToken);
      newShortPoolValue = uint256(int256(newShortPoolValue) + short_changeInMarketValue_inPaymentToken);
      marketSideValueInPaymentToken[marketIndex][true] = newLongPoolValue;
      marketSideValueInPaymentToken[marketIndex][false] = newShortPoolValue;

      emit SystemStateUpdated(
        marketIndex,
        marketUpdateIndex[marketIndex],
        newAssetPrice,
        newLongPoolValue,
        newShortPoolValue,
        syntheticTokenPrice_inPaymentTokens_long,
        syntheticTokenPrice_inPaymentTokens_short
      );
    }
  }

  
  
  function updateSystemState(uint32 marketIndex) external override {
    _updateSystemStateInternal(marketIndex);
  }

  
  
  function updateSystemStateMulti(uint32[] calldata marketIndexes) external override {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _updateSystemStateInternal(marketIndexes[i]);
    }
  }

  

  
  
  
  
  
  function _transferPaymentTokensFromUserToYieldManager(uint32 marketIndex, uint256 amount) internal virtual {
    require(IERC20(paymentTokens[marketIndex]).transferFrom(msg.sender, yieldManagers[marketIndex], amount));
  }

  

  
  
  
  
  
  function _mintNextPrice(
    uint32 marketIndex,
    uint256 amount,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    _transferPaymentTokensFromUserToYieldManager(marketIndex, amount);

    batched_amountPaymentToken_deposit[marketIndex][isLong] += amount;
    userNextPrice_paymentToken_depositAmount[marketIndex][isLong][msg.sender] += amount;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    emit NextPriceDeposit(marketIndex, isLong, amount, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  
  
  
  function mintLongNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, true);
  }

  
  
  
  function mintShortNextPrice(uint32 marketIndex, uint256 amount) external {
    _mintNextPrice(marketIndex, amount, false);
  }

  

  
  
  
  
  
  function _redeemNextPrice(
    uint32 marketIndex,
    uint256 tokens_redeem,
    bool isLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).transferFrom(msg.sender, address(this), tokens_redeem)
    );

    userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][msg.sender] += tokens_redeem;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_redeem[marketIndex][isLong] += tokens_redeem;

    emit NextPriceRedeem(marketIndex, isLong, tokens_redeem, msg.sender, marketUpdateIndex[marketIndex] + 1);
  }

  
  
  
  function redeemLongNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, true);
  }

  
  
  
  function redeemShortNextPrice(uint32 marketIndex, uint256 tokens_redeem) external {
    _redeemNextPrice(marketIndex, tokens_redeem, false);
  }

  

  
  
  
  
  
  function _shiftPositionNextPrice(
    uint32 marketIndex,
    uint256 amountSyntheticTokensToShift,
    bool isShiftFromLong
  )
    internal
    virtual
    updateSystemStateMarket(marketIndex)
    executeOutstandingNextPriceSettlements(msg.sender, marketIndex)
  {
    require(
      ISyntheticToken(syntheticTokens[marketIndex][isShiftFromLong]).transferFrom(
        msg.sender,
        address(this),
        amountSyntheticTokensToShift
      )
    );

    userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][
      msg.sender
    ] += amountSyntheticTokensToShift;
    userNextPrice_currentUpdateIndex[marketIndex][msg.sender] = marketUpdateIndex[marketIndex] + 1;

    batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      isShiftFromLong
    ] += amountSyntheticTokensToShift;

    emit NextPriceSyntheticPositionShift(
      marketIndex,
      isShiftFromLong,
      amountSyntheticTokensToShift,
      msg.sender,
      marketUpdateIndex[marketIndex] + 1
    );
  }

  
  
  
  function shiftPositionFromLongNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, true);
  }

  
  
  
  function shiftPositionFromShortNextPrice(uint32 marketIndex, uint256 amountSyntheticTokensToShift) external override {
    _shiftPositionNextPrice(marketIndex, amountSyntheticTokensToShift, false);
  }

  

  
  
  
  
  
  function _executeOutstandingNextPriceMints(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentPaymentTokenDepositAmount = userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user];
    if (currentPaymentTokenDepositAmount > 0) {
      userNextPrice_paymentToken_depositAmount[marketIndex][isLong][user] = 0;
      uint256 amountSyntheticTokensToTransferToUser = _getAmountSyntheticToken(
        currentPaymentTokenDepositAmount,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );
      require(
        ISyntheticToken(syntheticTokens[marketIndex][isLong]).transfer(user, amountSyntheticTokensToTransferToUser)
      );

      emit ExecuteNextPriceMintSettlementUser(user, marketIndex, isLong, amountSyntheticTokensToTransferToUser);
    }
  }

  
  
  
  
  function _executeOutstandingNextPriceRedeems(
    uint32 marketIndex,
    address user,
    bool isLong
  ) internal virtual {
    uint256 currentSyntheticTokenRedemptions = userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user];
    if (currentSyntheticTokenRedemptions > 0) {
      userNextPrice_syntheticToken_redeemAmount[marketIndex][isLong][user] = 0;
      uint256 amountPaymentToken_toRedeem = _getAmountPaymentToken(
        currentSyntheticTokenRedemptions,
        syntheticToken_priceSnapshot[marketIndex][isLong][userNextPrice_currentUpdateIndex[marketIndex][user]]
      );

      IYieldManager(yieldManagers[marketIndex]).transferPaymentTokensToUser(user, amountPaymentToken_toRedeem);

      emit ExecuteNextPriceRedeemSettlementUser(user, marketIndex, isLong, amountPaymentToken_toRedeem);
    }
  }

  
  
  
  
  
  function _executeOutstandingNextPriceTokenShifts(
    uint32 marketIndex,
    address user,
    bool isShiftFromLong
  ) internal virtual {
    uint256 syntheticToken_toShiftAwayFrom_marketSide = userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[
      marketIndex
    ][isShiftFromLong][user];
    if (syntheticToken_toShiftAwayFrom_marketSide > 0) {
      uint256 syntheticToken_toShiftTowardsTargetSide = getAmountSyntheticTokenToMintOnTargetSide(
        marketIndex,
        syntheticToken_toShiftAwayFrom_marketSide,
        isShiftFromLong,
        userNextPrice_currentUpdateIndex[marketIndex][user]
      );

      userNextPrice_syntheticToken_toShiftAwayFrom_marketSide[marketIndex][isShiftFromLong][user] = 0;

      require(
        ISyntheticToken(syntheticTokens[marketIndex][!isShiftFromLong]).transfer(
          user,
          syntheticToken_toShiftTowardsTargetSide
        )
      );

      emit ExecuteNextPriceMarketSideShiftSettlementUser(
        user,
        marketIndex,
        isShiftFromLong,
        syntheticToken_toShiftTowardsTargetSide
      );
    }
  }

  
  
  
  
  function _executeOutstandingNextPriceSettlements(address user, uint32 marketIndex) internal virtual {
    uint256 userCurrentUpdateIndex = userNextPrice_currentUpdateIndex[marketIndex][user];
    if (userCurrentUpdateIndex != 0 && userCurrentUpdateIndex <= marketUpdateIndex[marketIndex]) {
      _executeOutstandingNextPriceMints(marketIndex, user, true);
      _executeOutstandingNextPriceMints(marketIndex, user, false);
      _executeOutstandingNextPriceRedeems(marketIndex, user, true);
      _executeOutstandingNextPriceRedeems(marketIndex, user, false);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, true);
      _executeOutstandingNextPriceTokenShifts(marketIndex, user, false);

      userNextPrice_currentUpdateIndex[marketIndex][user] = 0;

      emit ExecuteNextPriceSettlementsUser(user, marketIndex);
    }
  }

  
  
  
  function executeOutstandingNextPriceSettlementsUser(address user, uint32 marketIndex) external override {
    _executeOutstandingNextPriceSettlements(user, marketIndex);
  }

  
  
  
  function executeOutstandingNextPriceSettlementsUserMulti(address user, uint32[] memory marketIndexes) external {
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      _executeOutstandingNextPriceSettlements(user, marketIndexes[i]);
    }
  }

  

  
  
  
  
  
  function _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
    uint32 marketIndex,
    int256 totalPaymentTokenValueChangeForMarket
  ) internal virtual {
    if (totalPaymentTokenValueChangeForMarket > 0) {
      IYieldManager(yieldManagers[marketIndex]).depositPaymentToken(uint256(totalPaymentTokenValueChangeForMarket));
    } else if (totalPaymentTokenValueChangeForMarket < 0) {
      
      
      IYieldManager(yieldManagers[marketIndex]).removePaymentTokenFromMarket(
        uint256(-totalPaymentTokenValueChangeForMarket)
      );
    }
  }

  
  
  
  
  
  function _handleChangeInSyntheticTokensTotalSupply(
    uint32 marketIndex,
    bool isLong,
    int256 changeInSyntheticTokensTotalSupply
  ) internal virtual {
    if (changeInSyntheticTokensTotalSupply > 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).mint(
        address(this),
        uint256(changeInSyntheticTokensTotalSupply)
      );
    } else if (changeInSyntheticTokensTotalSupply < 0) {
      ISyntheticToken(syntheticTokens[marketIndex][isLong]).burn(uint256(-changeInSyntheticTokensTotalSupply));
    }
  }

  
  function _batchConfirmOutstandingPendingActions(
    uint32 marketIndex,
    uint256 syntheticTokenPrice_inPaymentTokens_long,
    uint256 syntheticTokenPrice_inPaymentTokens_short
  )
    internal
    virtual
    returns (int256 long_changeInMarketValue_inPaymentToken, int256 short_changeInMarketValue_inPaymentToken)
  {
    int256 changeInSupply_syntheticToken_long;
    int256 changeInSupply_syntheticToken_short;

    
    uint256 amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][true];

    
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][true] = 0;

      changeInSupply_syntheticToken_long = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
    }

    
    amountForCurrentAction_workingVariable = batched_amountPaymentToken_deposit[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken = int256(amountForCurrentAction_workingVariable);

      batched_amountPaymentToken_deposit[marketIndex][false] = 0;

      changeInSupply_syntheticToken_short = int256(
        _getAmountSyntheticToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToShort = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );

      long_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToShort;
      short_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToShort;

      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_short += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_long,
          syntheticTokenPrice_inPaymentTokens_short
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][
      false
    ];
    if (amountForCurrentAction_workingVariable > 0) {
      int256 paymentTokenValueChangeForShiftToLong = int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );

      short_changeInMarketValue_inPaymentToken -= paymentTokenValueChangeForShiftToLong;
      long_changeInMarketValue_inPaymentToken += paymentTokenValueChangeForShiftToLong;

      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);
      changeInSupply_syntheticToken_long += int256(
        _getEquivalentAmountSyntheticTokensOnTargetSide(
          amountForCurrentAction_workingVariable,
          syntheticTokenPrice_inPaymentTokens_short,
          syntheticTokenPrice_inPaymentTokens_long
        )
      );

      batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true] = 0;
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][true];
    if (amountForCurrentAction_workingVariable > 0) {
      long_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_long)
      );
      changeInSupply_syntheticToken_long -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][true] = 0;
    }

    
    amountForCurrentAction_workingVariable = batched_amountSyntheticToken_redeem[marketIndex][false];
    if (amountForCurrentAction_workingVariable > 0) {
      short_changeInMarketValue_inPaymentToken -= int256(
        _getAmountPaymentToken(amountForCurrentAction_workingVariable, syntheticTokenPrice_inPaymentTokens_short)
      );
      changeInSupply_syntheticToken_short -= int256(amountForCurrentAction_workingVariable);

      batched_amountSyntheticToken_redeem[marketIndex][false] = 0;
    }

    
    _handleTotalPaymentTokenValueChangeForMarketWithYieldManager(
      marketIndex,
      long_changeInMarketValue_inPaymentToken + short_changeInMarketValue_inPaymentToken
    );
    
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, true, changeInSupply_syntheticToken_long);
    _handleChangeInSyntheticTokensTotalSupply(marketIndex, false, changeInSupply_syntheticToken_short);
  }
}",7793.0,1,2,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Centralization Risks**: 
   - The `admin` has extensive control over critical functions (e.g., changing oracles, treasury, market parameters). Compromise of the admin account could lead to system manipulation.

2. **Oracle Manipulation**:
   - Reliance on an updatable oracle (`oracleManagers`) for price data. A malicious or compromised oracle can inject incorrect prices, affecting minting, redeeming, and market valuations.

3. **Division by Zero in Price Calculation**:
   - `_getSyntheticTokenPrice` may divide by zero if `amountSyntheticToken` is zero (e.g., if all synthetic tokens are redeemed). This could halt price updates and critical operations.

4. **Front-Running Price Updates**:
   - Pending actions (mints/redeems) settle on the next price update. Malicious actors could front-run oracle updates to manipulate settlement outcomes.

5. **ERC20 Compliance Assumptions**:
   - Uses `require` for ERC20 transfers, assuming compliant tokens. Non-compliant tokens (e.g., returning `false` instead of reverting) may cause transaction failures.

6. **Reentrancy in Yield Manager Interactions**:
   - Calls to `IYieldManager.transferPaymentTokensToUser()` occur after state updates but could allow reentrancy if the yield manager makes external calls to untrusted contracts.

7. **Upgradeable Contract Risks**:
   - Inherits risks from upgradeability patterns (e.g., admin could deploy a malicious upgrade). The `__constantsGap` and `__globalStateGap` indicate upgradeability concerns.

8. **Rounding Errors**:
   - Integer divisions (e.g., in `_getSyntheticTokenPrice`) may truncate values, leading to gradual value leakage or inaccuracies over time.

9. **Permanent Initial Liquidity Holder Control**:
   - The `PERMANENT_INITIAL_LIQUIDITY_HOLDER` receives initial synthetic tokens. If accessible, this address could manipulate liquidity; if locked, it restricts liquidity.

10. **Staker Contract Dependency**:
    - Relies on the external `staker` contract. Vulnerabilities or malicious code in `staker` could propagate to this contract (e.g., incorrect reward calculations).

11. **Unchecked Market State in Rebalancing**:
    - In `_claimAndDistributeYieldThenRebalanceMarket`, subtracting from `longValue` or `shortValue` without ensuring sufficient balances could underflow (mitigated by Solidity 0.8's checked math).

12. **Token Factory Trust**:
    - Synthetic tokens are created via `tokenFactory`. A compromised factory could deploy malicious tokens, undermining the system's integrity.

13. **Delayed Price Updates Impacting Batched Actions**:
    - Prolonged delays in price updates could leave user actions unsettled, exposing them to market risks or manipulation.

14. **Lack of Input Validation**:
    - Some functions (e.g., `initializeMarket`) lack validation for parameters like `kInitialMultiplier` or `unstakeFee_e18`, risking improper market configurations.

15. **Insufficient Event Emissions**:
    - Critical state changes (e.g., admin changes) emit events, but others (like yield distribution) may lack detailed logging, reducing transparency.","### **Comparison and Evaluation**

---

#### **[H-01] Copy Paste Error in `_batchConfirmOutstandingPendingActions`**

**Report Description**:  
The function `_batchConfirmOutstandingPendingActions` in `LongShort.sol` processes the variable `batched_amountSyntheticToken_toShiftAwayFrom_marketSide` and sets it to 0 after processing. However, due to a copy/paste error, in the second instance, `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed, but the wrong version is set to 0: `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][true]` = 0. This means the next time `batched_amountSyntheticToken_toShiftAwayFrom_marketSide[marketIndex][false]` is processed, it is never reset, causing it to keep increasing. This results in internal administration discrepancies and far too many tokens being shifted from SHORT to LONG.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this specific issue. The copy/paste error in `_batchConfirmOutstandingPendingActions` is a critical logical flaw that could lead to significant token misallocation. This issue is not covered in the response list, which focuses on broader vulnerabilities like centralization risks, oracle manipulation, and reentrancy.

---

#### **[M-01] `latestMarket` Used Where `marketIndex` Should Have Been Used**

**Report Description**:  
The functions `initializeMarket` and `_seedMarketInitially` use the variable `latestMarket`. If these functions are called separately from `createNewSyntheticMarket`, `latestMarket` would have the same value for each call, leading to multiple initializations of the same market and improper initialization of previous markets. This issue could be prevented by the call to `addNewStakingFund`, but it also allows this issue to occur. While the functions can only be called by the admin, future releases might separate the calls to `createNewSyntheticMarket` and `initializeMarket`, leading to problems.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The misuse of `latestMarket` instead of `marketIndex` is a logical error that could lead to improper market initialization. This issue is not covered in the response list, which focuses on broader vulnerabilities like oracle manipulation, division by zero, and front-running.

---

#### **[M-06] Prevent Markets Getting Stuck When Prices Don't Move**

**Report Description**:  
If the price of a synthetic token remains constant (e.g., synthetic DAI or binary option tokens), `assetPriceHasChanged` will never be true again, and `marketUpdateIndex[marketIndex]` will never increase. This means the `_executeOutstandingNextPrice*` functions will never be executed, effectively leaving the market stuck.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address this issue. The potential for markets to get stuck due to unchanging prices is a significant operational risk. This issue is not covered in the response list, which focuses on broader vulnerabilities like oracle manipulation, reentrancy, and rounding errors.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-01] Copy Paste Error in `_batchConfirmOutstandingPendingActions`**  
- **[M-01] `latestMarket` Used Where `marketIndex` Should Have Been Used**  
- **[M-06] Prevent Markets Getting Stuck When Prices Don't Move**

---

### **Conclusion**  
The `response_list` does not adequately address the specific issues raised in the `issue` report. While the response list covers a broad range of vulnerabilities, it misses critical logical errors and operational risks identified in the issue report. These gaps highlight the need for a more detailed and context-specific analysis of the smart contract's functionality and potential vulnerabilities.",0,0,3,15,"Okay, let me take a look at this smart contract and see what vulnerabilities I can find. Hmm, the contract is called LongShort and it's using Solidity 0.8.3. Since it's an upgradeable contract, it imports Initializable from OpenZeppelin. There are a bunch of other imports too, like interfaces for TokenFactory, SyntheticToken, Staker, etc.

Starting from the top, the contract has a constant address PERMANENT_INITIAL_LIQUIDITY_HOLDER. That's a long address, probably a placeholder. Then there are some state variables like admin, treasury, latestMarket, staker, tokenFactory, and various mappings for market data.

Looking at the modifiers, there's adminOnly and requireMarketExists. The initialize function sets up the admin, treasury, etc. Then there are functions to change admin and treasury, which are adminOnly, so only the admin can change them. That's okay as long as the admin is a trusted entity.

The createNewSyntheticMarket function increments latestMarket and creates synthetic tokens via the TokenFactory. Then it sets paymentTokens, yieldManagers, oracleManagers, and assetPrice. Wait, the oracle manager is set here, but there's an updateMarketOracle function that allows the admin to change the oracle manager. If the oracle is compromised or changed maliciously, that could affect the asset price, leading to incorrect valuations. That's a potential centralization risk or a vulnerability if the admin is untrusted.

In the _seedMarketInitially function, they transfer payment tokens to the yield manager and mint synthetic tokens to the PERMANENT_INITIAL_LIQUIDITY_HOLDER. The initial seed is required to be at least 1e18, which is 1 token if it's 18 decimals. But if the PERMANENT_INITIAL_LIQUIDITY_HOLDER is a fixed address, maybe that's a problem if it's not properly controlled. However, the address is a constant, so maybe it's a burn address or something. Not sure if that's an issue here.

Looking at the initializeMarket function, it checks that the market doesn't exist and sets up parameters. Then calls _seedMarketInitially. The problem might be if someone can call this function multiple times for the same marketIndex, but the require statement prevents that. So maybe not an issue here.

Moving on to the _getSyntheticTokenPrice function. It calculates the price as (amountPaymentTokenBackingSynth * 1e18) / amountSyntheticToken. Division in Solidity can lead to rounding errors, especially if the denominator is larger than the numerator, leading to a price of zero. But since this is a common approach, maybe it's handled properly elsewhere. But if there's a case where amountSyntheticToken is zero, this would cause a division by zero. However, the code should ensure that total supply isn't zero when this is called. But maybe in some edge cases, like when all synthetic tokens are redeemed, this could be a problem. For example, if all tokens are redeemed, the total supply would be zero, and this function would revert. But the code might have checks elsewhere to prevent that. Need to check where this is used.

In the _updateSystemStateInternal function, it calls IOracleManager to update the price. If the oracle manager is malicious or returns an incorrect price, that could affect the entire market. Since the oracle can be changed by the admin, this is a potential risk. The contract relies heavily on the oracle's correctness.

Another thing in _updateSystemStateInternal is the call to _claimAndDistributeYieldThenRebalanceMarket. This function calculates the yield split and rebalances the market based on price changes. The calculation for valueChange is ((newAssetPrice - oldAssetPrice) * underbalancedSideValue) / oldAssetPrice. If oldAssetPrice is zero, this would divide by zero. But oldAssetPrice is set from assetPrice[marketIndex], which is initialized from the oracle's initial price. If the oracle returns zero, that's a problem. But the oracle should be a trusted contract that doesn't return invalid prices. However, if the oracle is compromised, this could be an issue.

Looking at the mint and redeem functions. For example, mintLongNextPrice calls _mintNextPrice, which adds to batched_amountPaymentToken_deposit and sets userNextPrice_currentUpdateIndex. But during the next price update, these batched amounts are processed. However, if a user mints and then the price isn't updated for a long time, their transaction is pending until an update happens. This could lead to front-running or price manipulation if the oracle updates can be influenced by certain actions.

Another area is the executeOutstandingNextPriceSettlements functions. When executing settlements, it transfers synthetic tokens to the user based on the price snapshot. If the synthetic token's transfer function has hooks or is upgradable, that could introduce risks. But since the synthetic tokens are created via the TokenFactory, which is presumably controlled by the admin, this depends on the TokenFactory's security.

In the _batchConfirmOutstandingPendingActions function, when handling shifts from long to short, the code uses the price snapshot to calculate equivalent amounts. There's a potential for incorrect calculations here, especially if the prices are outdated or manipulated. For example, if a user shifts their position and the price changes unfavorably before the batch is processed, they might get a worse rate than expected. But this is part of the design of next-price actions.

Another possible issue is reentrancy. The contract uses the Checks-Effects-Interactions pattern, but let's check. For example, in _executeOutstandingNextPriceRedeems, after updating the user's redemption amount to zero, it calls transferPaymentTokensToUser. If the yield manager's transfer function is malicious or makes external calls, this could allow reentrancy. However, since the state is updated before the transfer, it might be safe. But depends on the yield manager's implementation.

Also, the use of require for ERC20 transfers: require(IERC20(...).transferFrom(...)). The transferFrom function returns a boolean, and using require checks that it's true. But some tokens may not revert on failure and instead return false, which would cause the require to fail. That's okay, but it's a known issue with some ERC20 implementations. However, since the payment token is set by the admin, they should ensure it's a compliant token.

The contract has a lot of mappings and state variables, which could lead to storage collisions if not handled properly, but since it's using Solidity 0.8.3 and the gaps (__constantsGap, __globalStateGap) are present, it's likely using the upgradeable pattern correctly. However, if the contract is upgradeable, the admin could upgrade it to a malicious version. But that's a general risk of upgradeable contracts, not a specific vulnerability in this code.

In the _getYieldSplit function, the code calculates treasuryYieldPercent_e18 as 1e18 - marketPercent_e18. If marketPercentCalculated_e18 is greater than 1e18, marketPercent_e18 is capped at 1e18, making treasuryYieldPercent_e18 zero. This could mean that all yield goes to the market, but maybe that's intended.

In the _claimAndDistributeYieldThenRebalanceMarket function, when adding marketAmount to longValue or shortValue, there's a possible overflow if the values are too large. But since Solidity 0.8.3 has checked math, this would revert. So that's handled.

Another thing to note is the use of userNextPrice_currentUpdateIndex to track the user's pending actions. If the system doesn't update the state for a long time, users' transactions could be stuck. But this is part of the design, requiring regular price updates.

Potential vulnerabilities I can identify:

1. **Centralization Risks**: The admin has significant control, including changing the oracle, treasury, and other critical parameters. If the admin is compromised, they can manipulate the system.

2. **Oracle Manipulation**: The contract relies on the oracle manager for price data. If the oracle is malicious or compromised, it can provide incorrect prices, leading to incorrect minting, redeeming, and value calculations.

3. **Division by Zero in Price Calculation**: In _getSyntheticTokenPrice, if amountSyntheticToken is zero (e.g., all tokens are redeemed), this would cause a division by zero error. However, the initial seed ensures some tokens exist, but if all are burned, this could happen.

4. **Front-Running Price Updates**: Since actions are executed on the next price update, a malicious actor could front-run the update to manipulate the system's state.

5. **Dependency on ERC20 Compliance**: Assumes that payment tokens comply with the ERC20 standard, especially returning a boolean on transferFrom. Non-compliant tokens could cause issues.

6. **Reentrancy in Yield Manager**: If the yield manager's functions (like transferPaymentTokensToUser) make external calls, there's a potential for reentrancy attacks. However, state changes occur before the transfer, which should mitigate this.

7. **Upgradeable Contract Risks**: Since the contract is upgradeable, a malicious admin could upgrade to a harmful version. This is inherent in upgradeable contracts.

8. **Rounding Errors**: Due to integer division, there could be rounding errors that slightly favor the contract or users, leading to value leakage over time.

9. **Lack of Access Control on Some Functions**: For example, the executeOutstandingNextPriceSettlementsUserMulti function can be called by anyone for any user. This might allow griefing by forcing settlements, but the function itself is harmless as it processes the user's own pending actions. However, if there's a cost associated (like gas), it could be a nuisance.

10. **Incorrect Handling of Negative Value Changes**: In _claimAndDistributeYieldThenRebalanceMarket, when valueChange is negative, the code subtracts from longValue and adds to shortValue. If the subtraction underflows, the transaction would revert. But since underbalancedSideValue is the minimum of long and short, and multiplied by price change over old price, maybe the code ensures that it doesn't exceed the actual values. However, this depends on the oracle's price accuracy.

11. **Uninitialized Markets**: The initializeMarket function requires that the market doesn't exist, but if someone calls createNewSyntheticMarket and then initializeMarket with a wrong marketIndex, it might cause issues. However, latestMarket is incremented correctly, so probably not.

12. **Staker Contract Interaction**: The contract interacts with the staker contract, assuming it's properly configured. If the staker is malicious or has vulnerabilities, it could affect this contract.

13. **Permanent Initial Liquidity Holder**: The PERMANENT_INITIAL_LIQUIDITY_HOLDER receives initial minted tokens. If this address is inaccessible (like a burn address), the initial liquidity is locked. But if it's a regular address, the holder could manipulate the market by moving tokens.

14. **Batched Actions Processing**: The batched amounts are processed during system updates. If a system update isn't called, these actions remain pending. An attacker could possibly exploit delayed processing, but that's part of the design.

15. **Incorrect Price Snapshots**: The syntheticToken_priceSnapshot is updated based on oracle prices. If the oracle provides incorrect data during an update, all subsequent actions based on that snapshot would be incorrect.

16. **Market Existence Check**: Functions with requireMarketExists modifier could be called with non-existent markets, causing reverts. However, this is more of a usability issue than a vulnerability.

17. **Token Factory Trust**: The contract relies on the token factory to create valid synthetic tokens. If the token factory is compromised, the synthetic tokens could be malicious.

So, summarizing the main vulnerabilities:

- Centralization risks with admin privileges.
- Oracle manipulation risks.
- Potential division by zero in price calculation if synthetic token supply is zero.
- Reentrancy in yield manager interactions (if not properly secured).
- Front-running and price update manipulation.
- ERC20 compliance assumptions.
- Upgradeability risks.

Each of these points should be considered as potential vulnerabilities, depending on the context and trust assumptions of the contract's setup.","```
None.
```",0.0
Staker.sol,"// SPDX-License-Identifier: BUSL-1.1

pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";

import ""./interfaces/IFloatToken.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ISyntheticToken.sol"";

contract Staker is IStaker, Initializable {
  /*╔═════════════════════════════╗
    ║          VARIABLES          ║
    ╚═════════════════════════════╝*/

  /* ══════ Fixed-precision constants ══════ */
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;
  // 2^52 ~= 4.5e15
  // With an exponent of 5, the largest total liquidity possible in a market (to avoid integer overflow on exponentiation) is ~10^31 or 10 Trillion (10^13)
  // NOTE: this also means if the total market value is less than 2^52 there will be a division by zero error
  uint256 public constant safeExponentBitShifting = 52;

  /* ══════ Global state ══════ */
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  /* ══════ Market specific ══════ */
  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  /* ══════ Reward specific ══════ */
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  /* ══════ User specific ══════ */
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  /* ══════ Token shift management specific ══════ */
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  /**
  @notice Used to link a token shift to a staker state
  @dev tokenShiftIndex => accumulativeFloatIssuanceSnapshotIndex
    POSSIBLE OPTIMIZATION - could pack stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping and stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping into a struct of two uint128 for storage space optimization.
  */
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  /// @notice Used to fetch the price from LongShort at that point in time
  /// @dev tokenShiftIndex => longShortMarketPriceSnapshotIndex
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  /// @dev marketIndex => usersAddress => stakerTokenShiftIndex
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromLongOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  /// @dev marketIndex => usersAddress => amountUserRequestedToShiftAwayFromShortOnNextUpdate
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  /*╔════════════════════════════╗
    ║           EVENTS           ║
    ╚════════════════════════════╝*/

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  // Note: the `amountFloatMinted` isn't strictly needed by the graph, but it is good to add it to validate calculations are accurate.
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  /*╔═════════════════════════════╗
    ║          MODIFIERS          ║
    ╚═════════════════════════════╝*/

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, ""not admin"");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, ""not valid synth"");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), ""not valid market"");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), ""not long short"");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  /*╔═════════════════════════════╗
    ║       CONTRACT SET-UP       ║
    ╚═════════════════════════════╝*/

  /**
  @notice Initializes the contract.
  @dev Calls OpenZeppelin's initializer modifier.
  @param _admin Address of the admin role.
  @param _longShort Address of the LongShort contract, a deployed LongShort.sol
  @param _floatToken Address of the Float token earned by staking.
  @param _floatTreasury Address of the treasury contract for managing fees.
  @param _floatCapital Address of the contract which earns a fixed percentage of Float.
  @param _floatPercentage Determines the float percentage that gets minted for Float Capital, base 1e18.
  */
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  /*╔═══════════════════╗
    ║       ADMIN       ║
    ╚═══════════════════╝*/

  /** 
  @notice Changes admin for the contract
  @param _admin The address of the new admin.
  */
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  /// @dev Logic for changeFloatPercentage
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%
    floatPercentage = newFloatPercentage;
  }

  /**
  @notice Changes percentage of float that is minted for float capital.
  @param newFloatPercentage The new float percentage in base 1e18.
  */
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  /// @dev Logic for changeUnstakeFee
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  /**
  @notice Changes unstake fee for a market
  @param marketIndex Identifies the market.
  @param newMarketUnstakeFee_e18 The new unstake fee.
  */
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  /// @dev Logic for changeMarketLaunchIncentiveParameters
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, ""marketLaunchIncentiveMultiplier must be >= 1e18"");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  /**
  @notice Changes the market launch incentive parameters for a market
  @param marketIndex Identifies the market.
  @param period The new period for which float token generation should be boosted.
  @param initialMultiplier The new multiplier on Float generation.
  */
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  /// @dev Logic for changeBalanceIncentiveExponent
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      // The exponent has to be less than 5 in these versions of the contracts.
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      ""balanceIncentiveCurve_exponent out of bounds""
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  /** 
  @notice Changes the balance incentive exponent for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_exponent The new exponent for the curve.
  */
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  /// @dev Logic for changeBalanceIncentiveEquilibriumOffset
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    // Unreasonable that we would ever shift this more than 90% either way
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      ""balanceIncentiveCurve_equilibriumOffset out of bounds""
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  /**
  @notice Changes the balance incentive curve equilibrium offset for a market
  @param marketIndex Identifies the market.
  @param _balanceIncentiveCurve_equilibriumOffset The new offset.
  */
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  /*╔═════════════════════════════╗
    ║        STAKING SETUP        ║
    ╚═════════════════════════════╝*/

  /**
  @notice Sets this contract to track staking for a market in LongShort.sol
  @param marketIndex Identifies the market.
  @param longToken Address of the long token for the market.
  @param shortToken Address of the short token for the market.
  @param kInitialMultiplier Initial boost on float generation for the market.
  @param kPeriod Period which the boost should last.
  @param unstakeFee_e18 Percentage of tokens that are levied on unstaking in base 1e18.
  @param _balanceIncentiveCurve_exponent Exponent for balance curve (see _calculateFloatPerSecond)
  @param _balanceIncentiveCurve_equilibriumOffset Offset for balance curve (see _calculateFloatPerSecond)
  */
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    // Set this value to one initially - 0 is a null value and thus potentially bug prone.
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  /*╔═════════════════════════════════════════════════════════════════════════╗
    ║    GLOBAL FLT REWARD ACCUMULATION CALCULATION AND TRACKING FUNCTIONS    ║
    ╚═════════════════════════════════════════════════════════════════════════╝*/

  /**
  @notice Returns the K factor parameters for the given market with sensible
  defaults if they haven't been set yet.
  @param marketIndex The market to change the parameters for.
  @return period The period for which the k factor applies for in seconds.
  @return multiplier The multiplier on Float generation in this period.
  */
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; // multiplier of 1 by default
    }
  }

  /** 
  @notice Returns the extent to which a markets float generation should be adjusted
  based on the market's launch incentive parameters. Should start at multiplier
  then linearly change to 1e18 over time.
  @param marketIndex Identifies the market.
  @return k The calculated modifier for float generation.
  */
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    // Parameters controlling the float issuance multiplier.
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    // Sanity check - under normal circumstances, the multipliers should
    // *never* be set to a value < 1e18, as there are guards against this.
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  /*
  @notice Computes the number of float tokens a user earns per second for
  every long/short synthetic token they've staked. The returned value has
  a fixed decimal scale of 1e42 (!!!) for numerical stability. The return
  values are float per second per synthetic token (hence the requirement
  to multiply by price)
  @dev to see below math in latex form see TODO add link
  to interact with the equations see https://www.desmos.com/calculator/optkaxyihr
  @param marketIndex The market referred to.
  @param longPrice Price of the synthetic long token in units of payment token
  @param shortPrice Price of the synthetic short token in units of payment token
  @param longValue Amount of payment token in the long side of the market
  @param shortValue Amount of payment token in the short side of the market
  @return longFloatPerSecond Float token per second per long synthetic token
  @return shortFloatPerSecond Float token per second per short synthetic token
   */
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    // A float issuance multiplier that starts high and decreases linearly
    // over time to a value of 1. This incentivises users to stake early.
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    // we need to scale this number by the totalLocked so that the offset remains consistent accross market size

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    // Float is scaled by the percentage of the total market value held in
    // the opposite position. This incentivises users to stake on the
    // weaker position.
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to short token
        //            extremeley unlikely to happen in practice
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token
        //            extremeley unlikely to happen in practice
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      // NOTE: `x * 5e17` == `(x * 10e18) / 2`
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  /**
  @notice Computes the time since last accumulativeIssuancePerStakedSynthSnapshot for the given market in seconds.
  @param marketIndex The market referred to.
  @return The time difference in seconds
  */
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  /**
  @notice Computes new cumulative sum of 'r' value since last accumulativeIssuancePerStakedSynthSnapshot. We use
  cumulative 'r' value to avoid looping during issuance. Note that the
  cumulative sum is kept in 1e42 scale (!!!) to avoid numerical issues.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  @return longCumulativeRates The long cumulative sum.
  @return shortCumulativeRates The short cumulative sum.
  */
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    // Compute the current 'r' value for float issuance per second.
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    // Compute new cumulative 'r' value total.
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  /**
  @notice Creates a new accumulativeIssuancePerStakedSynthSnapshot for the given token and updates indexes.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  /**
  @notice Adds new accumulativeIssuancePerStakedSynthSnapshots for the given long/short tokens. Called by the
  ILongShort contract whenever there is a state change for a market.
  @param stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted Mapping from this contract's shifts to LongShort.sols next price snapshots.
  @param shortValue The value locked in the short side of the market.
  @param longValue The value locked in the long side of the market.
  @param shortPrice The price of the short token as defined in LongShort.sol
  @param longPrice The price of the long token as defined in LongShort.sol
  @param marketIndex An identifier for the market.
  */
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured
  ) external override onlyLongShort {
    // Only add a new accumulativeIssuancePerStakedSynthSnapshot if some time has passed.

    // the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted` value will be 0 if there is no staker related action in an executed batch
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    // Time delta is fetched twice in below code, can pass through? Which is less gas?
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  /*╔═══════════════════════════════════╗
    ║    USER REWARD STATE FUNCTIONS    ║
    ╚═══════════════════════════════════╝*/

  /// @dev Calculates the accumulated float in a specific range of staker snapshots
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  /** 
  @notice Calculates float owed to the user since the user last minted float for a market.
  @param marketIndex Identifier for the market which the user staked in.
  @param user The address of the user.
  @return floatReward The amount of float owed.
   */
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    // Don't do the calculation and return zero immediately if there is no change
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      // Update the users balances
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      // Save the users updated staked amounts
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  /**
  @notice Mints float for a user.
  @dev Mints a fixed percentage for Float capital.
  @param user The address of the user.
  @param floatToMint The amount of float to mint.
   */
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  /**
  @notice Mints float owed to a user for a market since they last minted.
  @param marketIndex An identifier for the market.
  @param user The address of the user.
   */
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      // Set the user has claimed up until now, stops them setting this forward
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  /**
  @notice Mints float owed to a user for multiple markets, since they last minted for those markets.
  @param marketIndexes Identifiers for the markets.
  @param user The address of the user.
   */
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        // Set the user has claimed up until now, stops them setting this forward
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  /**
  @notice Mints outstanding float for msg.sender.
  @param marketIndexes Identifiers for the markets for which to mint float.
   */
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  /**
  @notice Mints outstanding float on behalf of another user.
  @param marketIndexes Identifiers for the markets for which to mint float.
  @param user The address of the user.
   */
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.
    // No need to impose limit.
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  /*╔═══════════════════════╗
    ║        STAKING        ║
    ╚═══════════════════════╝*/

  /**
  @notice A user with synthetic tokens stakes by calling stake on the token
  contract which calls this function. We need to first update the
  state of the LongShort contract for this market before staking to correctly calculate user rewards.
  @param amount Amount to stake.
  @param from Address to stake for.
  */
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  /**
  @dev Internal logic for staking.
  @param token Address of the token for which to stake.
  @param amount Amount to stake.
  @param user Address to stake for.
  */
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    // If they already have staked and have rewards due, mint these.
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  /**
  @notice Allows users to shift their staked tokens from one side of the market to 
  the other at the next price.
  @param amountSyntheticTokensToShift Amount of tokens to shift.
  @param marketIndex Identifier for the market.
  @param isShiftFromLong Whether the shift is from long to short or short to long.
  */
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, ""Not enough tokens to shift"");

    // If the user has outstanding token shift that have already been confirmed in the LongShort
    // contract, execute them first.
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  /*╔════════════════════════════╗
    ║    WITHDRAWAL & MINTING    ║
    ╚════════════════════════════╝*/

  /**
  @notice Internal logic for withdrawing stakes.
  @dev Mint user any outstanding float before withdrawing.
  @param marketIndex Market index of token.
  @param amount Amount to withdraw.
  @param token Synthetic token that was staked.
  */
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, ""nothing to withdraw"");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  /**
  @notice Withdraw function. Allows users to unstake.
  @param amount Amount to withdraw.
  @param token Address of the token for which to withdraw.
  */
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      // If they still have outstanding shifts after minting float, then check
      // that they don't withdraw more than their shifts allow.
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        ""Outstanding next price stake shifts too great""
      );
    }
  }

  /**
  @notice Allows users to withdraw their entire stake for a token.
  @param token Address of the token for which to withdraw.
  */
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}",10095.0,986.0,"[H-02] 2 variables not indexed by marketIndex
Function `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`
In the token contract: `batched_stakerNextTokenShiftIndex` is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.
stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex. So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex[market2]
This will lead to weird results in _calculateAccumulatedFloat, allocating too much or too little float.
``` function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    ...
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;
...
) ```   [H-03] Users could shift tokens on `Staker` with more than he has staked The `shiftTokens` function of `Staker` checks whether the user has staked at least the number of tokens he wants to shift from one side to the other (line 885). A user could call the `shiftTokens` function multiple times before the next price update to shift the staker's token from one side to the other with more than he has staked. Staker.sol#L885
Recommend adding checks on userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long and userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short to ensure that the sum of the two variables does not exceed user's stake balance.
  [M-04] Staker.sol: Wrong values returned in edge cases of `_calculateFloatPerSecond()`
In `_calculateFloatPerSecond()`, the edge cases where full rewards go to either the long or short token returns
`return (1e18 * k * longPrice, 0);` and
`return (0, 1e18 * k * shortPrice);` respectively.
This is however `1e18` times too large. We can verify this by checking the equivalent calculation in the 'normal case', where we assume all the rewards go to the short token, ie. `longRewardUnscaled = 0` and `shortRewardUnscaled = 1e18`. Plugging this into the calculation below,
return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18); results in
`(0, 1e18 * k * shortPrice / 1e18) or (0, k * shortPrice)`.
As we can see, this would result in an extremely large float token issuance rate, which would be disastrous.
The edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` in the cases where rewards should go fully to long and short token holders respectively.",3.0,"pragma solidity 0.8.3;

import ""@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol"";

import ""./interfaces/IFloatToken.sol"";
import ""./interfaces/ILongShort.sol"";
import ""./interfaces/IStaker.sol"";
import ""./interfaces/ISyntheticToken.sol"";

contract Staker is IStaker, Initializable {
  
  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;

  uint256 public constant safeExponentBitShifting = 52;

  
  address public admin;
  address public floatCapital;
  address public floatTreasury;
  uint256 public floatPercentage;

  address public longShort;
  address public floatToken;

  
  mapping(uint32 => uint256) public marketLaunchIncentive_period; 
  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; 
  mapping(uint32 => uint256) public marketUnstakeFee_e18;
  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;
  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;

  mapping(uint32 => mapping(bool => address)) public syntheticTokens;

  mapping(address => uint32) public marketIndexOfToken;

  
  mapping(uint32 => uint256) public latestRewardIndex;
  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))
    public accumulativeFloatPerSyntheticTokenSnapshots;
  struct AccumulativeIssuancePerStakedSynthSnapshot {
    uint256 timestamp;
    uint256 accumulativeFloatPerSyntheticToken_long;
    uint256 accumulativeFloatPerSyntheticToken_short;
  }

  
  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;
  mapping(address => mapping(address => uint256)) public userAmountStaked;

  
  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;
  
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;
  
  
  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;
  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;
  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;
  
  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;

  

  event StakerV1(
    address admin,
    address floatTreasury,
    address floatCapital,
    address floatToken,
    uint256 floatPercentage
  );

  event MarketAddedToStaker(
    uint32 marketIndex,
    uint256 exitFee_e18,
    uint256 period,
    uint256 multiplier,
    uint256 balanceIncentiveExponent,
    int256 balanceIncentiveEquilibriumOffset
  );

  event AccumulativeIssuancePerStakedSynthSnapshotCreated(
    uint32 marketIndex,
    uint256 accumulativeFloatIssuanceSnapshotIndex,
    uint256 accumulativeLong,
    uint256 accumulativeShort
  );

  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);

  event StakeWithdrawn(address user, address token, uint256 amount);

  
  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);

  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);

  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);

  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);

  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);

  event FloatPercentageUpdated(uint256 floatPercentage);

  event SyntheticTokensShifted();

  event ChangeAdmin(address newAdmin);

  

  function onlyAdminModifierLogic() internal virtual {
    require(msg.sender == admin, ""not admin"");
  }

  modifier onlyAdmin() {
    onlyAdminModifierLogic();
    _;
  }

  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {
    require(marketIndexOfToken[_synth] != 0, ""not valid synth"");
  }

  modifier onlyValidSynthetic(address _synth) {
    onlyValidSyntheticModifierLogic(_synth);
    _;
  }

  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {
    require(address(syntheticTokens[marketIndex][true]) != address(0), ""not valid market"");
  }

  modifier onlyValidMarket(uint32 marketIndex) {
    onlyValidMarketModifierLogic(marketIndex);
    _;
  }

  function onlyLongShortModifierLogic() internal virtual {
    require(msg.sender == address(longShort), ""not long short"");
  }

  modifier onlyLongShort() {
    onlyLongShortModifierLogic();
    _;
  }

  

  
  function initialize(
    address _admin,
    address _longShort,
    address _floatToken,
    address _floatTreasury,
    address _floatCapital,
    uint256 _floatPercentage
  ) external virtual initializer {
    admin = _admin;
    floatCapital = _floatCapital;
    floatTreasury = _floatTreasury;
    longShort = _longShort;
    floatToken = _floatToken;

    _changeFloatPercentage(_floatPercentage);

    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);
  }

  

  
  function changeAdmin(address _admin) external onlyAdmin {
    admin = _admin;
    emit ChangeAdmin(_admin);
  }

  
  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {
    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); 
    floatPercentage = newFloatPercentage;
  }

  
  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {
    _changeFloatPercentage(newFloatPercentage);
    emit FloatPercentageUpdated(newFloatPercentage);
  }

  
  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {
    require(newMarketUnstakeFee_e18 <= 5e16); 
    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;
  }

  
  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {
    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);
    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);
  }

  
  function _changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) internal virtual {
    require(initialMultiplier >= 1e18, ""marketLaunchIncentiveMultiplier must be >= 1e18"");

    marketLaunchIncentive_period[marketIndex] = period;
    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;
  }

  
  function changeMarketLaunchIncentiveParameters(
    uint32 marketIndex,
    uint256 period,
    uint256 initialMultiplier
  ) external onlyAdmin {
    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);

    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);
  }

  
  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    internal
    virtual
  {
    require(
      
      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,
      ""balanceIncentiveCurve_exponent out of bounds""
    );

    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;
  }

  
  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);

    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);
  }

  
  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    internal
    virtual
  {
    
    require(
      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,
      ""balanceIncentiveCurve_equilibriumOffset out of bounds""
    );

    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;
  }

  
  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)
    external
    onlyAdmin
  {
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);

    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
  }

  

  
  function addNewStakingFund(
    uint32 marketIndex,
    address longToken,
    address shortToken,
    uint256 kInitialMultiplier,
    uint256 kPeriod,
    uint256 unstakeFee_e18,
    uint256 _balanceIncentiveCurve_exponent,
    int256 _balanceIncentiveCurve_equilibriumOffset
  ) external override onlyLongShort {
    marketIndexOfToken[longToken] = marketIndex;
    marketIndexOfToken[shortToken] = marketIndex;

    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;

    syntheticTokens[marketIndex][true] = longToken;
    syntheticTokens[marketIndex][false] = shortToken;

    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);
    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);
    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);

    _changeUnstakeFee(marketIndex, unstakeFee_e18);

    
    batched_stakerNextTokenShiftIndex[marketIndex] = 1;

    emit MarketAddedToStaker(
      marketIndex,
      unstakeFee_e18,
      kPeriod,
      kInitialMultiplier,
      _balanceIncentiveCurve_exponent,
      _balanceIncentiveCurve_equilibriumOffset
    );

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);
  }

  

  
  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256 period, uint256 multiplier)
  {
    period = marketLaunchIncentive_period[marketIndex];
    multiplier = marketLaunchIncentive_multipliers[marketIndex];

    if (multiplier < 1e18) {
      multiplier = 1e18; 
    }
  }

  
  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {
    
    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);

    
    
    assert(kInitialMultiplier >= 1e18);

    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;

    if (block.timestamp - initialTimestamp <= kPeriod) {
      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);
    } else {
      return 1e18;
    }
  }

  
  function _calculateFloatPerSecond(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {
    
    
    uint256 k = _getKValue(marketIndex);

    uint256 totalLocked = (longValue + shortValue);

    

    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *
      int256(totalLocked)) / 2e18;

    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);

    
    
    
    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        
        
        return (0, 1e18 * k * shortPrice);
      }

      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      
      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    } else {
      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {
        
        
        return (1e18 * k * longPrice, 0);
      }

      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>
        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];

      
      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;
      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;

      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);
    }
  }

  
  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)
    internal
    view
    virtual
    returns (uint256)
  {
    return
      block.timestamp -
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;
  }

  
  function _calculateNewCumulativeIssuancePerStakedSynth(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {
    
    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(
      marketIndex,
      longPrice,
      shortPrice,
      longValue,
      shortValue
    );

    
    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);

    
    return (
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),
      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]
      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)
    );
  }

  
  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue
  ) internal virtual {
    (
      uint256 newLongAccumulativeValue,
      uint256 newShortAccumulativeValue
    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);

    uint256 newIndex = latestRewardIndex[marketIndex] + 1;

    
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]
    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;

    
    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;

    
    latestRewardIndex[marketIndex] = newIndex;

    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(
      marketIndex,
      newIndex,
      newLongAccumulativeValue,
      newShortAccumulativeValue
    );
  }

  
  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(
    uint32 marketIndex,
    uint256 longPrice,
    uint256 shortPrice,
    uint256 longValue,
    uint256 shortValue,
    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted 
  ) external override onlyLongShort {
    

    
    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {
      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;
      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[
        batched_stakerNextTokenShiftIndex[marketIndex]
      ] = latestRewardIndex[marketIndex] + 1;
      batched_stakerNextTokenShiftIndex[marketIndex] += 1;

      emit SyntheticTokensShifted();
    }

    
    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {
      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(
        marketIndex,
        longPrice,
        shortPrice,
        longValue,
        shortValue
      );
    }
  }

  

  
  function _calculateAccumulatedFloatInRange(
    uint32 marketIndex,
    uint256 amountStakedLong,
    uint256 amountStakedShort,
    uint256 rewardIndexFrom,
    uint256 rewardIndexTo
  ) internal view virtual returns (uint256 floatReward) {
    if (amountStakedLong > 0) {
      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_long -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_long;
      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }

    if (amountStakedShort > 0) {
      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]
      .accumulativeFloatPerSyntheticToken_short -
        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]
        .accumulativeFloatPerSyntheticToken_short;
      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;
    }
  }

  
  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {
    address longToken = syntheticTokens[marketIndex][true];
    address shortToken = syntheticTokens[marketIndex][false];

    uint256 amountStakedLong = userAmountStaked[longToken][user];
    uint256 amountStakedShort = userAmountStaked[shortToken][user];

    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];

    
    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {
      return 0;
    }

    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];
    
    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]
      );

      
      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {
        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],
          true,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;
      }

      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {
        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(
          marketIndex,
          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],
          false,
          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]
        );

        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];
        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;
      }

      
      userAmountStaked[longToken][user] = amountStakedLong;
      userAmountStaked[shortToken][user] = amountStakedShort;

      floatReward += _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],
        latestRewardIndex[marketIndex]
      );

      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;
    } else {
      floatReward = _calculateAccumulatedFloatInRange(
        marketIndex,
        amountStakedLong,
        amountStakedShort,
        usersLastRewardIndex,
        latestRewardIndex[marketIndex]
      );
    }
  }

  
  function _mintFloat(address user, uint256 floatToMint) internal virtual {
    IFloatToken(floatToken).mint(user, floatToMint);
    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);
  }

  
  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {
    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);

    if (floatToMint > 0) {
      
      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

      _mintFloat(user, floatToMint);
      emit FloatMinted(user, marketIndex, floatToMint);
    }
  }

  
  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {
    uint256 floatTotal = 0;
    for (uint256 i = 0; i < marketIndexes.length; i++) {
      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);

      if (floatToMint > 0) {
        
        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];

        floatTotal += floatToMint;

        emit FloatMinted(user, marketIndexes[i], floatToMint);
      }
    }
    if (floatTotal > 0) {
      _mintFloat(user, floatTotal);
    }
  }

  
  function claimFloatCustom(uint32[] calldata marketIndexes) external {
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);
  }

  
  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {
    
    
    ILongShort(longShort).updateSystemStateMulti(marketIndexes);
    _mintAccumulatedFloatMulti(marketIndexes, user);
  }

  

  
  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);
    _stake((msg.sender), amount, from);
  }

  
  function _stake(
    address token,
    uint256 amount,
    address user
  ) internal virtual {
    uint32 marketIndex = marketIndexOfToken[token];

    
    if (
      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&
      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, user);
    }

    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;

    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];

    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);
  }

  
  function shiftTokens(
    uint256 amountSyntheticTokensToShift,
    uint32 marketIndex,
    bool isShiftFromLong
  ) external virtual {
    address token = syntheticTokens[marketIndex][isShiftFromLong];
    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, ""Not enough tokens to shift"");

    
    
    if (
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&
      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <
      batched_stakerNextTokenShiftIndex[marketIndex]
    ) {
      _mintAccumulatedFloat(marketIndex, msg.sender);
    }

    if (isShiftFromLong) {
      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    } else {
      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);
      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][
        msg.sender
      ] += amountSyntheticTokensToShift;
    }

    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[
      marketIndex
    ];
  }

  

  
  function _withdraw(
    uint32 marketIndex,
    address token,
    uint256 amount
  ) internal virtual {
    require(userAmountStaked[token][msg.sender] > 0, ""nothing to withdraw"");
    _mintAccumulatedFloat(marketIndex, msg.sender);

    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;

    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;

    IERC20(token).transfer(floatTreasury, amountFees);
    IERC20(token).transfer(msg.sender, amount - amountFees);

    emit StakeWithdrawn(msg.sender, token, amount);
  }

  
  function withdraw(address token, uint256 amount) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    _withdraw(marketIndex, token, amount);

    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {
      
      
      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

      require(
        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,
        ""Outstanding next price stake shifts too great""
      );
    }
  }

  
  function withdrawAll(address token) external {
    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);

    uint32 marketIndex = marketIndexOfToken[token];

    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token
      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]
      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];

    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);
  }
}",6409.0,2,1,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Division by Zero in Incentive Calculation**  
   In `_calculateFloatPerSecond`, if the `totalLocked` value (right-shifted by 52 bits) results in zero, the denominator becomes zero. This causes a division by zero error when calculating rewards, leading to transaction reverts. This can occur in markets with small total locked values, effectively halting reward distribution.

2. **Underflow in `withdrawAll` Function**  
   If a user's pending token shift amount exceeds their current staked balance, the `withdrawAll` function will attempt an underflow during subtraction (due to Solidity's checked arithmetic), causing a revert. This prevents the user from withdrawing any funds until the shift is resolved.

3. **Incorrect Price Index Mapping During Token Shifts**  
   Token shifts rely on price snapshots mapped via `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping`. If this mapping is incorrect, token conversions during shifts may use outdated or invalid prices, leading to incorrect staked balances and potential loss of rewards.

4. **Unbounded Loops in Reward Claims**  
   The `claimFloatCustom` and `claimFloatCustomFor` functions loop over an arbitrary array of market indices. A large array could exhaust gas limits, causing transaction failures and denial-of-service for reward claims.

5. **Use of `assert` in `_getKValue`**  
   The `assert(kInitialMultiplier >= 1e18)` statement consumes all gas on failure. While intended as an invariant check, it should use `require` for input validation to avoid unnecessary gas consumption.

6. **Insufficient Validation in `withdrawAll`**  
   The function does not validate if the user's pending shift amount exceeds their staked balance, leading to potential underflow reverts and locked funds.

7. **Precision Loss in Reward Calculations**  
   Truncation during division operations (e.g., `numerator * 5e17 / denominator`) may result in users receiving fewer rewards than expected, especially when values are small or incentive parameters are misconfigured.

8. **Stale Reward Index Handling**  
   If a user's `userIndexOfLastClaimedReward` is not properly updated across multiple shifts or updates, accumulated rewards might be miscalculated, leading to incorrect minting of Float tokens.

9. **Potential Front-Running in System Updates**  
   Although mitigated by calling `updateSystemState`, delays between state updates and user actions could allow front-running to manipulate reward calculations or token shifts.

10. **Incorrect Equilibrium Offset Handling**  
    Extreme values for `balanceIncentiveCurve_equilibriumOffset` could cause negative adjusted values in `_calculateFloatPerSecond`, leading to incorrect reward splits between long and short positions if not properly validated.","### **Output**

---

**[H-02] 2 variables not indexed by marketIndex**

**Report Description**:  
In the function `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`, the variables `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` and `stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping` are not indexed by `marketIndex`. This can lead to overwriting of values if `batched_stakerNextTokenShiftIndex[market1] == batched_stakerNextTokenShiftIndex[market2]`. This issue can cause incorrect calculations in `_calculateAccumulatedFloat`, leading to improper allocation of float tokens.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of variables not being indexed by `marketIndex`, which is a critical oversight in the contract's design. This omission could lead to significant miscalculations in float token issuance.

---

**[H-03] Users could shift tokens on `Staker` with more than he has staked**

**Report Description**:  
The `shiftTokens` function in `Staker` checks if the user has staked at least the number of tokens they want to shift. However, a user could call this function multiple times before the next price update, allowing them to shift more tokens than they have staked. This could lead to manipulation of the staking system. The recommendation is to add checks on `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short` to ensure the sum does not exceed the user's stake balance.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of users shifting more tokens than they have staked. This is a critical vulnerability that could allow users to manipulate the staking system, and it is not covered in the response list.

---

**[M-04] Staker.sol: Wrong values returned in edge cases of `_calculateFloatPerSecond()`**

**Report Description**:  
In the `_calculateFloatPerSecond` function, the edge cases where full rewards go to either the long or short token return values that are `1e18` times too large. This can lead to extremely large float token issuance rates, which would be disastrous. The edge cases should return `(k * longPrice, 0)` and `(0, k * shortPrice)` instead of `(1e18 * k * longPrice, 0)` and `(0, 1e18 * k * shortPrice)`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect values being returned in edge cases of `_calculateFloatPerSecond`. This is a significant vulnerability that could lead to incorrect reward calculations and is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- **[H-02] 2 variables not indexed by marketIndex**  
- **[H-03] Users could shift tokens on `Staker` with more than he has staked**  
- **[M-04] Staker.sol: Wrong values returned in edge cases of `_calculateFloatPerSecond()`**

---

### **Conclusion**

The `response_list` does not adequately address the issues identified in the `issue` report. Specifically, it misses critical vulnerabilities related to variable indexing, token shifting, and incorrect reward calculations. These omissions could lead to significant security risks and incorrect contract behavior. It is essential to address these issues to ensure the contract's security and functionality.",0,0,3,10,"Okay, let's take a look at this Staker contract and try to find any vulnerabilities. I'm new to this, so I'll start by going through each part step by step.

First, the contract imports several OpenZeppelin and custom interfaces. The contract is Initializable, which suggests it's part of an upgradeable setup. The admin has various privileges, which could be a centralization risk if compromised. But the question is about vulnerabilities, not mitigation, so maybe that's not a direct issue here.

Looking at the mappings, there's a lot of state variables tracking user stakes, rewards, and shifts between long/short positions. The functions include staking, withdrawing, shifting tokens between positions, and claiming rewards. 

Possible vulnerabilities:

1. **Reentrancy**: Check if there are any external calls that could be exploited. The withdraw function transfers tokens after updating the state. Since it uses transfer, which forwards 2300 gas, maybe that's safe. But if there's a function that calls an external contract before updating state, that could be a problem. Let me check.

   In `_withdraw`, they transfer tokens after reducing the user's balance. So the state is updated before the transfer. That's good. But wait, in `withdrawAll`, it calls `_withdraw` with `userAmountStaked[token][msg.sender] - amountToShiftForThisToken`. If there's a miscalculation here, maybe an underflow? Let's see. The subtraction could underflow if amountToShiftForThisToken is larger than the user's stake. But the `withdraw` function checks that the user's balance is sufficient. However, in `withdrawAll`, `amountToShiftForThisToken` is part of the user's staked amount. Maybe if the user has pending shifts, but their actual balance is less, the subtraction might underflow. For example, if a user has 100 staked, and a shift of 150 pending. Then 100 - 150 would underflow. But in `withdrawAll`, `amountToShiftForThisToken` is derived from the user's own staked amounts. Wait, `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` and similar mappings track the amounts the user is shifting. But if those amounts are greater than the user's current stake, the subtraction here would underflow. So `withdrawAll` might be vulnerable to underflow here if the user has a shift amount larger than their current stake. But how can that happen? Maybe if they shifted and then some tokens were removed. Let's check the code.

   The `withdraw` function checks that `userAmountStaked[token][msg.sender] >= amountToShiftForThisToken` after withdrawal. But in `withdrawAll`, it's possible that after subtracting `amountToShiftForThisToken`, the remaining amount could be negative. For example, if user has 100 staked, but `amountToShiftForThisToken` is 150. Then `100 - 150` would be negative, causing an underflow. But since Solidity 0.8.x uses checked math, this would revert. So maybe that's not a vulnerability but a possible revert scenario. However, the `withdrawAll` function may not handle this properly. If the user has pending shifts, but their actual stake is less than the shift amount, trying to withdraw all would revert. So that could be a DoS for the user. Not sure if this counts as a vulnerability, but it's a possible issue.

2. **Incorrect Reward Calculation**: The `_calculateAccumulatedFloat` function handles shifts in positions. When a user shifts tokens, their staked amounts are adjusted in the next price update. However, if during the calculation, the shifted amounts are not properly accounted for, rewards could be miscalculated. For example, when shifting tokens, the code adds the shifted amount to the opposite side. If the price snapshot index is incorrect, the conversion might be wrong, leading to incorrect reward calculations.

3. **Access Control**: The `onlyAdmin` modifier is used for critical functions like changing parameters. If the admin is compromised, an attacker can change fees, incentives, etc. But the question states not to consider mitigation, so maybe this is not a vulnerability but a centralization risk note.

4. **Division Precision**: The contract uses several divisions, especially in reward calculations. For example, in `_calculateFloatPerSecond`, divisions by 1e18 could lead to truncation errors if not handled properly. If variables are not scaled correctly, this might result in loss of precision, affecting reward distribution.

5. **Unbounded Loops**: The `claimFloatCustom` and `claimFloatCustomFor` functions loop over an array of market indexes. If the array is too large, this could exceed the block gas limit, causing the transaction to fail. However, the function is external and the user provides the array, so it's up to the user to manage, but still a potential vulnerability if not handled.

6. **Front-Running**: When users stake or shift positions, the reward calculation depends on the latest reward index. If another transaction updates the reward index before the user's transaction, their rewards might be calculated based on outdated data. However, the functions call `updateSystemState` which might update the state first, so this might be mitigated. Need to check if `updateSystemState` is called before modifying user positions.

7. **Incorrect Fee Application**: In the `_withdraw` function, the fee is calculated as `(amount * marketUnstakeFee_e18[marketIndex]) / 1e18`. If `marketUnstakeFee_e18` is not properly validated, it could be set to a value higher than intended, leading to excessive fees. However, the `_changeUnstakeFee` function checks that the fee is <=5e16 (5%), so that's probably okay.

8. **Incorrect K Value Calculation**: In `_getKValue`, the code uses `block.timestamp - initialTimestamp` to determine the time elapsed. If the initialTimestamp is not correctly initialized, this could lead to incorrect K values. For example, if `initialTimestamp` is zero (which shouldn't happen as it's set in `addNewStakingFund`). But maybe if the market hasn't been added properly?

9. **Token Shift Index Handling**: When shifting tokens, the code uses `batched_stakerNextTokenShiftIndex` to track shifts. If there's an error in mapping the indices between shifts and price snapshots, users might not receive the correct rewards when shifts are executed. For example, if `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` is not properly updated, the conversion from shifted amounts could use an incorrect price snapshot, leading to wrong token amounts.

10. **Uninitialized Market**: The `addNewStakingFund` function initializes a new market. If the marketIndex is reused or not properly initialized, it could lead to data corruption. For example, if `syntheticTokens[marketIndex][true]` is already set, adding a new market with the same index would overwrite existing data. But the function is only callable by `longShort`, so maybe it's controlled. However, there's no check that the marketIndex is not already in use.

11. **Rounding Errors in Incentive Calculations**: The `_calculateFloatPerSecond` function has several divisions and multiplications. If the numerator in the balance incentive calculation is small, the division by `denominator` could result in zero, leading to no rewards being distributed. For instance, if `denominator` is very large due to high exponent values, even if the numerator is non-zero, the division could truncate to zero.

12. **Use of `assert` in `_getKValue`**: There's an `assert(kInitialMultiplier >= 1e18)`. However, `assert` is meant for invariants and consumes all gas if failed, unlike `require`. But since `_getMarketLaunchIncentiveParameters` ensures that `multiplier` is at least 1e18, this might not be an issue. Still, using `assert` here is unnecessary and could be replaced with a `require` for better practice.

13. **Missing Event Emissions**: For critical state changes like updating the admin, events are emitted. But are there any state changes that lack events, making it hard to track off-chain? For example, when `userNextPrice_stakedSyntheticTokenShiftIndex` is reset, there's no event. Not a vulnerability per se, but could affect monitoring.

14. **Possible Integer Overflows/Underflows**: Even with Solidity 0.8's checked math, some variables could be manipulated in ways that cause unexpected reverts. For example, in `_calculateAccumulatedFloatInRange`, if `accumDeltaLong` is negative (which shouldn't happen as it's computed as a difference between increasing accumulative values), the subtraction would underflow. However, since `rewardIndexTo` is always greater than `rewardIndexFrom`, this shouldn't be an issue. But if somehow `rewardIndexFrom` is greater than `rewardIndexTo`, it would underflow. However, the code ensures that `rewardIndexTo` is the latest index, so maybe this is safe.

15. **Incorrect Balance Tracking After Shifts**: When shifting tokens, the code adds the shifted amount to the opposite side. For example, shifting from long to short converts the amount using the price from a snapshot. If the price snapshot is incorrect or outdated, the converted amount might not reflect the actual value, leading to incorrect staked balances. This could be exploited if the price is manipulated at the time of the snapshot.

16. **Unhandled Edge Cases in Incentive Curve Parameters**: The `balanceIncentiveCurve_equilibriumOffset` is checked to be within certain bounds, but if set to extreme allowed values, it might lead to unintended behavior. For example, if `equilibriumOffsetMarketScaled` is almost equal to `shortValue`, the numerator in the incentive calculation could become zero or negative, leading to potential underflows or incorrect reward distribution.

17. **Lack of Input Validation in `stakeFromUser`**: The `stakeFromUser` function is called with `msg.sender` as the token, but if a malicious contract pretends to be a synthetic token, could this lead to unauthorized stakes? The `onlyValidSynthetic` modifier checks that `marketIndexOfToken[_synth]` is not zero. So unless a fake token is added via `addNewStakingFund`, which is only callable by `longShort`, this is probably safe. So the input validation here is adequate.

18. **Missing Checks-Effects-Interactions Pattern**: In `_withdraw`, the function transfers tokens after updating the state. That's correct. But in other functions, like `shiftTokens`, external calls to `ILongShort` are made before updating the user's state. However, since `ILongShort` is a trusted contract (as it's set by admin), this might not be an issue. Still, if the external call were to a malicious contract, it could reenter. But since the code uses `onlyLongShort` modifier, which checks `msg.sender == longShort`, this is controlled.

19. **Incorrect Index Handling in `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations`**: When updating the accumulative snapshots, the code increments `batched_stakerNextTokenShiftIndex` and maps the new index to a price snapshot. If this is not properly synchronized with the LongShort contract's state, it could lead to incorrect mappings. For example, if the `stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping` points to an invalid index, the token shift calculations would use the wrong price data.

20. **Stale Data in Reward Calculation**: If a user hasn't claimed rewards for a long time, and multiple snapshots have been created, the `_calculateAccumulatedFloat` function loops through all the ranges. However, this is handled by tracking the last claimed index, so it shouldn't be a problem. The function processes all unclaimed intervals, which is efficient.

Hmm, that's a lot of points. Now, I need to prioritize which of these are actual vulnerabilities versus potential code smells or issues that are mitigated by design.

From the above, the key vulnerabilities I can identify are:

- **Underflow in `withdrawAll`**: If the user's pending shift amount is greater than their current stake, subtracting them would cause an underflow. Since Solidity 0.8.x uses checked math, this would revert the transaction. This could lock the user's funds if they can't withdraw because of an underflow. However, the `withdraw` function checks that after withdrawal, the user's remaining balance is >= the shift amount. But `withdrawAll` doesn't have such a check. For example, if a user has 100 staked and a pending shift of 150, `withdrawAll` would try to withdraw 100 - 150 = negative, causing a revert. The user would not be able to withdraw anything until they reduce their pending shift. But how can the pending shift exceed their stake? Maybe if they shifted and then some tokens were slashed or burned. But the system might not account for that. This could be a vulnerability as it locks the user's funds.

- **Incorrect Conversion During Token Shifts**: When shifting tokens, the code uses `ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide` with a snapshot index. If the snapshot index is incorrect (e.g., due to a wrong mapping), the converted amount could be wrong, leading to incorrect staked balances. This could allow manipulation if the price snapshot can be influenced.

- **Unbounded Loops in `claimFloatCustom`**: If a user passes a very large array of market indexes, the loop could consume excessive gas, leading to a DoS. However, since the user controls the input, it's their responsibility, but the contract should have a limit to prevent this.

- **Division Precision in Incentive Calculations**: If the denominator in the incentive calculation is too large, the division could result in zero, leading to no rewards. This could happen if the exponent is high and the locked amounts are large, making the denominator very big, thus making the numerator/denominator ratio zero. For example, with exponent 5 and totalLocked shifted right by 52 bits, then raised to the 5th power, the denominator could be extremely large, leading to zero rewards.

Let me verify some of these:

Looking at `_calculateFloatPerSecond`:

The denominator is `(totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]`. `safeExponentBitShifting` is 52. So if totalLocked is 1e18 (assuming 18 decimals), shifting right by 52 gives 1e18 / 2^52 ≈ 2e-9, which when raised to exponent 5 (max allowed is <6) would be tiny. Then the numerator could be even smaller. Dividing these might lead to zero, resulting in no rewards. This could be a vulnerability where under certain conditions, no rewards are minted, even though they should be.

Another example: if the totalLocked is very small, the shifted value becomes zero, leading to a division by zero. Wait, no, the denominator would be zero, but the code requires that `balanceIncentiveCurve_exponent` is between 0 and 6 (exclusive). Wait, in `_changeBalanceIncentiveExponent`, the exponent is required to be >0 and <6. So exponents from 1 to 5. If `totalLocked >> 52` is zero (if totalLocked is less than 2^52), then the denominator is zero, leading to a division by zero error. Which would revert the transaction. That's a problem. For example, if the total locked value is small, this calculation would divide by zero. So if a market has just launched and totalLocked is small, this function would revert, preventing any rewards from being calculated. This could be a vulnerability as it could halt reward distribution for new markets.

Wait, let's check the code again. The `_changeBalanceIncentiveExponent` function requires that the exponent is greater than 0 and less than 6. So possible exponents are 1,2,3,4,5. If `totalLocked` is a small number, then `totalLocked >> 52` could be zero. Then `denominator` would be (0)^exponent, which is zero. Then when calculating `numerator * 5e17 / denominator`, it would be division by zero. This would cause a revert in `_calculateFloatPerSecond`, which is called by `_setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot`, which is part of the `pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations` function. This function is called by LongShort when updating the system state. If this reverts, it could prevent the system state from being updated, leading to a denial of service.

So this is a critical vulnerability. If the totalLocked in a market is less than 2^52 (which is a very large number, 4.5e15), but if the token has 18 decimals, then 2^52 units would be 4.5e15 / 1e18 = 0.0045 tokens. So if the total locked is less than that (which is possible in a new market), the denominator becomes zero, leading to a division by zero and reverting. This would block reward calculations and possibly other functions that depend on updating the system state.

Another vulnerability is the division by zero in the incentive calculation when totalLocked is small. That's a major issue.

Other possible issues:

In `_calculateFloatPerSecond`, when checking which side to calculate rewards for, if the equilibrium offset causes one side's value to be negative, the code has a condition to handle that. But if the equilibrium offset is such that the adjusted value is negative, it could lead to underflow when converting to uint256. However, the code checks if `equilibriumOffsetMarketScaled >= int256(shortValue)` or similar, which could prevent that. For example:

if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {
    if (equilibriumOffsetMarketScaled >= int256(shortValue)) {
        return (0, 1e18 * k * shortPrice);
    }
    ...
}

But `int256(shortValue) - equilibriumOffsetMarketScaled` could be negative, but then the code checks if `equilibriumOffsetMarketScaled >= int256(shortValue)`, which would mean the adjusted value is <=0, so returns 0 for long. But when calculating the numerator, `uint256(int256(shortValue) - equilibriumOffsetMarketScaled)` would underflow if the result is negative, which is possible if `equilibriumOffsetMarketScaled` is greater than `shortValue`. However, in that case, the code returns early with (0, 1e18 * k * shortPrice). Wait, no: in the code, if `equilibriumOffsetMarketScaled >= int256(shortValue)`, it returns (0, ...). So in that case, `int256(shortValue) - equilibriumOffsetMarketScaled` is negative, but the code returns early. However, in the else case, when `int256(shortValue) - equilibriumOffsetMarketScaled` is >= `int256(longValue)`, then the code checks if `-equilibriumOffsetMarketScaled >= int256(longValue)`, which would also lead to returning early. 

But in the cases where it proceeds to calculate the numerator, the adjusted values are positive. So maybe that's handled. However, there's a potential for miscalculations if the equilibrium offset is not properly handled, leading to incorrect reward distributions.

Another vulnerability is the division by zero in the incentive calculation when the denominator is zero. This is a critical issue as it would prevent any rewards from being issued for a market with low total locked value.

So summarizing the vulnerabilities:

1. **Division by Zero in Incentive Calculation**: When the total locked value (shifted right by 52 bits) is zero, the denominator becomes zero, causing a revert. This can occur in new markets with low total stakes, leading to a denial of service in reward distribution.

2. **Underflow in `withdrawAll`**: If a user's pending shift amount exceeds their current stake, attempting to withdraw all would underflow, reverting the transaction and preventing withdrawal.

3. **Incorrect Token Conversion During Shifts**: If the price snapshot index mapped to a token shift is incorrect, the converted token amounts could be wrong, leading to incorrect staked balances and potential loss of funds.

4. **Unbounded Loops in Reward Claims**: Looping over an arbitrary number of markets in `claimFloatCustom` could lead to gas exhaustion and transaction failure.

5. **Potential Front-Running in Reward Claims**: Although mitigated by updating the system state first, if the `updateSystemState` is not properly called, users might get outdated rewards.

6. **Use of `assert` in `_getKValue`**: Although likely safe, using `assert` instead of `require` for input validation could unnecessarily consume all gas on failure.

Among these, the most critical are the division by zero in incentive calculations and the underflow in `withdrawAll`.

Another point to consider: the `_changeFloatPercentage` function requires `newFloatPercentage` to be <=1e18 and >0. However, if `newFloatPercentage` is set to 1e18, then `(floatToMint * floatPercentage) / 1e18` equals `floatToMint`, which would mean all the Float is minted to `floatCapital`, leaving nothing for the user. But the require statement allows `newFloatPercentage <=1e18`, which would permit 100% allocation to `floatCapital`, which might not be intended. However, the comment says `newFloatPercentage` must be >0. So setting it to 1e18 would result in users getting 0 Float when they claim. This could be a misconfiguration, but since the admin can set this, it's a governance issue rather than a code vulnerability.

Another thing: the `stakeFromUser` function is an override with `onlyValidSynthetic(msg.sender)`. The `msg.sender` here is the synthetic token. So when a user calls `stakeFromUser`, the token must be a valid one. But how does the user call this function? Typically, staking would involve transferring tokens to the staker contract. However, in this code, `stakeFromUser` is called by the synthetic token itself via some mechanism (maybe via an ERC20's transfer hook). If the synthetic tokens are not implementing a hook to call `stakeFromUser`, this function might not be called correctly. However, the code seems to expect that the synthetic tokens are calling this function, but if they don't, then users can't stake. This could be a integration issue rather than a vulnerability in the Staker contract itself.

Also, in `stakeFromUser`, the function is `public` and overrides an interface function. But since it's supposed to be called by the synthetic token contract, maybe it should be `external`. However, in Solidity, `public` is fine. Not a vulnerability, but a code style note.

Back to vulnerabilities:

The division by zero is critical. Let's see:

In `_calculateFloatPerSecond`, denominator is `((totalLocked >> safeExponentBitShifting) ** balanceIncentiveCurve_exponent)`. If `totalLocked >> 52` is 0 (i.e., totalLocked < 2^52), then denominator is 0. Then, when dividing `numerator * 5e17` by denominator, it's division by zero. This would revert the entire transaction. This would happen whenever the total locked is below 2^52, which is possible in the early stages of a market. This would prevent any new rewards from being calculated, effectively halting the staking rewards for that market. This is a critical vulnerability as it can cause the contract to become unusable for new or small markets.

Another possible issue: the `safeExponentBitShifting` is 52, which is a magic number. If the token has a different decimal scale, shifting by 52 might not be appropriate. For example, if the token uses 6 decimals (like USDC), shifting by 52 would reduce the value significantly, possibly leading to truncation to zero more often, increasing the chance of division by zero. However, the code seems to be designed for 18 decimal tokens, so this is a potential integration issue but not a vulnerability in the contract itself.

So, to list the vulnerabilities:

1. **Division by Zero in Incentive Calculation**: When total locked value is too small, leading to a zero denominator in the incentive calculation, causing transaction reverts and preventing reward distribution.

2. **Underflow in `withdrawAll`**: If a user's pending shift amount exceeds their staked amount, causing an underflow and preventing withdrawal.

3. **Incorrect Price Index Mapping in Token Shifts**: If the price snapshot index for a token shift is incorrect, leading to wrong token conversions and staked amounts.

4. **Unbounded Loops Leading to Gas Exhaustion**: When claiming rewards across many markets, causing the transaction to fail due to out-of-gas errors.

5. **Use of `assert` Instead of `require`**: In `_getKValue`, using `assert` which consumes all gas on failure, which is unnecessary and could be a potential DoS vector if triggered.

6. **Insufficient Validation in `withdrawAll`**: Allowing users to attempt withdrawals that would underflow due to pending shifts, leading to transaction reverts and locked funds.

7. **Potential Precision Loss in Reward Calculations**: Due to truncation in divisions, leading to users receiving fewer rewards than expected, especially in cases with small reward amounts.

The most severe are the division by zero and the underflow in `withdrawAll`.

Another possible vulnerability is in the `_mintAccumulatedFloat` function. When a user claims rewards, the code mints Float tokens. However, if the calculation of `floatToMint` is incorrect, users could receive more or fewer tokens than they should. For example, if the accumulative values are not properly updated, but that's more of a correctness issue than a vulnerability.

Also, in the `shiftTokens` function, if the user shifts tokens multiple times before the shift is executed, the `userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long` or `short` could accumulate. However, the code allows this, and when the shift is executed, all accumulated amounts are converted. This is correct as per the design, but if there's a miscalculation in the conversion, it could lead to incorrect balances. However, this relies on the LongShort contract's `getAmountSyntheticTokenToMintOnTargetSide` function to be correct.

In summary, the main vulnerabilities I can identify are:

- Division by zero in `_calculateFloatPerSecond` when totalLocked is small, leading to DoS in reward distribution.
- Underflow in `withdrawAll` when pending shifts exceed staked amounts, preventing withdrawals.
- Incorrect token conversion during shifts due to wrong price indices.
- Unbounded loops causing gas exhaustion.","```
None.
```",0.0
,,,,,,,,3,3,,,0,0,6,25,,,
