nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,Reasoning_Content,matchList,MAP
ExtraRewardsDistributor.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";

/**
 * @title   ExtraRewardsDistributor
 * @author  adapted from ConvexFinance
 * @notice  Allows anyone to distribute rewards to the AuraLocker at a given epoch.
 */
contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    // token -> epoch -> amount
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    // token -> epochList
    mapping(address => uint256[]) public rewardEpochs;
    // token -> account -> last claimed epoch index
    mapping(address => mapping(address => uint256)) public userClaims;

    /* ========== EVENTS ========== */

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    /**
     * @dev Simple constructoor
     * @param _auraLocker Aura Locker address
     */
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    /* ========== ADD REWARDS ========== */

    /**
     * @notice Add a reward to the current epoch. can be called multiple times for the same reward token
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokenπ
     */
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    /**
     * @notice Add reward token to a specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens to add
     * @param _epoch    Which epoch to add to (must be less than the previous epoch)
     */
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    /**
     * @notice  Transfer reward tokens from sender to contract for vlCVX holders
     * @dev     Add reward token for specific epoch
     * @param _token    Reward token address
     * @param _amount   Amount of reward tokens
     * @param _epoch    Epoch to add tokens to
     */
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        // Pull before reward accrual
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        //convert to reward per token
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        //add epoch to list
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        //event
        emit RewardAdded(_token, _epoch, _amount);
    }

    /* ========== GET REWARDS ========== */

    /**
     * @notice Claim rewards for a specific token since the first epoch.
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account      Address of vlCVX holder
     * @param _token        Reward token address
     * @param _startIndex   Index of rewardEpochs[_token] to start checking for rewards from
     */
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    /**
     * @notice Claim rewards for a specific token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        //get claimable tokens
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            //set claim checkpoint
            userClaims[_token][_account] = index;

            //send
            IERC20(_token).safeTransfer(_account, claimableTokens);

            //event
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    /**
     * @notice  Allow a user to set their claimed index forward without claiming rewards
     *          Because claims cycle through all periods that a specific reward was given
     *          there becomes a situation where, for example, a new user could lock
     *          2 years from now and try to claim a token that was given out every week prior.
     *          This would result in a 2mil gas checkpoint.(about 20k gas * 52 weeks * 2 years)
     * @param _token  Reward token to forfeit
     * @param _index  Epoch index to forfeit from
     */
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        //set claim checkpoint. next claim starts from index+1
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    /* ========== VIEW REWARDS ========== */

    /**
     * @notice Get claimable rewards (rewardToken) for vlCVX holder
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token address
     */
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    /**
     * @notice  Get all claimable rewards by looping through each epoch starting with the latest
     *          saved epoch the user last claimed from
     * @param _account  Address of vlCVX holder
     * @param _token    Reward token
     * @param _startIndex  Index of rewardEpochs[_token] to start checking for rewards from
     */
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        // e.g. tokenEpochs = 31, 21
        uint256 tokenEpochs = rewardEpochs[_token].length;

        // e.g. epochIndex = 0
        uint256 epochIndex = userClaims[_token][_account];
        // e.g. epochIndex = 27 > 0 ? 27 : 0 = 27
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            //only claimable after rewards are ""locked in""
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                //return index user claims should be set to
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    /**
     * @notice Get claimable rewards for a token at a specific epoch
     * @param _account     Address of vlCVX holder
     * @param _token       Reward token address
     * @param _epoch       The epoch to check for rewards
     */
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        //get balance and calc share
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    /**
     * @notice Simply gets the current epoch count for a given reward token
     * @param _token    Reward token address
     * @return _epochs  Number of epochs
     */
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",2365.0,268.0,"[H-01] User can forfeit other user rewards
User can forfeit other user rewards by giving a higher `_startIndex` in `getReward` function.
 
[M-05] Users can grief reward distribution
Users can grief reward distributions by spending dust.
If a reward is targeted for an epoch in the past, a user can front-run the txn in the mempool and call addRewardToEpoch() with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert
  [M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.   [M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens
If rewards are given in fee-on-transfer tokens, users may get no rewards, breaking functionality.",4.0,"pragma solidity ^0.8.11;

import { IExtraRewardsDistributor, IAuraLocker } from ""./Interfaces.sol"";
import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";


contract ExtraRewardsDistributor is ReentrancyGuard, IExtraRewardsDistributor {
    using SafeERC20 for IERC20;

    IAuraLocker public immutable auraLocker;

    
    mapping(address => mapping(uint256 => uint256)) public rewardData;
    
    mapping(address => uint256[]) public rewardEpochs;
    
    mapping(address => mapping(address => uint256)) public userClaims;

    

    event RewardAdded(address indexed token, uint256 indexed epoch, uint256 reward);
    event RewardPaid(address indexed user, address indexed token, uint256 reward, uint256 index);
    event RewardForfeited(address indexed user, address indexed token, uint256 index);

    
    constructor(address _auraLocker) {
        auraLocker = IAuraLocker(_auraLocker);
    }

    

    
    function addReward(address _token, uint256 _amount) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        _addReward(_token, _amount, latestEpoch);
    }

    
    function addRewardToEpoch(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) external {
        auraLocker.checkpointEpoch();

        uint256 latestEpoch = auraLocker.epochCount() - 1;
        require(_epoch <= latestEpoch, ""Cannot assign to the future"");

        if (_epoch == latestEpoch) {
            _addReward(_token, _amount, latestEpoch);
        } else {
            uint256 len = rewardEpochs[_token].length;
            require(len == 0 || rewardEpochs[_token][len - 1] < _epoch, ""Cannot backdate to this epoch"");

            _addReward(_token, _amount, _epoch);
        }
    }

    
    function _addReward(
        address _token,
        uint256 _amount,
        uint256 _epoch
    ) internal nonReentrant {
        
        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);

        
        uint256 supply = auraLocker.totalSupplyAtEpoch(_epoch);
        uint256 rPerT = (_amount * 1e20) / supply;
        rewardData[_token][_epoch] += rPerT;

        
        uint256 len = rewardEpochs[_token].length;
        if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
            rewardEpochs[_token].push(_epoch);
        }

        
        emit RewardAdded(_token, _epoch, _amount);
    }

    

    
    function getReward(address _account, address _token) public {
        _getReward(_account, _token, 0);
    }

    
    function getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        _getReward(_account, _token, _startIndex);
    }

    
    function _getReward(
        address _account,
        address _token,
        uint256 _startIndex
    ) public {
        
        (uint256 claimableTokens, uint256 index) = _allClaimableRewards(_account, _token, _startIndex);

        if (claimableTokens > 0) {
            
            userClaims[_token][_account] = index;

            
            IERC20(_token).safeTransfer(_account, claimableTokens);

            
            emit RewardPaid(_account, _token, claimableTokens, index);
        }
    }

    
    function forfeitRewards(address _token, uint256 _index) external {
        require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
        require(_index >= userClaims[_token][msg.sender], ""already claimed"");

        
        userClaims[_token][msg.sender] = _index + 1;

        emit RewardForfeited(msg.sender, _token, _index);
    }

    

    
    function claimableRewards(address _account, address _token) external view returns (uint256) {
        (uint256 rewards, ) = _allClaimableRewards(_account, _token, 0);
        return rewards;
    }

    
    function claimableRewardsAtEpoch(
        address _account,
        address _token,
        uint256 _epoch
    ) external view returns (uint256) {
        return _claimableRewards(_account, _token, _epoch);
    }

    
    function _allClaimableRewards(
        address _account,
        address _token,
        uint256 _startIndex
    ) internal view returns (uint256, uint256) {
        uint256 latestEpoch = auraLocker.epochCount() - 1;
        
        uint256 tokenEpochs = rewardEpochs[_token].length;

        
        uint256 epochIndex = userClaims[_token][_account];
        
        epochIndex = _startIndex > epochIndex ? _startIndex : epochIndex;

        if (epochIndex >= tokenEpochs) {
            return (0, tokenEpochs);
        }

        uint256 claimableTokens = 0;

        for (uint256 i = epochIndex; i < tokenEpochs; i++) {
            
            if (rewardEpochs[_token][i] < latestEpoch) {
                claimableTokens += _claimableRewards(_account, _token, rewardEpochs[_token][i]);
                
                epochIndex = i + 1;
            }
        }
        return (claimableTokens, epochIndex);
    }

    
    function _claimableRewards(
        address _account,
        address _token,
        uint256 _epoch
    ) internal view returns (uint256) {
        
        uint256 balance = auraLocker.balanceAtEpochOf(_epoch, _account);
        return (balance * rewardData[_token][_epoch]) / 1e20;
    }

    
    function rewardEpochsCount(address _token) external view returns (uint256) {
        return rewardEpochs[_token].length;
    }
}",1352.0,1,3,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Division by Zero in `_addReward`**  
   If `auraLocker.totalSupplyAtEpoch(_epoch)` returns zero when adding a reward, the calculation `(_amount * 1e20) / supply` will revert due to division by zero. This can occur if the epoch's locked supply is zero, leading to transaction failure and potential fund lockup.

2. **Dust Accumulation from Integer Truncation**  
   When rewards are distributed, integer division truncation in `rPerT = (_amount * 1e20) / supply` can leave residual tokens unclaimable in the contract. These dust amounts accumulate over time, permanently locking funds.

3. **Forfeited Rewards Permanently Locked**  
   The `forfeitRewards` function allows users to skip claiming rewards for specific epochs. However, the corresponding tokens for their share remain in the contract and become unclaimable by anyone, resulting in irreversible fund loss.

4. **Outdated Epoch Handling in `getReward`**  
   The `getReward` function relies on `auraLocker`'s latest epoch, which is only updated via `addReward` or `addRewardToEpoch`. If no new rewards are added, users cannot claim rewards from newly finalized epochs until a checkpoint occurs, causing delays.

5. **Unchecked Token Supply in Reward Distribution**  
   Adding rewards to epochs with zero token supply (e.g., via `addRewardToEpoch`) is permitted without validation, risking division by zero errors and disrupting reward distribution.

6. **Publicly Callable `_getReward` Function**  
   The `_getReward` function is `public`, allowing anyone to trigger reward claims for any address. While not directly exploitable, it could enable griefing by forcing unintended transactions or disrupting user reward strategies.

7. **Incomplete Index Validation in `forfeitRewards`**  
   The check `_index < rewardEpochs[_token].length - 1` may prevent forfeiting the latest epoch, even if valid. Additionally, edge cases (e.g., single epoch) render the function unusable due to incorrect bounds.

8. **Lack of Recovery Mechanism for Residual Funds**  
   The contract lacks a method to recover unclaimed or residual tokens (e.g., from division truncation or forfeits), leading to permanently locked assets.","### **[H-01] User can forfeit other user rewards**

**Report Description**:  
A user can forfeit another user's rewards by providing a higher `_startIndex` in the `getReward` function. This could allow malicious actors to manipulate reward claims, leading to unfair distribution and potential loss of rewards for legitimate users.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of users being able to forfeit other users' rewards by manipulating the `_startIndex` parameter. This is a critical oversight, as it directly impacts the fairness and security of the reward distribution mechanism.

---

### **[M-05] Users can grief reward distribution**

**Report Description**:  
Users can grief reward distributions by spending dust amounts. If a reward is targeted for an epoch in the past, a user can front-run the transaction in the mempool and call `addRewardToEpoch()` with a dust amount at an epoch after the one in question. This will cause the transaction in the mempool to revert, disrupting the reward distribution process.

**Match in Response List**:  
Matches with the issue titled **""Dust Accumulation from Integer Truncation""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of dust accumulation but does not address the specific griefing vector where users can front-run transactions to disrupt reward distribution. The response focuses on the accumulation of unclaimable tokens rather than the intentional manipulation of the reward process.

---

### **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**

**Report Description**:  
Rewards may be locked forever if a user does not claim them for a very long time, such that too many epochs have passed. The platform may then be forced to reimburse the user for the locked rewards, causing significant economic loss.

**Match in Response List**:  
Matches with the issue titled **""Forfeited Rewards Permanently Locked""**.

**Validation**:  
**Correct**. The response accurately identifies the issue of rewards becoming permanently locked if not claimed. It correctly explains the economic impact of this issue, aligning with the report's description of the risk.

---

### **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

**Report Description**:  
If rewards are given in fee-on-transfer tokens, users may receive no rewards, breaking functionality. This occurs because the actual amount received by the contract is less than the amount sent due to the fee mechanism, leading to discrepancies in reward distribution.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of fee-on-transfer tokens, which is a significant oversight. This issue directly impacts the functionality of the reward distribution mechanism and could lead to users receiving no rewards.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time**

**Partially Correct Matches**:

- **[M-05] Users can grief reward distribution**

**Missed Issues from Issue Report**:

- **[H-01] User can forfeit other user rewards**
- **[M-11] Users may lose rewards to other users if rewards are given as fee-on-transfer tokens**

---

The response list covers some issues but misses critical vulnerabilities, particularly those related to reward manipulation and fee-on-transfer tokens. Addressing these gaps is essential for ensuring the security and fairness of the smart contract.",1,1,2,8,"Okay, let's try to figure out the vulnerabilities in this smart contract. I'm a bit new to this, so I'll take it step by step.

First, I'll start by reading through the code and understanding what each part does. The contract is called ExtraRewardsDistributor and it imports some interfaces and OpenZeppelin libraries for SafeERC20 and ReentrancyGuard. It seems to handle distributing extra rewards to users based on epochs from the AuraLocker contract.

Looking at the state variables, there's a mapping called rewardData which tracks rewards per token and epoch. Then rewardEpochs keeps track of epochs for each token. UserClaims records how much a user has claimed for each token. The contract uses ReentrancyGuard, which is good to prevent reentrancy attacks.

The constructor sets the auraLocker address. The main functions are addReward, addRewardToEpoch, _addReward, getReward, forfeitRewards, and some view functions for claimable rewards.

Let's look for common vulnerabilities. First, reentrancy. The functions that transfer tokens are using SafeERC20's safeTransferFrom and safeTransfer, which should handle reentrancy, but there's a nonReentrant modifier on _addReward. But other functions like getReward call safeTransfer without a nonReentrant modifier. Wait, the _getReward function is public and calls safeTransfer. Since it's public, could someone call it and cause a reentrancy? But the _getReward is marked as public and can be called by anyone. But the function first calculates claimable tokens and then transfers them. However, since the state is updated (userClaims) after the transfer, that's a problem. Because in the _getReward function, they set userClaims after transferring the tokens. That's a classic reentrancy vulnerability. An attacker could potentially re-enter the contract before the userClaims is updated, allowing them to claim rewards multiple times.

Wait, let me check. In _getReward, the code does:

if (claimableTokens > 0) {
    userClaims[_token][_account] = index;
    IERC20(_token).safeTransfer(_account, claimableTokens);
    emit RewardPaid(...);
}

No, wait! They update userClaims before transferring the tokens. Because the code sets userClaims to index first, then transfers. Wait, no, the code is:

userClaims[_token][_account] = index;

Then they transfer the tokens. Wait, the transfer is after updating the state. So that's safe. Because once the user's claim index is updated, even if there's a reentrant call, the next time it would check the updated index. So maybe that's not a reentrancy issue here. But the _getReward function is public and anyone can call it for any _account. Is that a problem? Like, can someone else trigger the transfer to another account? For example, if Alice has some rewards, can Bob call getReward and specify Alice's address, thereby claiming Alice's rewards for her? But that would mean the tokens are sent to Alice, not to Bob. So maybe that's intended? But perhaps it's a vulnerability if the function allows anyone to trigger a transfer to another address. However, in the code, the _getReward function is public, so anyone can call it with any _account. But when they transfer the tokens, they send them to _account. So an attacker can't steal the tokens, but they can trigger the distribution. That might be a design choice rather than a vulnerability. However, it could be used to grief users by making them pay gas for the transfer, but in reality, since the function is called by someone else, the caller pays the gas. So maybe not a vulnerability, but more of a potential inefficiency or unexpected behavior.

Next, looking at the addReward and addRewardToEpoch functions. They call auraLocker.checkpointEpoch(), which might be necessary to update the latest epoch. But in addRewardToEpoch, when _epoch is not the latest, they check if the new epoch is after the last in rewardEpochs[_token]. However, there's a possible issue here. Let's say the rewardEpochs for a token has [1,3], and someone tries to add to epoch 2. The code requires that the new epoch is greater than the last in the array. Wait, the code says:

if (len == 0 || rewardEpochs[_token][len - 1] < _epoch) {
    rewardEpochs[_token].push(_epoch);
}

But when adding to a past epoch (i.e., _epoch < latestEpoch), the code allows adding as long as the new epoch is higher than the last in rewardEpochs. But if the epochs are not contiguous, this could create gaps. However, maybe that's intended. However, when _addReward is called, it adds the reward to that specific epoch. But the problem could be if epochs are added out of order. Wait, the code in addRewardToEpoch checks that when _epoch is not latestEpoch, the new epoch must be higher than the last in rewardEpochs. So rewardEpochs is kept in ascending order. That makes sense. So that part seems okay.

Another possible issue is division in _addReward. The code calculates rPerT as (_amount * 1e20) / supply. If supply is zero, this would cause a division by zero. However, in the context of auraLocker, the totalSupplyAtEpoch(_epoch) must be positive when adding rewards. But if for some reason, the total supply is zero at that epoch, this would revert. So the contract assumes that when adding rewards, the supply is non-zero. But there's no check for supply > 0. That could be a vulnerability. If someone calls addReward when the total supply for that epoch is zero, it would divide by zero and revert. But maybe the auraLocker ensures that epochs are only created when there's supply. But if not, this is a possible division by zero error.

Then in the _claimableRewards function, they multiply balance by rewardData[_token][_epoch], divide by 1e20. If rewardData was not initialized for that epoch, it would be zero, which is okay. But maybe that's expected.

Looking at the forfeitRewards function. It allows a user to forfeit rewards up to a certain index. The checks are:

require(_index > 0 && _index < rewardEpochs[_token].length - 1, ""!past"");
require(_index >= userClaims[_token][msg.sender], ""already claimed"");

But the first condition checks if _index is less than rewardEpochs[_token].length - 1. Let's say rewardEpochs has length 5 (indices 0-4). Then _index must be less than 4, so up to 3. Then the user can set their claim index to _index + 1. But if the current index is at 0, and they forfeit to index 3, they set their userClaims to 4, which would skip some epochs. Wait, the code sets userClaims to _index + 1. But the rewardEpochs array may have epochs that are not contiguous. For example, if the epochs are [1,3,5], then the indices are 0,1,2. If a user forfeits up to index 1 (epoch 3), their userClaims would be set to 2. Then in the next claim, they start from 2 (epoch 5). But if the epochs are not in order, maybe this is intended. However, the check in forfeit requires that _index is less than rewardEpochs.length -1. So the maximum _index is length - 2. Then _index +1 would be length -1. So the user can only move their index forward to the second to last epoch. But perhaps there's an off-by-one error here. For example, if rewardEpochs has length 1, then _index has to be < 0, which is not possible. So the forfeit function would revert. But in that case, maybe it's impossible to call forfeitRewards when there's only one epoch. But maybe that's intended.

Another issue could be in the _allClaimableRewards function. The code loops through epochs starting from epochIndex (the user's current claim index) and checks if the reward epoch is less than the latestEpoch. But latestEpoch is auraLocker.epochCount() - 1. So if the latestEpoch is, say, 10, and a reward epoch is 10, then it's not included. But the code requires that the reward epoch is less than latestEpoch. So rewards for the latest epoch can't be claimed until a new epoch is created. That seems correct, as the current epoch might still be active.

But what if the latestEpoch is not checkpointed? Because auraLocker.checkpointEpoch() is called in addReward functions, but when someone calls getReward, do they need to checkpoint? For example, if the latest epoch hasn't been checkpointed, then the latestEpoch variable might be old, and the rewards for previous epochs might not be claimable yet. But since the getReward function doesn't call checkpointEpoch, it's possible that the latestEpoch is not up to date. So if the auraLocker hasn't been checkpointed, the latestEpoch would be old, and the rewards for epochs up to that old latestEpoch can be claimed. But maybe this is intentional, as the contract relies on the addReward functions to call checkpointEpoch. However, if someone never calls addReward again, the latestEpoch in this contract would not be updated, and users might not be able to claim their latest rewards until a new reward is added. That could be a problem. So the getReward function doesn't trigger a checkpoint, which might leave the latestEpoch outdated. So users might not be able to claim rewards from the latest epochs until a new reward is added, which calls checkpointEpoch. This could lead to delays or require manual intervention to checkpoint.

Another possible issue is the use of 1e20 for scaling. When calculating rPerT, they multiply _amount by 1e20 and divide by supply. But if the supply is very large, this could result in rPerT being zero for small _amount. For example, if _amount is 1 and supply is 1e24, then 1 * 1e20 / 1e24 = 0. So the rewardData would be zero, and users wouldn't get anything. But maybe that's expected behavior when the amount is too small relative to supply. However, there's no check to prevent adding such small rewards, which could be a waste of gas.

In the forfeitRewards function, the user can forfeit rewards from a certain index. However, there's no transfer of tokens; it just moves their claim index forward. But when they forfeit, do the tokens stay in the contract? Yes, because the rewards are calculated based on the user's balance at each epoch and the rewardData. If they forfeit, they just can't claim those rewards anymore. But the tokens are still in the contract. So this could lead to locked funds that no one can claim. For example, if a user forfeits their rewards, the tokens allocated for their share in that epoch are not transferred to anyone else. This could be a design issue, as the tokens are effectively stuck unless another user's balance at that epoch allows them to claim more. Wait, no. The rewardData is per epoch and per token. The total rewards for an epoch are stored as rPerT (reward per token * 1e20). So if a user forfeits their claim, the tokens that were allocated for their balance in that epoch would still be part of the total rewards for that epoch, and other users can claim their portions. So forfeiting doesn't lock the tokens, it just prevents the user from claiming their portion. The tokens are distributed proportionally to all users based on their balance in that epoch. So if one user forfeits, the remaining users can still claim their shares. Wait, no. The total amount for the epoch is added as _amount, which is converted to rPerT. The contract holds the entire _amount. Then, each user's claimable is (balance * rPerT) / 1e20. If a user forfeits, their portion is effectively unclaimed, but the contract still holds those tokens. Since other users' claims are based on their own balance and the same rPerT, the total sum of all users' claims would be equal to _amount. So if a user forfeits, their unclaimed tokens remain in the contract and are not claimable by anyone else. Thus, those tokens are stuck. That's a problem. Because the total tokens in the contract should be equal to the sum of all rewards across epochs. But if some users forfeit, their portion is left unclaimed, but the contract doesn't have a way to recover those funds. So the contract would accumulate dust over time, which is a vulnerability as funds are locked forever.

Another possible issue is in the calculation of claimableTokens in _allClaimableRewards. The loop runs from epochIndex to tokenEpochs, and for each i, checks if rewardEpochs[_token][i] < latestEpoch. However, latestEpoch is obtained by auraLocker.epochCount() - 1. If the current epoch is still ongoing (i.e., not checkpointed), then rewards for that epoch cannot be claimed. But during the loop, it increments epochIndex each time, even if the epoch is not yet claimable. Wait, no. The loop checks if rewardEpochs[_token][i] < latestEpoch. If that's true, it adds the claimable reward and sets epochIndex to i+1. If not, it skips. Wait, no. Let's see:

Inside the loop:

for (uint256 i = epochIndex; i < tokenEpochs; i++) {
    if (rewardEpochs[_token][i] < latestEpoch) {
        claimableTokens += _claimableRewards(...);
        epochIndex = i + 1;
    }
}

So even if some epochs are not yet claimable (i.e., their epoch is >= latestEpoch), the loop would skip them. However, once those epochs become claimable (when latestEpoch increases), the user's next claim would start from epochIndex where it left off. Wait, no. Because once the loop runs, epochIndex is incremented only for the epochs that were processed (those with rewardEpochs[_token][i] < latestEpoch). So suppose in the current run, some epochs are not yet claimable; they are skipped, and epochIndex remains at i where the condition wasn't met. But when the loop continues, it might process them in the next call. Wait, but the loop is for all i from epochIndex to tokenEpochs-1. So in a single call to _allClaimableRewards, all epochs up to the latest claimable are processed, and epochIndex is set to the next index after the last processed. Any epochs after that (even if they are now claimable) would have to wait for the next call. Wait, no. Because in the loop, it's checking for each i in order. So if, for example, in the current call, the latestEpoch is 5, and there's an epoch at i=2 which is 4 (less than 5), so it's processed. Then i=3 is 5 (not less than latestEpoch 5), so it's skipped. The loop continues to i=4, which might be 6 (but tokenEpochs is the length). Wait, maybe not. So the problem is that once an epoch is added to rewardEpochs, but it's not yet claimable (because latestEpoch hasn't passed), then the loop will skip it. However, when the latestEpoch increases (after a checkpoint), the next time the user calls getReward, the loop will process those epochs that are now older than the new latestEpoch. But the way the loop is structured, it will process all epochs starting from the user's current index, but only those that are older than latestEpoch. So once the latestEpoch is updated, the next call will process those epochs. That seems correct. So the code should handle that correctly.

Another possible issue is with the userClaims mapping. When a user claims rewards, their index is updated to the highest processed epoch index. However, the rewardEpochs array could have epochs that are not in order, but earlier epochs. Wait, no, because the rewardEpochs array is maintained in ascending order. When adding a new epoch, it's pushed only if it's higher than the last one. So the array is sorted. Therefore, when processing epochs in order, starting from the user's current index, they are processed in increasing order of epochs. So once an epoch is processed, the user's index moves past it, and they can't claim it again.

But what if a new epoch is added that is earlier than the latestEpoch but higher than some existing ones? For example, existing epochs [1,3,5], then add a new epoch 4. But according to the code in addRewardToEpoch, when adding to a past epoch (not latest), it requires that the new epoch is higher than the last in the array. So in this example, trying to add epoch 4 after 5 would require that 4 > 5, which is false. So the code would not allow that. Therefore, the rewardEpochs array is always in ascending order. Therefore, processing from index 0 upwards is safe.

Another thing to check is the function visibility. The _getReward function is marked as public, so anyone can call it. But since it's intended to be called by getReward functions, maybe making it internal would be better. However, as it is, it's public and can be called by anyone. But the code doesn't have any access control on the getReward functions. So anyone can trigger a claim for any user. That could be a problem if, for example, a contract expects the reward to be claimed only by the user, but an external party can force the claim, potentially disrupting the contract's state. However, in this case, the tokens are sent to the user, so it's not a security issue, but it could be a griefing vector where someone else pays the gas to claim the user's rewards. But the user might prefer to handle it themselves. But the code allows it, which might not be a vulnerability per se, but a design choice.

In the addReward function, when adding a reward to the latestEpoch, it calls _addReward. But if the total supply at that epoch is zero, division by zero will occur. As mentioned earlier, this is a possible issue. There's no check to ensure that supply is greater than zero. So if someone calls addReward when the supply is zero, the transaction will revert. But maybe this is an edge case. However, it's a possible vulnerability if the contract doesn't handle it.

Looking at the event emissions. The RewardAdded event emits the _amount, which is the amount transferred. But in _addReward, the code adds the _amount to rewardData. However, the code increases rewardData[_token][_epoch] by rPerT, which is calculated as (_amount * 1e20) / supply. So the RewardAdded event's 'reward' parameter is the _amount, which is correct. But if the division rounds down, some tokens might be left in the contract. For example, if _amount is 100, supply is 3, then rPerT is (100 * 1e20) /3 = 3333333333333333333333.333..., which is truncated. Then total rewards distributed would be (supply * rPerT) /1e20 = 3 * 3333333333333333333333 /1e20 = 100 /1e20 * 3 * ... wait, maybe there's a precision loss here. Let me see: rPerT is _amount *1e20 / supply. Then when a user's balance is multiplied by rPerT and divided by 1e20, the total per user is (balance * _amount) / supply. Summing over all users' balances would give _amount (since sum(balance) = supply). So the total distributed should equal _amount. However, due to integer division, there might be a remainder left in the contract. For example, if _amount is 101, supply is 2, then rPerT is (101 *1e20)/2 = 505e20 /2 = 505e20 /2 = 252.5e20, which can't be represented as an integer. So the code would take the floor of that (2525...). Then when users claim, each gets (balance * rPerT) /1e20. For balance 1: 1 * 2525... /1e20 = 2.525... which would be 2 (truncated). For the other user, same. Total is 4, but _amount was 101. So 101 -4 = 97 would be left in the contract. That's a problem. Because the contract would accumulate dust from each reward addition due to integer division. This is a vulnerability as it leads to locked funds that can't be distributed.

So the contract doesn't handle the case where the division in _addReward leaves a remainder. The tokens transferred are the full _amount, but the sum of all possible claims is (supply * rPerT) /1e20, which could be less than _amount. The difference would remain in the contract, unclaimable by anyone. This is a significant issue as funds get locked forever.

Another possible issue is in the forfeitRewards function. The first condition requires _index < rewardEpochs[_token].length - 1. Let's say the length is 1, then length -1 is 0. So _index must be <0, which is impossible, meaning the function can't be called. So if there's only one epoch, users can't forfeit. But maybe that's intended. However, if there are multiple epochs, but the user wants to forfeit the latest one, they can't. Because rewardEpochs.length -1 is the last index. The check requires _index < that, so they can only forfeit up to the second to last index. So for example, if rewardEpochs has epochs [1,2,3], the indices are 0,1,2. Then _index must be < 2, so 0 or 1. So the user can forfeit up to index 1 (epoch 2), and their claim index is set to 2. Then, when they claim again, they start from index 2 (epoch3). But if epoch3 is the latest, they can't claim it yet. So this allows users to forfeit up to the second to last epoch. But if the user wants to forfeit the last epoch (index 2), they can't. So this might be a limitation, but perhaps it's by design to prevent forfeiting the latest epoch. However, it could lead to confusion.

Another potential issue is in the event emission in _getReward. The event RewardPaid includes the 'index' parameter, which is the epochIndex after processing. However, the index is the new user's claim index, which is the next epoch to process. So the event's index might not directly correspond to the epochs that were claimed. For example, if a user claims epochs 0,1,2, the index would be 3, but the event would emit index=3. But the actual epochs processed are 0,1,2. The event might not provide enough information about which epochs were claimed. This could be a problem for off-chain tracking, but it's not a security vulnerability.

Now, summarizing the possible vulnerabilities:

1. **Division by Zero in _addReward**: If the supply at the epoch is zero when adding a reward, the division (_amount * 1e20) / supply will revert. The contract does not check if supply is greater than zero before performing the division.

2. **Dust Funds Due to Integer Division**: When rewards are added, the calculation of rPerT could truncate, leading to unclaimable dust remaining in the contract. For example, if _amount is not perfectly divisible by supply, the remainder is locked in the contract forever.

3. **Forfeited Rewards Locked Forever**: When a user forfeits rewards, their unclaimed tokens for those epochs remain in the contract and cannot be claimed by anyone else. This leads to locked funds that are irretrievable.

4. **Outdated Latest Epoch in getReward**: The getReward function does not trigger a checkpoint, so if the latest epoch in auraLocker has advanced but hasn't been checkpointed via addReward, users may not be able to claim rewards from previous epochs until a new reward is added. This could delay reward distribution.

5. **Unprotected _getReward Function**: The _getReward function is public and allows anyone to trigger a claim for any user. While not a direct security risk, it could lead to unexpected behavior or gas griefing.

6. **Incorrect Index Handling in Forfeit**: The forfeitRewards function's index checks might be off, potentially allowing users to skip epochs unintentionally or leading to confusion in certain edge cases (like when there's only one epoch).

7. **Lack of Access Control**: Functions like addReward and addRewardToEpoch can be called by anyone, allowing anyone to add rewards for any token. Depending on the intended design, this could be a vulnerability if only authorized parties should be allowed to add rewards.

Wait, the addReward and addRewardToEpoch functions are external and have no access control. So any user can call them and add rewards. But in the code, the _addReward function transfers tokens from the caller. So if someone calls addReward, they need to have approved the contract to spend their tokens. So the functions are permissionless but require the caller to provide the tokens. That's intentional, as anyone can contribute rewards. So maybe that's not a vulnerability but a feature. Unless there's an assumption that only certain addresses should add rewards, but the code doesn't enforce that. So this is only a vulnerability if the contract's design expects only specific addresses to add rewards, but there's no access control. However, since the function transfers tokens from the caller, it's safe as only the token owner can contribute. So this is not a vulnerability.

Another point: the code uses the nonReentrant modifier in _addReward. But other functions like getReward do not have this modifier. However, the _getReward function does a token transfer after updating the state. Since the state is updated before the transfer, reentrancy is mitigated. So that's safe.

So the main vulnerabilities are the division by zero, dust due to integer division, forfeited funds locked, and possibly the outdated latest epoch.

Additionally, the addRewardToEpoch function allows adding rewards to past epochs, but there's no check that the epoch is valid (e.g., exists in the auraLocker). However, the code calls auraLocker.checkpointEpoch(), which may create epochs if necessary. But if the _epoch is too old and not existing, totalSupplyAtEpoch(_epoch) might return zero, leading to division by zero. So this depends on auraLocker's implementation.

Wait, auraLocker.totalSupplyAtEpoch(_epoch) is called in _addReward. If the _epoch does not exist in auraLocker, what does it return? If it returns zero, then the division by zero occurs. So if someone can call addRewardToEpoch with an _epoch that's invalid (i.e., not yet created in auraLocker), then totalSupplyAtEpoch could be zero. But the auraLocker's checkpointEpoch is called before. Let's check the auraLocker interface. The function checkpointEpoch() is supposed to create a new epoch if necessary. So when addRewardToEpoch is called, it checkpoints, which might create a new epoch. However, if _epoch is a past epoch that hasn't been properly recorded, totalSupplyAtEpoch could be zero, leading to division by zero. This could happen if the auraLocker hasn't recorded that epoch's supply. But the code in addRewardToEpoch requires that _epoch <= latestEpoch. But latestEpoch is obtained after checkpointing. So when you checkpoint, the latestEpoch is updated. So if the epoch is valid (i.e., exists in auraLocker), then totalSupplyAtEpoch should return the correct value. But if the auraLocker's totalSupplyAtEpoch returns zero for a valid epoch, then division by zero occurs.

Therefore, the division by zero vulnerability exists if the auraLocker returns zero for a valid epoch.

So putting it all together, the vulnerabilities are:

1. **Division by Zero in _addReward**: If the total supply at the given epoch is zero, adding a reward will cause a division by zero error, reverting the transaction and possibly locking funds if not handled.

2. **Dust Accumulation from Integer Division**: Due to integer truncation when calculating rewards per token, residual tokens may remain locked in the contract indefinitely.

3. **Forfeited Rewards Result in Locked Funds**: When users forfeit rewards, the corresponding tokens are not redistributed and remain stuck in the contract.

4. **Outdated Epoch Handling in getReward**: The latest epoch is not checkpointed during reward claims, potentially delaying reward availability until another reward is added.

5. **Unprotected addReward and addRewardToEpoch Functions**: While not a vulnerability in itself, allowing anyone to add rewards could lead to unexpected behavior if combined with other issues.

6. **Lack of Supply Check in addReward**: Adding rewards to epochs with zero supply leads to division by zero, which is not checked.

Now, the most critical ones are division by zero, dust accumulation, and locked funds from forfeits.","```
1. Forfeited Rewards Permanently Locked
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Forfeited Rewards Permanently Locked"".
   - It appears at rank 3 in the ranked list of predictions.

2. **Calculate the precision at that rank**:
   - Precision at rank 3 (\( P@3 \)) is calculated as the number of true positives up to rank 3 divided by the rank itself.
   - Since there is only one true positive up to rank 3, \( P@3 = \frac{1}{3} \approx 0.333 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where it appears.
   - Therefore, \( AP = 0.333 \).

**Output**:
```
0.333
```"
AuraLocker.sol,"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}

/**
 * @title   AuraLocker
 * @author  ConvexFinance
 * @notice  Effectively allows for rolling 16 week lockups of CVX, and provides balances available
 *          at each epoch (1 week). Also receives cvxCrv from `CvxStakingProxy` and redistributes
 *          to depositors.
 * @dev     Invdividual and delegatee vote power lookups both use independent accounting mechanisms.
 */
contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    /* ==========     STRUCTS     ========== */

    struct RewardData {
        /// Timestamp for current period finish
        uint32 periodFinish;
        /// Last time any user took action
        uint32 lastUpdateTime;
        /// RewardRate for the rest of the period
        uint96 rewardRate;
        /// Ever increasing rewardPerToken rate, based on % of total supply
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; //epoch start date
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    /* ========== STATE VARIABLES ========== */

    // Rewards
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    //     Core reward data
    mapping(address => RewardData) public rewardData;
    //     Reward token -> distributor -> is approved to add rewards
    mapping(address => mapping(address => bool)) public rewardDistributors;
    //     User -> reward token -> amount
    mapping(address => mapping(address => UserData)) public userData;
    //     Duration that rewards are streamed over
    uint256 public constant rewardsDuration = 86400 * 7;
    //     Duration of lock/earned penalty period
    uint256 public constant lockDuration = rewardsDuration * 17;

    // Balances
    //     Supplies and historic supply
    uint256 public lockedSupply;
    //     Epochs contains only the tokens that were locked at that epoch, not a cumulative supply
    Epoch[] public epochs;
    //     Mappings for balance data
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    // Voting
    //     Stored delegations
    mapping(address => address) private _delegates;
    //     Checkpointed votes
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    //     Delegatee balances (user -> unlock timestamp -> amount)
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    // Config
    //     Tokens
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    //     Denom for calcs
    uint256 public constant denominator = 10000;
    //     Staking cvxCrv
    address public immutable cvxcrvStaking;
    //     Incentives
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    //     Shutdown
    bool public isShutdown = false;

    // Basic token data
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    /* ========== EVENTS ========== */

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    /***************************************
                    CONSTRUCTOR
    ****************************************/

    /**
     * @param _nameArg          Token name, simples
     * @param _symbolArg        Token symbol
     * @param _stakingToken     CVX (0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B)
     * @param _cvxCrv           cvxCRV (0x62B9c7356A2Dc64a1969e19C23e4f579F9810Aa7)
     * @param _cvxCrvStaking    cvxCRV rewards (0x3Fe65692bfCD0e6CF84cB1E7d24108E434A7587e)
     */
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    /***************************************
                    MODIFIER
    ****************************************/

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    /***************************************
                    ADMIN
    ****************************************/

    // Add a new reward token to be distributed to stakers
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    // Modify approval for an address to call notifyRewardAmount
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    //set kick incentive
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); //max 5% per epoch
        require(_delay >= 2, ""min delay""); //minimum 2 epochs of grace
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    //shutdown the contract. unstake all tokens. release all locks
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    // Set approvals for staking cvx and cvxcrv
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    /***************************************
                    ACTIONS
    ****************************************/

    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        //pull tokens
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        //lock
        _lock(_account, _amount);
    }

    //lock tokens
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        //must try check pointing epoch first
        _checkpointEpoch();

        //add user balances
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        //add to total supplies
        lockedSupply = lockedSupply.add(_amount);

        //add user lock records or add to current
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        //update epoch supply, epoch checkpointed above so safe to add to latest
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    // claim all pending rewards
    function getReward(address _account) external {
        getReward(_account, false);
    }

    // Claim all pending rewards
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    //insert a new epoch if needed. fill in any gaps
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        //first epoch add in constructor, no need to check 0 length
        //check to add
        if (epochs[epochindex - 1].date < currentEpoch) {
            //fill any epoch gaps until the next epoch date.
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    // Withdraw/relock all currently locked tokens where the unlock time has passed
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        //allow kick after grace period of 'kickRewardEpochDelay'
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    // Withdraw without checkpointing or accruing any rewards, providing system is shutdown
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    // Withdraw all currently locked tokens where the unlock time has passed
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        // e.g. now = 16
        // if contract is shutdown OR latest lock unlock time (e.g. 17) <= now - (1)
        // e.g. 17 <= (16 + 1)
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            //if time is beyond last lock, can just bundle everything together
            locked = userBalance.locked;

            //dont delete, just set next index
            userBalance.nextUnlockIndex = length.to32();

            //check for kick reward
            //this wont have the exact reward rate that you would get if looped through
            //but this section is supposed to be for quick and easy low gas processing of all locks
            //we'll assume that if the reward was good enough someone would have processed at an earlier epoch
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            //use a processed index(nextUnlockIndex) to not loop as much
            //deleting does not change array length
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                //unlock time must be less or equal to time
                if (locks[i].unlockTime > expiryTime) break;

                //add to cumulative amounts
                locked = locked.add(locks[i].amount);

                //check for kick reward
                //each epoch over due increases reward
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                //set next unlock index
                nextUnlockIndex++;
            }
            //update next unlock index
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        //update user balances and total supplies
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        //checkpoint the delegatee
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        //send process incentive
        if (reward > 0) {
            //reduce return amount by the kick reward
            locked = locked.sub(reward.to112());

            //transfer reward
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        //relock or return to user
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    /***************************************
            DELEGATION & VOTE BALANCE
    ****************************************/

    /**
     * @dev Delegate votes from the sender to `newDelegatee`.
     */
    function delegate(address newDelegatee) external virtual nonReentrant {
        // Step 1: Get lock data
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        // Step 2: Update delegatee storage
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        // Step 3: Move balances around
        //         Delegate for the upcoming epoch
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        // Step 3.1: Add future unlocks and sum balances
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        // Step 3.2: Checkpoint old delegatee
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        // Step 3.3: Checkpoint new delegatee
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        // This would only skip on first checkpointing
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                // If there has already been a record for the upcoming epoch, no need to deduct the unlocks
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                // else if it has been over 16 weeks since the previous checkpoint, all locks have since expired
                // e.g. week 1 + 17 <= 18
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    // Should be maximum 18 iterations
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    /**
     * @dev Get the address `account` is currently delegating to.
     */
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    /**
     * @dev Gets the current votes balance for `account`
     */
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    /**
     * @dev Get the `pos`-th checkpoint for `account`.
     */
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    /**
     * @dev Get number of checkpoints for `account`.
     */
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    /**
     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.
     */
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    /**
     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.
     * It is but NOT the sum of all the delegated votes!
     */
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    /**
     * @dev Lookup a value in a list of (sorted) checkpoints.
     *      Copied from oz/ERC20Votes.sol
     */
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    /***************************************
                VIEWS - BALANCES
    ****************************************/

    // Balance of an account which only includes properly locked tokens as of the most recent eligible epoch
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    // Balance of an account which only includes properly locked tokens at the given epoch
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        //need to add up since the range could be in the middle somewhere
        //traverse inversely to make more current queries more gas efficient
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            //lock epoch must be less or equal to the epoch we're basing from.
            //also not include the current epoch
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    //stop now as no futher checks matter
                    break;
                }
            }
        }

        return amount;
    }

    // Information on a user's locked balances
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    // Supply of all properly locked balances at most recent eligible epoch
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    // Supply of all properly locked balances at the given epoch
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    // Get an epoch index based on timestamp
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    /***************************************
                VIEWS - GENERAL
    ****************************************/

    // Number of epochs
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    /***************************************
                VIEWS - REWARDS
    ****************************************/

    // Address and claimable amount of all reward tokens for the given account
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    /***************************************
                REWARD FUNDING
    ****************************************/

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        //et = now - (finish-duration)
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        //current at now: rewardRate * elapsedTime
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        // handle the transfer of reward tokens via `transferFrom` to reduce the number
        // of transactions required and ensure correctness of the _reward amount
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",7734.0,876.0,"[M-03] Improperly Skewed Governance Mechanism
The balance checkpointing system exposed by the contract for governance purposes is flawed as it does not maintain voting balances properly. In detail, the total supply of votes is tracked as the sum of all locked balances, however, the total voting power of an individual only tracks delegated balances. As a result, governance percentage thresholds will be significantly affected and potentially unmet.   [M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance
The issue occurs in AuraLocker, when expired locks are processed via kicking, and if all the user locks have expired. In this scenario, to calculate the kick reward, `_processExpiredLocks` multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch.
  [M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848
Rewards distribution can be delayed/never distributed on the function `_rewardPerToken()`
  [M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed
Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed. The platform then forced to reimburse reward to the user that got their reward locked. Causing huge economics loss.   [M-08] Locking up AURA Token does not increase voting power of individual
Per the documentation, AURA tokens can be locked in the AuraLocker to recieve vlAURA. vlAURA is voting power in the AURA ecosystem.
It is also possible for the users to delegate their voting power to a specific address by calling the `AuraLocker.delegate(address account)` function.
However, after users locked up their AURA tokens in exchange for vlAURA tokens, their voting power did not increase.
  [M-10] Increase voting power by tokenizing the address that locks the token
Without restriction on the type of address that lock the token in function `_lock`, a bad actor could lock the token through the smart contract.
  [M-14] Integer overflow will lock all rewards in AuraLocker
There is a potential overflow in the rewards calculations which would lead to `updateReward()` always reverting.",7.0,"pragma solidity ^0.8.11;
pragma experimental ABIEncoderV2;

import { IERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol"";
import { SafeERC20 } from ""@openzeppelin/contracts-0.8/token/ERC20/utils/SafeERC20.sol"";
import { Ownable } from ""@openzeppelin/contracts-0.8/access/Ownable.sol"";
import { ReentrancyGuard } from ""@openzeppelin/contracts-0.8/security/ReentrancyGuard.sol"";
import { AuraMath, AuraMath32, AuraMath112, AuraMath224 } from ""./AuraMath.sol"";
import ""./Interfaces.sol"";

interface IRewardStaking {
    function stakeFor(address, uint256) external;
}


contract AuraLocker is ReentrancyGuard, Ownable, IAuraLocker {
    using AuraMath for uint256;
    using AuraMath224 for uint224;
    using AuraMath112 for uint112;
    using AuraMath32 for uint32;
    using SafeERC20 for IERC20;

    

    struct RewardData {
        
        uint32 periodFinish;
        
        uint32 lastUpdateTime;
        
        uint96 rewardRate;
        
        uint96 rewardPerTokenStored;
    }
    struct UserData {
        uint128 rewardPerTokenPaid;
        uint128 rewards;
    }
    struct EarnedData {
        address token;
        uint256 amount;
    }
    struct Balances {
        uint112 locked;
        uint32 nextUnlockIndex;
    }
    struct LockedBalance {
        uint112 amount;
        uint32 unlockTime;
    }
    struct Epoch {
        uint224 supply;
        uint32 date; 
    }
    struct DelegateeCheckpoint {
        uint224 votes;
        uint32 epochStart;
    }

    

    
    address[] public rewardTokens;
    uint256 public queuedCvxCrvRewards = 0;
    uint256 public constant newRewardRatio = 830;
    
    mapping(address => RewardData) public rewardData;
    
    mapping(address => mapping(address => bool)) public rewardDistributors;
    
    mapping(address => mapping(address => UserData)) public userData;
    
    uint256 public constant rewardsDuration = 86400 * 7;
    
    uint256 public constant lockDuration = rewardsDuration * 17;

    
    
    uint256 public lockedSupply;
    
    Epoch[] public epochs;
    
    mapping(address => Balances) public balances;
    mapping(address => LockedBalance[]) public userLocks;

    
    
    mapping(address => address) private _delegates;
    
    mapping(address => DelegateeCheckpoint[]) private _checkpointedVotes;
    
    mapping(address => mapping(uint256 => uint256)) public delegateeUnlocks;

    
    
    IERC20 public immutable stakingToken;
    address public immutable cvxCrv;
    
    uint256 public constant denominator = 10000;
    
    address public immutable cvxcrvStaking;
    
    uint256 public kickRewardPerEpoch = 100;
    uint256 public kickRewardEpochDelay = 3;
    
    bool public isShutdown = false;

    
    string private _name;
    string private _symbol;
    uint8 private immutable _decimals;

    

    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);
    event DelegateCheckpointed(address indexed delegate);

    event Recovered(address _token, uint256 _amount);
    event RewardPaid(address indexed _user, address indexed _rewardsToken, uint256 _reward);
    event Staked(address indexed _user, uint256 _paidAmount, uint256 _lockedAmount);
    event Withdrawn(address indexed _user, uint256 _amount, bool _relocked);
    event KickReward(address indexed _user, address indexed _kicked, uint256 _reward);
    event RewardAdded(address indexed _token, uint256 _reward);

    event KickIncentiveSet(uint256 rate, uint256 delay);
    event Shutdown();

    

    
    constructor(
        string memory _nameArg,
        string memory _symbolArg,
        address _stakingToken,
        address _cvxCrv,
        address _cvxCrvStaking
    ) Ownable() {
        _name = _nameArg;
        _symbol = _symbolArg;
        _decimals = 18;

        stakingToken = IERC20(_stakingToken);
        cvxCrv = _cvxCrv;
        cvxcrvStaking = _cvxCrvStaking;

        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        epochs.push(Epoch({ supply: 0, date: uint32(currentEpoch) }));
    }

    

    modifier updateReward(address _account) {
        {
            Balances storage userBalance = balances[_account];
            uint256 rewardTokensLength = rewardTokens.length;
            for (uint256 i = 0; i < rewardTokensLength; i++) {
                address token = rewardTokens[i];
                uint256 newRewardPerToken = _rewardPerToken(token);
                rewardData[token].rewardPerTokenStored = newRewardPerToken.to96();
                rewardData[token].lastUpdateTime = _lastTimeRewardApplicable(rewardData[token].periodFinish).to32();
                if (_account != address(0)) {
                    userData[_account][token] = UserData({
                        rewardPerTokenPaid: newRewardPerToken.to128(),
                        rewards: _earned(_account, token, userBalance.locked).to128()
                    });
                }
            }
        }
        _;
    }

    

    
    function addReward(address _rewardsToken, address _distributor) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime == 0, ""Reward already exists"");
        require(_rewardsToken != address(stakingToken), ""Cannot add StakingToken as reward"");
        rewardTokens.push(_rewardsToken);
        rewardData[_rewardsToken].lastUpdateTime = uint32(block.timestamp);
        rewardData[_rewardsToken].periodFinish = uint32(block.timestamp);
        rewardDistributors[_rewardsToken][_distributor] = true;
    }

    
    function approveRewardDistributor(
        address _rewardsToken,
        address _distributor,
        bool _approved
    ) external onlyOwner {
        require(rewardData[_rewardsToken].lastUpdateTime > 0, ""Reward does not exist"");
        rewardDistributors[_rewardsToken][_distributor] = _approved;
    }

    
    function setKickIncentive(uint256 _rate, uint256 _delay) external onlyOwner {
        require(_rate <= 500, ""over max rate""); 
        require(_delay >= 2, ""min delay""); 
        kickRewardPerEpoch = _rate;
        kickRewardEpochDelay = _delay;

        emit KickIncentiveSet(_rate, _delay);
    }

    
    function shutdown() external onlyOwner {
        isShutdown = true;
        emit Shutdown();
    }

    
    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {
        require(_tokenAddress != address(stakingToken), ""Cannot withdraw staking token"");
        require(rewardData[_tokenAddress].lastUpdateTime == 0, ""Cannot withdraw reward token"");
        IERC20(_tokenAddress).safeTransfer(owner(), _tokenAmount);
        emit Recovered(_tokenAddress, _tokenAmount);
    }

    
    function setApprovals() external {
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, 0);
        IERC20(cvxCrv).safeApprove(cvxcrvStaking, type(uint256).max);
    }

    

    
    function lock(address _account, uint256 _amount) external nonReentrant updateReward(_account) {
        
        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);

        
        _lock(_account, _amount);
    }

    
    function _lock(address _account, uint256 _amount) internal {
        require(_amount > 0, ""Cannot stake 0"");
        require(!isShutdown, ""shutdown"");

        Balances storage bal = balances[_account];

        
        _checkpointEpoch();

        
        uint112 lockAmount = _amount.to112();
        bal.locked = bal.locked.add(lockAmount);

        
        lockedSupply = lockedSupply.add(_amount);

        
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 unlockTime = currentEpoch.add(lockDuration);
        uint256 idx = userLocks[_account].length;
        if (idx == 0 || userLocks[_account][idx - 1].unlockTime < unlockTime) {
            userLocks[_account].push(LockedBalance({ amount: lockAmount, unlockTime: uint32(unlockTime) }));
        } else {
            LockedBalance storage userL = userLocks[_account][idx - 1];
            userL.amount = userL.amount.add(lockAmount);
        }

        address delegatee = delegates(_account);
        if (delegatee != address(0)) {
            delegateeUnlocks[delegatee][unlockTime] += lockAmount;
            _checkpointDelegate(delegatee, lockAmount, 0);
        }

        
        Epoch storage e = epochs[epochs.length - 1];
        e.supply = e.supply.add(lockAmount);

        emit Staked(_account, lockAmount, lockAmount);
    }

    
    function getReward(address _account) external {
        getReward(_account, false);
    }

    
    function getReward(address _account, bool _stake) public nonReentrant updateReward(_account) {
        uint256 rewardTokensLength = rewardTokens.length;
        for (uint256 i; i < rewardTokensLength; i++) {
            address _rewardsToken = rewardTokens[i];
            uint256 reward = userData[_account][_rewardsToken].rewards;
            if (reward > 0) {
                userData[_account][_rewardsToken].rewards = 0;
                if (_rewardsToken == cvxCrv && _stake && _account == msg.sender) {
                    IRewardStaking(cvxcrvStaking).stakeFor(_account, reward);
                } else {
                    IERC20(_rewardsToken).safeTransfer(_account, reward);
                }
                emit RewardPaid(_account, _rewardsToken, reward);
            }
        }
    }

    function checkpointEpoch() external {
        _checkpointEpoch();
    }

    
    function _checkpointEpoch() internal {
        uint256 currentEpoch = block.timestamp.div(rewardsDuration).mul(rewardsDuration);
        uint256 epochindex = epochs.length;

        
        
        if (epochs[epochindex - 1].date < currentEpoch) {
            
            while (epochs[epochs.length - 1].date != currentEpoch) {
                uint256 nextEpochDate = uint256(epochs[epochs.length - 1].date).add(rewardsDuration);
                epochs.push(Epoch({ supply: 0, date: uint32(nextEpochDate) }));
            }
        }
    }

    
    function processExpiredLocks(bool _relock) external nonReentrant {
        _processExpiredLocks(msg.sender, _relock, msg.sender, 0);
    }

    function kickExpiredLocks(address _account) external nonReentrant {
        
        _processExpiredLocks(_account, false, msg.sender, rewardsDuration.mul(kickRewardEpochDelay));
    }

    
    function emergencyWithdraw() external nonReentrant {
        require(isShutdown, ""Must be shutdown"");

        LockedBalance[] memory locks = userLocks[msg.sender];
        Balances storage userBalance = balances[msg.sender];

        uint256 amt = userBalance.locked;
        require(amt > 0, ""Nothing locked"");

        userBalance.locked = 0;
        userBalance.nextUnlockIndex = locks.length.to32();
        lockedSupply -= amt;

        emit Withdrawn(msg.sender, amt, false);

        stakingToken.safeTransfer(msg.sender, amt);
    }

    
    function _processExpiredLocks(
        address _account,
        bool _relock,
        address _rewardAddress,
        uint256 _checkDelay
    ) internal updateReward(_account) {
        LockedBalance[] storage locks = userLocks[_account];
        Balances storage userBalance = balances[_account];
        uint112 locked;
        uint256 length = locks.length;
        uint256 reward = 0;
        uint256 expiryTime = _checkDelay == 0 && _relock
            ? block.timestamp.add(rewardsDuration)
            : block.timestamp.sub(_checkDelay);
        require(length > 0, ""no locks"");
        
        
        
        if (isShutdown || locks[length - 1].unlockTime <= expiryTime) {
            
            locked = userBalance.locked;

            
            userBalance.nextUnlockIndex = length.to32();

            
            
            
            
            if (_checkDelay > 0) {
                uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                uint256 epochsover = currentEpoch.sub(uint256(locks[length - 1].unlockTime)).div(rewardsDuration);
                uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);
            }
        } else {
            
            
            uint32 nextUnlockIndex = userBalance.nextUnlockIndex;
            for (uint256 i = nextUnlockIndex; i < length; i++) {
                
                if (locks[i].unlockTime > expiryTime) break;

                
                locked = locked.add(locks[i].amount);

                
                
                if (_checkDelay > 0) {
                    uint256 currentEpoch = block.timestamp.sub(_checkDelay).div(rewardsDuration).mul(rewardsDuration);
                    uint256 epochsover = currentEpoch.sub(uint256(locks[i].unlockTime)).div(rewardsDuration);
                    uint256 rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);
                    reward = reward.add(uint256(locks[i].amount).mul(rRate).div(denominator));
                }
                
                nextUnlockIndex++;
            }
            
            userBalance.nextUnlockIndex = nextUnlockIndex;
        }
        require(locked > 0, ""no exp locks"");

        
        userBalance.locked = userBalance.locked.sub(locked);
        lockedSupply = lockedSupply.sub(locked);

        
        _checkpointDelegate(delegates(_account), 0, 0);

        emit Withdrawn(_account, locked, _relock);

        
        if (reward > 0) {
            
            locked = locked.sub(reward.to112());

            
            stakingToken.safeTransfer(_rewardAddress, reward);
            emit KickReward(_rewardAddress, _account, reward);
        }

        
        if (_relock) {
            _lock(_account, locked);
        } else {
            stakingToken.safeTransfer(_account, locked);
        }
    }

    

    
    function delegate(address newDelegatee) external virtual nonReentrant {
        
        LockedBalance[] storage locks = userLocks[msg.sender];
        uint256 len = locks.length;
        require(len > 0, ""Nothing to delegate"");
        require(newDelegatee != address(0), ""Must delegate to someone"");

        
        address oldDelegatee = delegates(msg.sender);
        require(newDelegatee != oldDelegatee, ""Must choose new delegatee"");
        _delegates[msg.sender] = newDelegatee;

        emit DelegateChanged(msg.sender, oldDelegatee, newDelegatee);

        
        
        uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
        uint256 i = len - 1;
        uint256 futureUnlocksSum = 0;
        LockedBalance memory currentLock = locks[i];
        
        while (currentLock.unlockTime > upcomingEpoch) {
            futureUnlocksSum += currentLock.amount;

            if (oldDelegatee != address(0)) {
                delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;
            }
            delegateeUnlocks[newDelegatee][currentLock.unlockTime] += currentLock.amount;

            if (i > 0) {
                i--;
                currentLock = locks[i];
            } else {
                break;
            }
        }

        
        _checkpointDelegate(oldDelegatee, 0, futureUnlocksSum);

        
        _checkpointDelegate(newDelegatee, futureUnlocksSum, 0);
    }

    function _checkpointDelegate(
        address _account,
        uint256 _upcomingAddition,
        uint256 _upcomingDeduction
    ) internal {
        
        if (_account != address(0)) {
            uint256 upcomingEpoch = block.timestamp.add(rewardsDuration).div(rewardsDuration).mul(rewardsDuration);
            DelegateeCheckpoint[] storage ckpts = _checkpointedVotes[_account];
            if (ckpts.length > 0) {
                DelegateeCheckpoint memory prevCkpt = ckpts[ckpts.length - 1];
                
                if (prevCkpt.epochStart == upcomingEpoch) {
                    ckpts[ckpts.length - 1] = DelegateeCheckpoint({
                        votes: (prevCkpt.votes + _upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    });
                }
                
                
                else if (prevCkpt.epochStart + lockDuration <= upcomingEpoch) {
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (_upcomingAddition - _upcomingDeduction).to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                } else {
                    uint256 nextEpoch = upcomingEpoch;
                    uint256 unlocksSinceLatestCkpt = 0;
                    
                    while (nextEpoch > prevCkpt.epochStart) {
                        unlocksSinceLatestCkpt += delegateeUnlocks[_account][nextEpoch];
                        nextEpoch -= rewardsDuration;
                    }
                    ckpts.push(
                        DelegateeCheckpoint({
                            votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction)
                                .to224(),
                            epochStart: upcomingEpoch.to32()
                        })
                    );
                }
            } else {
                ckpts.push(
                    DelegateeCheckpoint({
                        votes: (_upcomingAddition - _upcomingDeduction).to224(),
                        epochStart: upcomingEpoch.to32()
                    })
                );
            }
            emit DelegateCheckpointed(_account);
        }
    }

    
    function delegates(address account) public view virtual returns (address) {
        return _delegates[account];
    }

    
    function getVotes(address account) external view returns (uint256) {
        return getPastVotes(account, block.timestamp);
    }

    
    function checkpoints(address account, uint32 pos) external view virtual returns (DelegateeCheckpoint memory) {
        return _checkpointedVotes[account][pos];
    }

    
    function numCheckpoints(address account) external view virtual returns (uint32) {
        return _checkpointedVotes[account].length.to32();
    }

    
    function getPastVotes(address account, uint256 timestamp) public view returns (uint256 votes) {
        require(timestamp <= block.timestamp, ""ERC20Votes: block not yet mined"");
        uint256 epoch = timestamp.div(rewardsDuration).mul(rewardsDuration);
        DelegateeCheckpoint memory ckpt = _checkpointsLookup(_checkpointedVotes[account], epoch);
        votes = ckpt.votes;
        if (votes == 0 || ckpt.epochStart + lockDuration <= epoch) {
            return 0;
        }
        while (epoch > ckpt.epochStart) {
            votes -= delegateeUnlocks[account][epoch];
            epoch -= rewardsDuration;
        }
    }

    
    function getPastTotalSupply(uint256 timestamp) external view returns (uint256) {
        require(timestamp < block.timestamp, ""ERC20Votes: block not yet mined"");
        return totalSupplyAtEpoch(findEpochId(timestamp));
    }

    
    function _checkpointsLookup(DelegateeCheckpoint[] storage ckpts, uint256 epochStart)
        private
        view
        returns (DelegateeCheckpoint memory)
    {
        uint256 high = ckpts.length;
        uint256 low = 0;
        while (low < high) {
            uint256 mid = AuraMath.average(low, high);
            if (ckpts[mid].epochStart > epochStart) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        return high == 0 ? DelegateeCheckpoint(0, 0) : ckpts[high - 1];
    }

    

    
    function balanceOf(address _user) external view returns (uint256 amount) {
        return balanceAtEpochOf(findEpochId(block.timestamp), _user);
    }

    
    function balanceAtEpochOf(uint256 _epoch, address _user) public view returns (uint256 amount) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);

        LockedBalance[] storage locks = userLocks[_user];

        
        
        uint256 locksLength = locks.length;
        for (uint256 i = locksLength; i > 0; i--) {
            uint256 lockEpoch = uint256(locks[i - 1].unlockTime).sub(lockDuration);
            
            
            if (lockEpoch < epochStart) {
                if (lockEpoch > cutoffEpoch) {
                    amount = amount.add(locks[i - 1].amount);
                } else {
                    
                    break;
                }
            }
        }

        return amount;
    }

    
    function lockedBalances(address _user)
        external
        view
        returns (
            uint256 total,
            uint256 unlockable,
            uint256 locked,
            LockedBalance[] memory lockData
        )
    {
        LockedBalance[] storage locks = userLocks[_user];
        Balances storage userBalance = balances[_user];
        uint256 nextUnlockIndex = userBalance.nextUnlockIndex;
        uint256 idx;
        for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
            if (locks[i].unlockTime > block.timestamp) {
                if (idx == 0) {
                    lockData = new LockedBalance[](locks.length - i);
                }
                lockData[idx] = locks[i];
                idx++;
                locked = locked.add(locks[i].amount);
            } else {
                unlockable = unlockable.add(locks[i].amount);
            }
        }
        return (userBalance.locked, unlockable, locked, lockData);
    }

    
    function totalSupply() external view returns (uint256 supply) {
        return totalSupplyAtEpoch(findEpochId(block.timestamp));
    }

    
    function totalSupplyAtEpoch(uint256 _epoch) public view returns (uint256 supply) {
        uint256 epochStart = uint256(epochs[0].date).add(uint256(_epoch).mul(rewardsDuration));
        require(epochStart < block.timestamp, ""Epoch is in the future"");

        uint256 cutoffEpoch = epochStart.sub(lockDuration);
        uint256 lastIndex = epochs.length - 1;

        uint256 epochIndex = _epoch > lastIndex ? lastIndex : _epoch;

        for (uint256 i = epochIndex + 1; i > 0; i--) {
            Epoch memory e = epochs[i - 1];
            if (e.date == epochStart) {
                continue;
            } else if (e.date <= cutoffEpoch) {
                break;
            } else {
                supply += e.supply;
            }
        }
    }

    
    function findEpochId(uint256 _time) public view returns (uint256 epoch) {
        return _time.sub(epochs[0].date).div(rewardsDuration);
    }

    

    
    function epochCount() external view returns (uint256) {
        return epochs.length;
    }

    function decimals() external view returns (uint8) {
        return _decimals;
    }

    function name() external view returns (string memory) {
        return _name;
    }

    function symbol() external view returns (string memory) {
        return _symbol;
    }

    

    
    function claimableRewards(address _account) external view returns (EarnedData[] memory userRewards) {
        userRewards = new EarnedData[](rewardTokens.length);
        Balances storage userBalance = balances[_account];
        uint256 userRewardsLength = userRewards.length;
        for (uint256 i = 0; i < userRewardsLength; i++) {
            address token = rewardTokens[i];
            userRewards[i].token = token;
            userRewards[i].amount = _earned(_account, token, userBalance.locked);
        }
        return userRewards;
    }

    function lastTimeRewardApplicable(address _rewardsToken) external view returns (uint256) {
        return _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish);
    }

    function rewardPerToken(address _rewardsToken) external view returns (uint256) {
        return _rewardPerToken(_rewardsToken);
    }

    function _earned(
        address _user,
        address _rewardsToken,
        uint256 _balance
    ) internal view returns (uint256) {
        UserData memory data = userData[_user][_rewardsToken];
        return _balance.mul(_rewardPerToken(_rewardsToken).sub(data.rewardPerTokenPaid)).div(1e18).add(data.rewards);
    }

    function _lastTimeRewardApplicable(uint256 _finishTime) internal view returns (uint256) {
        return AuraMath.min(block.timestamp, _finishTime);
    }

    function _rewardPerToken(address _rewardsToken) internal view returns (uint256) {
        if (lockedSupply == 0) {
            return rewardData[_rewardsToken].rewardPerTokenStored;
        }
        return
            uint256(rewardData[_rewardsToken].rewardPerTokenStored).add(
                _lastTimeRewardApplicable(rewardData[_rewardsToken].periodFinish)
                    .sub(rewardData[_rewardsToken].lastUpdateTime)
                    .mul(rewardData[_rewardsToken].rewardRate)
                    .mul(1e18)
                    .div(lockedSupply)
            );
    }

    

    function queueNewRewards(uint256 _rewards) external nonReentrant {
        require(rewardDistributors[cvxCrv][msg.sender], ""!authorized"");
        require(_rewards > 0, ""No reward"");

        RewardData storage rdata = rewardData[cvxCrv];

        IERC20(cvxCrv).safeTransferFrom(msg.sender, address(this), _rewards);

        _rewards = _rewards.add(queuedCvxCrvRewards);
        if (block.timestamp >= rdata.periodFinish) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
            return;
        }

        
        uint256 elapsedTime = block.timestamp.sub(rdata.periodFinish.sub(rewardsDuration.to32()));
        
        uint256 currentAtNow = rdata.rewardRate * elapsedTime;
        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);
        if (queuedRatio < newRewardRatio) {
            _notifyReward(cvxCrv, _rewards);
            queuedCvxCrvRewards = 0;
        } else {
            queuedCvxCrvRewards = _rewards;
        }
    }

    function notifyRewardAmount(address _rewardsToken, uint256 _reward) external {
        require(_rewardsToken != cvxCrv, ""Use queueNewRewards"");
        require(rewardDistributors[_rewardsToken][msg.sender], ""Must be rewardsDistributor"");
        require(_reward > 0, ""No reward"");

        _notifyReward(_rewardsToken, _reward);

        
        
        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), _reward);
    }

    function _notifyReward(address _rewardsToken, uint256 _reward) internal updateReward(address(0)) {
        RewardData storage rdata = rewardData[_rewardsToken];

        if (block.timestamp >= rdata.periodFinish) {
            rdata.rewardRate = _reward.div(rewardsDuration).to96();
        } else {
            uint256 remaining = uint256(rdata.periodFinish).sub(block.timestamp);
            uint256 leftover = remaining.mul(rdata.rewardRate);
            rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();
        }

        rdata.lastUpdateTime = block.timestamp.to32();
        rdata.periodFinish = block.timestamp.add(rewardsDuration).to32();

        emit RewardAdded(_rewardsToken, _reward);
    }
}",6073.0,0,7,"Here is the list of vulnerabilities identified in the provided smart contract:

1. **Potential Overflow in Delegatee Checkpoints**:
   - The contract uses `uint224` for vote checkpoints. If the sum of delegated amounts exceeds `2^224 - 1`, conversions will overflow, causing transaction reverts and possible denial of service (DoS) for large stakeholders.

2. **Denial of Service in `delegate` Function**:
   - Looping over a user's locks in `delegate` can consume excessive gas if the user has many locks, leading to DoS when attempting to delegate.

3. **Incorrect DelegateeUnlocks Handling in `emergencyWithdraw`**:
   - When a user emergency withdraws, the contract fails to adjust `delegateeUnlocks` for their delegatee. This results in incorrect voting power calculations, as delegatees retain voting power from withdrawn tokens.

4. **Incorrect `lockData` Array Initialization**:
   - The `lockedBalances` function initializes `lockData` with a maximum possible size but doesn't account for valid entries. This leads to trailing default (zero) values in the returned array, providing inaccurate lock information.

5. **Unbounded Loops in Epoch Checkpointing**:
   - The `_checkpointEpoch` function uses a loop to create missing epochs. If called after a long delay, creating numerous epochs could exceed gas limits, causing DoS.

6. **Underflow Risk in DelegateeUnlocks**:
   - Subtracting lock amounts from `delegateeUnlocks` in `delegate` could underflow if prior state modifications (e.g., via unlocks) incorrectly reduced entries, leading to transaction reverts.

7. **Reward Rate Truncation in `_notifyReward`**:
   - When calculating `rewardRate`, integer division truncates residual values, resulting in undistributed reward dust. While not a security flaw, this causes minor precision loss.","### **Output**

---

**[M-03] Improperly Skewed Governance Mechanism**

**Report Description**:  
The balance checkpointing system for governance is flawed because it does not properly maintain voting balances. The total supply of votes is tracked as the sum of all locked balances, but individual voting power only tracks delegated balances. This discrepancy significantly affects governance percentage thresholds, potentially rendering them unmet.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of improperly skewed governance mechanisms or the discrepancy between total supply and individual voting power. This is a critical governance flaw that is entirely missed.

---

**[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**

**Report Description**:  
In `AuraLocker`, when expired locks are processed via kicking, the kick reward calculation multiplies the last locked amount by the number of epochs between the last lock's unlock time and the current epoch. This ignores the user's entire locked balance, leading to incorrect reward calculations.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect kick reward calculations in `AuraLocker`. This is a significant oversight in reward distribution logic.

---

**[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**

**Report Description**:  
Rewards distribution can be delayed or never distributed in the `_rewardPerToken()` function, potentially leading to users not receiving their rewards as expected.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of delayed or failed rewards distribution in `AuraLocker`. This is a critical flaw in the reward mechanism.

---

**[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**

**Report Description**:  
If a user does not claim their reward for a very long time, the reward may become permanently locked due to the passage of too many epochs. This could force the platform to reimburse the user, causing significant economic loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of rewards becoming permanently locked due to unclaimed epochs. This is a significant economic risk.

---

**[M-08] Locking up AURA Token does not increase voting power of individual**

**Report Description**:  
Per the documentation, locking AURA tokens in `AuraLocker` should grant vlAURA (voting power). However, after locking tokens, users' voting power does not increase, despite the ability to delegate voting power via `AuraLocker.delegate(address account)`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of locked AURA tokens not increasing voting power. This is a critical flaw in the governance mechanism.

---

**[M-10] Increase voting power by tokenizing the address that locks the token**

**Report Description**:  
The `_lock` function does not restrict the type of address that can lock tokens. A bad actor could lock tokens through a smart contract, potentially increasing voting power inappropriately.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of unrestricted token locking by smart contracts. This is a potential attack vector for manipulating voting power.

---

**[M-14] Integer overflow will lock all rewards in AuraLocker**

**Report Description**:  
There is a potential overflow in the rewards calculations, which would cause `updateReward()` to always revert, effectively locking all rewards.

**Match in Response List**:  
Matches with the issue titled **""Potential Overflow in Delegatee Checkpoints""**.

**Validation**:  
**Partially Correct**. The response identifies a potential overflow issue but focuses on delegatee checkpoints rather than rewards calculations in `AuraLocker`. While the core issue of overflow is addressed, the specific context of rewards locking is missed.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[M-14] Integer overflow will lock all rewards in AuraLocker**

**Missed Issues from Issue Report**:  
- **[M-03] Improperly Skewed Governance Mechanism**  
- **[M-04] AuraLocker kick reward only takes last locked amount into consideration, instead of whole balance**  
- **[M-06] Rewards distribution can be delayed/never distributed on AuraLocker.sol#L848**  
- **[M-07] Reward may be locked forever if user doesn't claim reward for a very long time such that too many epochs have been passed**  
- **[M-08] Locking up AURA Token does not increase voting power of individual**  
- **[M-10] Increase voting power by tokenizing the address that locks the token**  

--- 

The response list fails to address the majority of the issues in the issue report, particularly those related to governance, reward distribution, and voting power. Only one issue (M-14) is partially addressed, but the context is misaligned. Significant gaps remain in the coverage of critical vulnerabilities.",0,1,6,7,"Okay, I need to analyze this smart contract for vulnerabilities. Let me start by reading through the code and understanding what each part does. The contract is called AuraLocker, and it looks like it's for locking tokens and handling rewards. Let's go step by step.

First, the contract imports several OpenZeppelin libraries like SafeERC20, Ownable, ReentrancyGuard. That's good because they use standard security practices. The contract is using Solidity 0.8.11, which has built-in overflow checks, so that's a plus.

Looking at the state variables, there's a mapping for rewardData, rewardDistributors, userData, lockedSupply, epochs, balances, userLocks, delegates, etc. The constructor initializes some variables, including the staking token, cvxCrv, and cvxcrvStaking addresses.

The main functions are lock, getReward, processExpiredLocks, emergencyWithdraw, delegate, and functions related to rewards. Let's check for common vulnerabilities like reentrancy, access control issues, arithmetic issues, improper event emissions, etc.

Starting with the lock function. It uses the nonReentrant modifier and updateReward. The _lock function increases the user's locked balance and adds to the lockedSupply. They use SafeERC20's safeTransferFrom, which is safe. The userLocks are updated, and delegates are handled. Maybe possible issues here? Let me think. The lockedSupply is increased by the _amount, which is a user input. But since it's using SafeMath (AuraMath), maybe that's okay. But wait, they use .add from the library. So overflow checks should be handled. So maybe no overflow here.

The getReward function iterates over rewardTokens and transfers the rewards. If the token is cvxCrv and _stake is true, it stakes for the user. The function uses safeTransfer, so that's okay. But what if one of the reward tokens is malicious? Since reward tokens are added by the owner, maybe the owner needs to be trusted. If a malicious token is added, it could cause a reentrancy here. But since the function is marked nonReentrant, maybe that's mitigated. But the modifier is on getReward, which is the external function. However, the _earned function is called before transferring, so maybe the state is updated before the transfer. Wait, the modifier updateReward(_account) is applied, which updates the rewards before any transfers. So the checks-effects-interactions pattern is followed here. So reentrancy here is probably handled.

Looking at the processExpiredLocks and kickExpiredLocks functions. They call _processExpiredLocks. In that function, they calculate the reward for kicking, then transfer the reward to the _rewardAddress. If _relock is true, it calls _lock again. There's a transfer of stakingToken. Since stakingToken is a trusted token (set in constructor), maybe that's okay. The locked variable is a uint112, so when subtracting reward, which is a uint256, there's a potential underflow if reward > locked. Let's check the code:

In _processExpiredLocks, after calculating reward, they do:

locked = locked.sub(reward.to112());

But how is reward calculated? It's based on locks[i].amount and a rate. Since locks[i].amount is part of the user's locked balance, the reward can't exceed the locked amount. Wait, the code says:

reward = uint256(locks[length - 1].amount).mul(rRate).div(denominator);

rRate is at most denominator (since min(kickRewardPerEpoch * ..., denominator)). So reward can't exceed locks[i].amount. Therefore, when locked is the sum of some locks[i].amount, subtracting reward (which is <= sum) should not underflow. But what if multiple locks are processed? Let's say locked is the sum of multiple locks, and each lock's reward is added. Then reward could be up to sum * (kickRewardPerEpoch * epochsOver +1) / denominator. If kickRewardPerEpoch is set to 500 (since the setKickIncentive allows up to 500), and denominator is 10000, then 500 * (epochsOver +1) can be up to 500 * ... but since in setKickIncentive, the _rate is required to be <=500, then the max rRate is denominator (10000). Wait, no: the code says:

rRate = AuraMath.min(kickRewardPerEpoch.mul(epochsover + 1), denominator);

So if kickRewardPerEpoch is 500 and epochsOver is 19, 500 * 20 = 10,000 which is equal to denominator. So rRate would be 10000. Then reward is (locks[i].amount * 10000) / 10000 = locks[i].amount. So the reward could be equal to the locked amount. Then locked would be reward, and locked.sub(reward) would be zero. So no underflow here. But if the reward exceeds the locked amount, which could happen if multiple locks contribute to the reward. Wait, for example:

Suppose locked is 100, and the calculated reward is 150. Then locked.sub(reward) would underflow. Wait, but how can the reward be more than the locked amount?

Looking at how reward is calculated. Each lock's amount is multiplied by rRate (which can be up to denominator, 10000) divided by denominator. So each lock's contribution to reward is at most the lock's amount. Therefore, the sum of rewards for multiple locks would be sum(lock.amount * rRate_i / denominator). Since each rRate_i is <= denominator, the total reward would be <= sum(lock.amount) = locked. Therefore, reward can't exceed locked. So locked.sub(reward) can't underflow. So this is safe.

The emergencyWithdraw function allows users to withdraw their locked tokens if the contract is shutdown. It transfers the entire locked amount. But the function is only callable if isShutdown is true. The modifiers are correct here.

Looking at the delegate function. The user can delegate their votes. The function updates the delegateeUnlocks for old and new delegates. It calls _checkpointDelegate for both. In _checkpointDelegate, they adjust the votes based on upcoming additions and deductions. The code uses to224, to32, etc., which could cause truncation if the values are too large. For example, if _upcomingAddition is larger than 2^224-1, converting to uint224 would cause an overflow. But the code uses .to224(), which in SafeMath libraries typically reverts on overflow. Wait, the code uses AuraMath224, which probably has a to224 function. Looking at the imports, they have AuraMath, AuraMath32, etc. If these libraries use Solidity 0.8's built-in checks, then any overflow would revert. So if _upcomingAddition is larger than 224 bits, the to224() would revert. But where does _upcomingAddition come from? It's the sum of future unlocks, which are LockedBalance amounts. The LockedBalance.amount is a uint112. So summing multiple of those could exceed 224 bits? Let's see: uint112 max is 2^112 -1. Summing 2^112 such amounts would be 2^112 * (2^112 -1) which is 2^224 - 2^112. That's larger than 2^224 -1. So if a user has a lot of locks, the sum could exceed 224 bits, causing an overflow when converting to224. That's a possible vulnerability. For example, if a user has a lot of small locks, the sum could be too big, leading to a revert in the delegate function. This would prevent the user from delegating, which is a denial of service. Similarly, in the code:

ckpts.push(
    DelegateeCheckpoint({
        votes: (prevCkpt.votes - unlocksSinceLatestCkpt + _upcomingAddition - _upcomingDeduction).to224(),
        epochStart: upcomingEpoch.to32()
    })
);

Here, prevCkpt.votes is a uint224, and _upcomingAddition is a sum of uint112s. If the sum is large enough, adding to prevCkpt.votes could exceed 224 bits. For example, prevCkpt.votes is 2^224 -1, and adding even 1 would overflow. This would cause the transaction to revert, leading to a DoS.

So the vulnerability here is that the votes are stored as uint224, but when adding new amounts, if the sum exceeds 224 bits, the contract will revert. This could happen if a delegatee has a very large amount of tokens delegated to them. Since the locked amounts are in uint112, which is up to ~5e33 for 18 decimals, summing multiple could reach 2^224 (~2.7e67) which is possible if there are many large locks. So this is a potential issue.

Another area: the addReward function allows the owner to add new reward tokens. If a malicious reward token is added (like a token with a callback on transfer), could that introduce reentrancy? The getReward function transfers the reward tokens after updating the state, so maybe not. But if the reward token's transfer function calls back into the contract, it could potentially interfere. However, since the getReward function is nonReentrant, that should prevent reentrancy. But the modifier is on the external function, but the internal transfers are done in a loop. Let's see:

In getReward, after updating the rewards, it does:

if (_rewardsToken == cvxCrv && _stake ...) else { IERC20(_rewardsToken).safeTransfer(...) }

safeTransfer is from SafeERC20, which uses low-level calls and checks for success. If the token is malicious and the transfer calls back into the contract, the nonReentrant modifier would prevent reentrancy. So that's probably safe.

Another possible issue is in the _notifyReward function. When calculating the new reward rate, it does:

rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();

If _reward + leftover is not perfectly divisible by rewardsDuration, there's a truncation here. For example, if _reward + leftover is 1000 and rewardsDuration is 7 days (604800 seconds), 1000 / 604800 is 0.00165..., which would be 0 when divided. But using integer division, it truncates. This would lead to loss of precision and some rewards not being distributed. However, this is a known issue with reward distribution and is a design choice rather than a vulnerability. But if the leftover is not accounted for properly, it could leave dust amounts. However, the code here uses the standard method, so it's probably acceptable.

Another thing: the queueNewRewards function is for cvxCrv rewards. It checks if the distributor is authorized. Then, it transfers the rewards and adds them to queuedCvxCrvRewards or notifies immediately. The code uses:

_rewards = _rewards.add(queuedCvxCrvRewards);

If queuedCvxCrvRewards is very large, adding _rewards could overflow. But since _rewards is a uint256, and queuedCvxCrvRewards is also a uint256, adding them could overflow only if their sum exceeds 2^256-1. Given that ERC20 tokens can't have that much supply, this is unlikely. But technically possible. However, the code uses .add from AuraMath, which should have overflow checks. So if an overflow occurs, the transaction would revert, preventing that. So this is safe.

In the _checkpointEpoch function, when creating new epochs, it uses a loop to add epochs until the current one. If the current time is far in the future, this loop could run out of gas. For example, if the contract hasn't been checkpointed for a long time, creating all the epochs in between could consume too much gas. This is a potential DoS vector. For example, if someone calls checkpointEpoch after years, the transaction could fail due to excessive gas consumption.

Similarly, in the getPastVotes function, there's a loop that subtracts rewardsDuration from epoch until it reaches ckpt.epochStart. If the timestamp is very old, this loop could run many times, leading to an out-of-gas error. This would make the function call fail when querying old data. However, this is a view function, so it's not a vulnerability in the contract's state, but it could affect external systems relying on this function.

Another potential issue is in the balanceAtEpochOf function. It loops through the user's locks, which could be expensive if the user has many locks. Since this is a view function, it's not a vulnerability per se, but could be a gas inefficiency.

The delegate function has a loop that iterates through the user's locks to update delegateeUnlocks. If a user has many locks, this loop could run out of gas, making delegation impossible. This is a DoS vulnerability. For example, if a user has hundreds of locks, the delegate function could exceed the gas limit, preventing them from delegating.

Also, in the delegate function, when oldDelegatee is not zero, it subtracts currentLock.amount from delegateeUnlocks[oldDelegatee][currentLock.unlockTime]. However, if currentLock.amount is larger than the existing value, this could underflow. For example, if delegateeUnlocks[oldDelegatee][currentLock.unlockTime] is 100, and currentLock.amount is 150, subtracting 150 would underflow. Wait, no: the code does:

delegateeUnlocks[oldDelegatee][currentLock.unlockTime] -= currentLock.amount;

But how was the amount added in the first place? When the user initially locked the tokens, they were delegated to oldDelegatee, so delegateeUnlocks[oldDelegatee][unlockTime] was increased by lockAmount. Now, when delegating to a new delegatee, it subtracts that same amount. So if the oldDelegatee's unlockTime entry for that unlockTime was exactly the lock's amount, then this subtraction is safe. However, if there was a previous delegation change, maybe the amount could be incorrect. For example, if the user delegated to A, then to B, and now to C. When switching from A to B, the code would subtract the amount from A and add to B. Now when switching from B to C, the code subtracts from B's entry. But if the user's locks have changed in between (like some were unlocked), this could lead to incorrect values. Wait, the code here is in the delegate function, which is updating the delegateeUnlocks for future unlocks. So when a user delegates, they are changing the delegatee for all future unlocks. The code loops through all locks that have unlockTime > upcomingEpoch (which is block.timestamp + rewardsDuration), and adjusts the delegateeUnlocks for those. So the amounts subtracted from the oldDelegatee's unlockTime entries should correspond to the current lock's amount. However, if the user had previously delegated to someone else and those entries were modified, this could result in underflow. For example, if the user had delegated to A, then delegated to B, and then back to A, the code would subtract from B's entries. But if during that time some locks were processed (unlocked), the entries might not have the expected amounts. This seems possible. Let's say:

1. User has a lock with unlockTime T, delegates to A. delegateeUnlocks[A][T] += amount.
2. User delegates to B. The code subtracts amount from A's T entry and adds to B's T entry.
3. Then, user delegates back to A. The code would subtract amount from B's T entry and add to A's T entry.

But if during step 2, some of the locks were unlocked (processed), then the locks array would have been modified. However, the delegate function processes only locks that have unlockTime > upcomingEpoch (future locks). So if the lock was already unlocked, it's not included in the loop. Therefore, the code should handle that correctly. The problem arises if the delegateeUnlocks for a certain unlockTime is less than the amount being subtracted. For example, if delegateeUnlocks[oldDelegatee][T] is 100, but currentLock.amount is 150, then 100 - 150 would underflow. How can this happen? If the oldDelegatee's entry for T is less than the currentLock.amount, which could happen if the user had previously changed delegates and the oldDelegatee's entry was partially processed. Wait, but the delegateeUnlocks entries are supposed to track the amount of tokens that are locked and delegated, which unlock at time T. When the user delegates, all future locks (those with unlockTime > upcomingEpoch) are moved from oldDelegatee to newDelegatee. So the code should subtract exactly the amount that was added when the lock was created. However, if the user has multiple delegate changes, perhaps the entries could be incorrect. For example:

- User locks 100, delegates to A. delegateeUnlocks[A][T] = 100.
- User delegates to B. The code subtracts 100 from A's T, adds 100 to B's T. Now delegateeUnlocks[A][T] = 0, B's is 100.
- User delegates back to A. The code subtracts 100 from B's T, adds 100 to A's T. B's T becomes 0, A's T becomes 100.

But if during this process, some other operation modified delegateeUnlocks (like a kick or unlock), that could change the entries. For example, if a kick operation processed some of the locks and reduced delegateeUnlocks for B's T. Suppose after step 2, B's T entry is 100. Then, some tokens are kicked and processed, reducing B's T entry to 50. Then, when the user delegates back to A, the code would subtract 100 from B's T, which is now 50, leading to underflow. But how could the delegateeUnlocks be reduced? The only way is through processing unlocks. The delegateeUnlocks are adjusted in the _processExpiredLocks function when tokens are unlocked. When tokens are unlocked (either via processExpiredLocks or kickExpiredLocks), the code reduces the delegatee's unlocks. For example, when a lock is processed, the delegatee's unlock entry for that time is reduced. So if a user's lock is processed (unlocked), then the delegateeUnlocks entry is decreased, but the user's locks array is also modified (nextUnlockIndex is updated). Therefore, when the user delegates again, the code loops through their current locks (those that haven't been unlocked yet). So the code in delegate function only processes locks that are still locked (i.e., unlockTime > upcomingEpoch). Therefore, if a lock has been unlocked, it's no longer in the user's locks array (or is marked as processed via nextUnlockIndex), so it's not included in the loop. Therefore, the delegateeUnlocks entries for those processed locks would have already been adjusted. So the code should correctly handle the current locks. Therefore, the subtraction in delegateeUnlocks should not underflow, because the code only processes locks that are still present in the user's locks array, and the delegateeUnlocks entries for those locks should have been properly maintained. However, this depends on the correct handling of delegateeUnlocks in all code paths. If there's a bug in another part of the code that leads to incorrect delegateeUnlocks entries, this could cause underflow here. But assuming the code is correct elsewhere, this might not be an issue. But if there's a scenario where delegateeUnlocks[oldDelegatee][currentLock.unlockTime] is less than currentLock.amount, this subtraction would underflow. For example, if another function mistakenly reduces delegateeUnlocks entries, this could happen. Therefore, this is a potential vulnerability if other parts of the code mishandle delegateeUnlocks.

Another possible issue is in the emergencyWithdraw function. It sets userBalance.locked to 0 and transfers the entire amount. However, if the user had delegated their tokens, the delegatee's votes are not adjusted. Because when emergencyWithdraw is called, the user's locks are all considered unlocked. The code in emergencyWithdraw does not update the delegatee's unlock entries. For example, if the user had delegated to someone, their delegatee's delegateeUnlocks entries for future unlock times would still include the user's locked amount, even though the user has withdrawn. This would lead to incorrect voting power for the delegatee. The code does not call _checkpointDelegate in emergencyWithdraw. So after emergencyWithdraw, the delegatee still has voting power from the user's withdrawn tokens, which is incorrect. This is a vulnerability because the delegatee's voting power is not reduced when the user emergency withdraws.

Similarly, when a user emergencyWithdraws, the lockedSupply is reduced by their locked amount. However, the delegatee's votes are not updated. This would result in the total voting power being higher than the actual locked supply. The delegatee could have votes based on tokens that have been withdrawn. This breaks the accounting of voting power.

Another area: the _checkpointDelegate function. It creates checkpoints for the delegatee's votes. The code assumes that the upcomingEpoch is correctly calculated as block.timestamp + rewardsDuration rounded down. However, if the timestamp is not aligned with the rewardsDuration, there could be discrepancies. For example, if rewardsDuration is 7 days (604800 seconds), but the block.timestamp is not a multiple of that, the upcomingEpoch would be the next multiple. But I think the code handles this correctly.

In the _checkpointDelegate function, when creating a new checkpoint, if the previous checkpoint's epochStart is in the past, it calculates unlocksSinceLatestCkpt. This is the sum of delegateeUnlocks for epochs between the previous checkpoint and the new one. However, this loop could run multiple times if there are many epochs between the last checkpoint and the current one. For example, if there have been many epochs since the last checkpoint, this loop could consume a lot of gas, leading to a DoS. This is a potential vulnerability because the delegate function could become very expensive if the delegatee hasn't been checkpointed for a long time.

Additionally, the code in _checkpointDelegate may not correctly account for all unlocks between the last checkpoint and the current epoch. For example, if the delegatee's tokens were unlocked in epochs that are not covered by the checkpoints, the votes calculation might not subtract those unlocks. However, when the getPastVotes function is called, it subtracts the delegateeUnlocks for each epoch between the checkpoint and the target timestamp. So the checkpointing only affects the stored checkpoints, but the actual calculation in getPastVotes might still be correct. However, the gas cost for getPastVotes could be high.

Another possible issue is the use of experimental ABIEncoderV2. Although the contract declares it, in Solidity 0.8.11, the ABIEncoderV2 is enabled by default, so it's redundant. But this is not a security issue, just a code style issue.

In the notifyRewardAmount function, the code transfers the reward token from the distributor. However, if the reward token is not a standard ERC20 (e.g., it doesn't return a boolean from transferFrom), the safeTransferFrom will revert. Since the function requires the distributor to be authorized, the owner must ensure that the reward token is compatible. But if the owner adds a non-compliant token, this could cause the notifyRewardAmount function to fail. However, this is a trust issue with the owner, not a vulnerability in the code itself.

The contract also uses SafeERC20 for transfers, which is correct. However, if any of the reward tokens are contracts that mimic the ERC20 interface but have malicious behavior (like reentrancy), the nonReentrant modifier should prevent reentrancy attacks. For example, when a reward is transferred, if the token calls back into the contract, the nonReentrant modifier would block it.

Another possible issue is in the _notifyReward function. The line:

rdata.rewardRate = _reward.add(leftover).div(rewardsDuration).to96();

If _reward + leftover is not a multiple of rewardsDuration, the division truncates, leading to a small loss of precision. This means that some reward tokens might not be distributed. However, this is a common approach in reward contracts and is generally accepted, but it could be considered a minor issue.

In the lockedBalances function, when creating the lockData array, it initializes it with locks.length - i. If i starts at nextUnlockIndex and increases, the array could be larger than necessary. For example, if some locks are after i but have unlockTime <= block.timestamp, they are considered unlockable and not added to lockData. However, the code initializes lockData as locks.length - i, which could include unlockable locks if they are processed after i. Wait, in the loop:

for (uint256 i = nextUnlockIndex; i < locks.length; i++) {
    if (locks[i].unlockTime > block.timestamp) {
        if (idx == 0) {
            lockData = new LockedBalance[](locks.length - i);
        }
        lockData[idx] = locks[i];
        idx++;
        locked = locked.add(locks[i].amount);
    } else {
        unlockable = unlockable.add(locks[i].amount);
    }
}

The loop starts at nextUnlockIndex and goes to locks.length. For each lock, if unlockTime > now, it's added to lockData. The initial size is locks.length - i, which is the maximum possible (all remaining locks). But in reality, some of them may have unlockTime <= now, so lockData could have a larger size than needed, with some elements being uninitialized (but in Solidity, dynamic arrays are correctly resized, so this is not an issue. However, in the code, when idx ==0, it initializes lockData to locks.length - i, but then idx increments for each valid lock. However, if the first lock is valid, lockData is initialized with length (locks.length - i), but if some subsequent locks are invalid (unlockTime <= now), then lockData will have trailing elements that are not set. But in Solidity, when you create a dynamic array with a certain length, all elements are initialized to default values. Then, in the loop, idx is used to assign elements. So lockData will have (locks.length - i) elements, but only idx of them are set. The rest are default (zero) values. This is a bug because the returned lockData will include empty elements. For example, if there are 5 locks, and 3 are valid, the lockData array will have 5 - i elements (say 5 - 0 =5 if i starts at 0), but only 3 are filled. The other 2 will be zero. This is incorrect and would return invalid data. The correct approach is to count the number of valid locks first, then create the array with that size. As it is, the lockedBalances function returns an array that may have trailing empty entries, which is incorrect.

So this is a vulnerability in the lockedBalances function. It initializes the lockData array with locks.length - i, but if some of the locks after i have unlockTime <= block.timestamp, they are not added, leading to uninitialized elements in the array.

Another issue: the getPastVotes function's loop could run for a very long time if the timestamp is much older than the current epoch. For example, if someone queries votes from years ago, the loop would iterate once per week until it reaches the checkpoint's epochStart. This could lead to high gas consumption and potential out-of-gas errors. However, since this is a view function, it's not a vulnerability in the contract's state, but it could cause issues for external systems that rely on this function.

In summary, the vulnerabilities I can identify are:

1. Potential overflow in delegatee vote checkpoints due to using uint224, leading to DoS when delegating large amounts.
2. Denial of Service in delegate function due to gas limits when processing many locks.
3. Incorrect handling of delegateeUnlocks in emergencyWithdraw, leading to inflated voting power for delegatees.
4. Incorrect lockData array size in lockedBalances, leading to invalid data returned.
5. Unhandled loop in _checkpointEpoch could cause DoS if called after a long period of inactivity.
6. Underflow risk in delegateeUnlocks when subtracting lock amounts if previous state was incorrect.
7. Truncation of reward rates in _notifyReward leading to dust amounts not distributed.","```
None.
```",0.0
ConvexMasterChef.sol,"// SPDX-License-Identifier: MIT

pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";

/**
 * @title   ConvexMasterChef
 * @author  ConvexFinance
 * @notice  Masterchef can distribute rewards to n pools over x time
 * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,
 *          and thus it can over complicate the distribution of these rewards.
 *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed
 *          pro-rata based on the allocation points in each pool vs the total alloc.
 */
contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of CVXs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        IERC20 lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.
        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.
        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.
        IRewarder rewarder;
    }

    //cvx
    IERC20 public immutable cvx;
    // CVX tokens created per block.
    uint256 public immutable rewardPerBlock;
    // Bonus muliplier for early cvx makers.
    uint256 public constant BONUS_MULTIPLIER = 2;

    // Info of each pool.
    PoolInfo[] public poolInfo;
    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when CVX mining starts.
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    // Events
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    // Add a new lp to the pool. Can only be called by the owner.
    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    // Update the given pool's CVX allocation point. Can only be called by the owner.
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    // Return reward multiplier over the given _from to _to block.
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    // View function to see pending CVXs on frontend.
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        //cvx.mint(address(this), cvxReward);
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    // Deposit LP tokens to MasterChef for CVX allocation.
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    // Withdraw LP tokens from MasterChef.
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        //extra rewards
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2667.0,308.0,"[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect
In the ConvexMasterChef contract, a new staking pool can be added using the `add()` function. The staking token for the new pool is defined using the _lpToken variable. However, there is no additional checking whether the `_lpToken` is the same as the reward token (cvx) or not.
  [M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds
All calculations are rounded down, since a lack of tokens in the contracts cannot be rounding errors' fault. So the function is redundant. On the other hand, if the contract is undersupplied with cvx tokens, this will cause depositors to be sent less tokens than needed (or none). This is especially unsafe because the tokens that were lacking are not resembled in accountings at all. Thus a depositor may invoke the safeRewardTransfer and not receive tokens they were supposed to.
  [M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control
Reward token accounting update in `deposit()` and `withdraw()` happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future (i.e. have or can introduce the _beforetokentransfer, _afterTokenTransfer type of hooks; or, say, can be upgraded to ERC777), the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.
  [M-20] massUpdatePools() is susceptible to DoS with block gas limit
`massUpdatePools()` is a public function and it calls the updatePool() function for the length of poolInfo. Hence, it is an unbounded loop, depending on the length of poolInfo. If poolInfo.length is big enough, block gas limit may be hit.   [M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools
  [M-22] Duplicate LP token could lead to incorrect reward distribution
It was observed that add function is not checking for duplicate lpToken which allows 2 or more pools to have exact same lpToken. This can cause issue with reward distribution",6.0,"pragma solidity 0.6.12;

import ""@openzeppelin/contracts-0.6/math/SafeMath.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol"";
import ""@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol"";
import ""@openzeppelin/contracts-0.6/utils/Context.sol"";
import ""@openzeppelin/contracts-0.6/access/Ownable.sol"";
import ""./interfaces/IRewarder.sol"";


contract ConvexMasterChef is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    
    struct UserInfo {
        uint256 amount; 
        uint256 rewardDebt; 
        
        
        
        
        
        
        
        
        
        
        
    }

    
    struct PoolInfo {
        IERC20 lpToken; 
        uint256 allocPoint; 
        uint256 lastRewardBlock; 
        uint256 accCvxPerShare; 
        IRewarder rewarder;
    }

    
    IERC20 public immutable cvx;
    
    uint256 public immutable rewardPerBlock;
    
    uint256 public constant BONUS_MULTIPLIER = 2;

    
    PoolInfo[] public poolInfo;
    
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    
    uint256 public totalAllocPoint = 0;
    
    uint256 public immutable startBlock;
    uint256 public immutable endBlock;

    
    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);
    event EmergencyWithdraw(
        address indexed user,
        uint256 indexed pid,
        uint256 amount
    );

    constructor(
        IERC20 _cvx,
        uint256 _rewardPerBlock,
        uint256 _startBlock,
        uint256 _endBlock
    ) public {
        cvx = _cvx;
        rewardPerBlock = _rewardPerBlock;
        startBlock = _startBlock;
        endBlock = _endBlock;
    }

    function poolLength() external view returns (uint256) {
        return poolInfo.length;
    }

    
    
    function add(
        uint256 _allocPoint,
        IERC20 _lpToken,
        IRewarder _rewarder,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock
            ? block.number
            : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfo.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accCvxPerShare: 0,
                rewarder: _rewarder
            })
        );
    }

    
    function set(
        uint256 _pid,
        uint256 _allocPoint,
        IRewarder _rewarder,
        bool _withUpdate,
        bool _updateRewarder
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(
            _allocPoint
        );
        poolInfo[_pid].allocPoint = _allocPoint;
        if(_updateRewarder){
            poolInfo[_pid].rewarder = _rewarder;
        }
    }

    
    function getMultiplier(uint256 _from, uint256 _to)
        public
        view
        returns (uint256)
    {
        uint256 clampedTo = _to > endBlock ? endBlock : _to;
        uint256 clampedFrom = _from > endBlock ? endBlock : _from;
        return clampedTo.sub(clampedFrom);
    }

    
    function pendingCvx(uint256 _pid, address _user)
        external
        view
        returns (uint256)
    {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_user];
        uint256 accCvxPerShare = pool.accCvxPerShare;
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 multiplier = getMultiplier(
                pool.lastRewardBlock,
                block.number
            );
            uint256 cvxReward = multiplier
                .mul(rewardPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accCvxPerShare = accCvxPerShare.add(
                cvxReward.mul(1e12).div(lpSupply)
            );
        }
        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);
    }

    
    function massUpdatePools() public {
        uint256 length = poolInfo.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = pool.lpToken.balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);
        uint256 cvxReward = multiplier
            .mul(rewardPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        
        pool.accCvxPerShare = pool.accCvxPerShare.add(
            cvxReward.mul(1e12).div(lpSupply)
        );
        pool.lastRewardBlock = block.number;
    }

    
    function deposit(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        updatePool(_pid);
        if (user.amount > 0) {
            uint256 pending = user
                .amount
                .mul(pool.accCvxPerShare)
                .div(1e12)
                .sub(user.rewardDebt);
            safeRewardTransfer(msg.sender, pending);
        }
        pool.lpToken.safeTransferFrom(
            address(msg.sender),
            address(this),
            _amount
        );
        user.amount = user.amount.add(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);
        }

        emit Deposit(msg.sender, _pid, _amount);
    }

    
    function withdraw(uint256 _pid, uint256 _amount) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        require(user.amount >= _amount, ""withdraw: not good"");
        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);
        pool.lpToken.safeTransfer(address(msg.sender), _amount);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);
        }

        emit RewardPaid(msg.sender, _pid, pending);
        emit Withdraw(msg.sender, _pid, _amount);
    }

    function claim(uint256 _pid, address _account) external{
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][_account];

        updatePool(_pid);
        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(
            user.rewardDebt
        );
        safeRewardTransfer(_account, pending);
        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, _account, _account, pending, user.amount);
        }

        emit RewardPaid(_account, _pid, pending);
    }

    
    function emergencyWithdraw(uint256 _pid) public {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;

        
        IRewarder _rewarder = pool.rewarder;
        if (address(_rewarder) != address(0)) {
            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);
        }
    }

    
    function safeRewardTransfer(address _to, uint256 _amount) internal {
        uint256 cvxBal = cvx.balanceOf(address(this));
        if (_amount > cvxBal) {
            cvx.safeTransfer(_to, cvxBal);
        } else {
            cvx.safeTransfer(_to, _amount);
        }
    }

}",2047.0,0,6,"Here is a list of vulnerabilities identified in the provided smart contract:

1. **Inflation/Fake Deposit Attack**: 
   - The contract calculates rewards based on the LP token's balance (`lpSupply = pool.lpToken.balanceOf(address(this))`) instead of tracking the sum of user deposits. An attacker can manipulate rewards by donating LP tokens directly to the contract, diluting the rewards for legitimate users.

2. **Fee-on-Transfer Token Handling**:
   - The contract assumes LP tokens have no transfer fees. If a fee-on-transfer token is used, the actual received amount will differ from `_amount`, causing discrepancies between `user.amount` and the contract's balance, leading to incorrect reward calculations.

3. **Reentrancy Vulnerabilities**:
   - Critical functions like `deposit`, `withdraw`, and `claim` lack reentrancy guards. Malicious LP tokens or rewarder contracts could reenter these functions, enabling attackers to manipulate state (e.g., double-spending rewards or draining funds).

4. **Division by Zero in Reward Distribution**:
   - If `totalAllocPoint` is zero (e.g., all pools have `allocPoint = 0`), calculations like `cvxReward = multiplier.mul(rewardPerBlock).mul(pool.allocPoint).div(totalAllocPoint)` will revert due to division by zero, halting contract operations.

5. **Missing Validation in Pool Creation**:
   - The `add` function allows pools with `_allocPoint = 0`, which could lead to `totalAllocPoint = 0` if all pools have zero allocation. This would trigger division by zero errors in reward calculations.

6. **Unchecked Constructor Parameters**:
   - The constructor does not validate that `startBlock <= endBlock`. If `endBlock` is set before `startBlock`, the reward multiplier becomes zero, preventing reward distribution entirely.

7. **Unused BONUS_MULTIPLIER**:
   - The constant `BONUS_MULTIPLIER` is declared but not applied in `getMultiplier`, resulting in rewards being lower than intended (e.g., missing a planned 2x bonus period).

8. **Unsafe ERC20 Token Interactions**:
   - The contract does not account for ERC20 tokens with callbacks (e.g., ERC777). Transferring such tokens could allow reentrancy attacks during `deposit` or `withdraw`.

9. **Insufficient Reward Balance Handling**:
   - The `safeRewardTransfer` function sends whatever CVX balance is available if rewards exceed the contract's holdings. Users may receive partial rewards if the contract is underfunded, leading to unfair reward distribution.

10. **Arbitrary Triggering of Claims**:
    - The `claim` function allows anyone to trigger a reward claim for any user. While not directly exploitable, this could lead to unintended interactions with rewarder contracts or unnecessary gas costs for users.

11. **Risk of Malfunctioning Rewarder Contracts**:
    - The owner can set a `rewarder` contract without validation. A faulty or malicious rewarder could cause transactions to revert (e.g., failing `onReward` calls) or manipulate rewards if compromised.","### **Output**

---

**[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**

**Report Description**:
The `add()` function in the ConvexMasterChef contract does not check whether the `_lpToken` is the same as the reward token (cvx). This oversight could lead to incorrect reward calculations if `_lpToken` is set to cvx, as the contract does not distinguish between the staking token and the reward token.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect reward calculation due to the lack of validation between `_lpToken` and the reward token (cvx). This is a specific vulnerability that is not covered in the response list.

---

**[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**

**Report Description**:
The `safeRewardTransfer` function does not account for rounding errors and may send fewer tokens than required if the contract is undersupplied with cvx tokens. This can lead to depositors receiving fewer tokens than they are entitled to, and the lack of accounting for the missing tokens can result in a loss of funds.

**Match in Response List**:
Matches with the issue titled **""Insufficient Reward Balance Handling""**.

**Validation**:
**Correct**. The response accurately identifies the issue with insufficient reward balance handling in the `safeRewardTransfer` function. It correctly explains the risks associated with underfunded contracts and the potential for users to receive partial rewards, which aligns with the reported issue.

---

**[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**

**Report Description**:
The `deposit()` and `withdraw()` functions in the ConvexMasterChef contract update reward token accounting after the reward transfer. If the reward token allows for transfer flow control (e.g., ERC777 tokens), an attacker could reenter these functions and drain all reward funds from the contract.

**Match in Response List**:
Matches with the issue titled **""Reentrancy Vulnerabilities""**.

**Validation**:
**Correct**. The response accurately identifies the reentrancy vulnerability in the `deposit` and `withdraw` functions. It correctly explains the risks associated with reward tokens that allow for transfer flow control, which aligns with the reported issue.

---

**[M-20] massUpdatePools() is susceptible to DoS with block gas limit**

**Report Description**:
The `massUpdatePools()` function calls `updatePool()` for each pool in `poolInfo`, which is an unbounded loop. If `poolInfo.length` is large enough, the function may exceed the block gas limit, causing a denial of service (DoS).

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of `massUpdatePools()` being susceptible to a DoS attack due to the block gas limit. This is a specific vulnerability that is not covered in the response list.

---

**[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**

**Report Description**:
The `add()` and `set()` functions in the ConvexMasterChef contract do not call `massUpdatePools()` to update all pools. This could lead to outdated pool information and incorrect reward calculations.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of `add()` and `set()` functions failing to call `massUpdatePools()`. This is a specific vulnerability that is not covered in the response list.

---

**[M-22] Duplicate LP token could lead to incorrect reward distribution**

**Report Description**:
The `add()` function in the ConvexMasterChef contract does not check for duplicate LP tokens, allowing multiple pools to have the same LP token. This could lead to incorrect reward distribution.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of duplicate LP tokens leading to incorrect reward distribution. This is a specific vulnerability that is not covered in the response list.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-15] ConvexMasterChef: `safeRewardTransfer` can cause loss of funds**
- **[M-17] ConvexMasterChef's deposit and withdraw can be reentered drawing all reward funds from the contract if reward token allows for transfer flow control**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[M-13] ConvexMasterChef: When `_lpToken` is cvx, reward calculation is incorrect**
- **[M-20] massUpdatePools() is susceptible to DoS with block gas limit**
- **[M-21] ConvexMasterChef: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools**
- **[M-22] Duplicate LP token could lead to incorrect reward distribution**

---",2,0,4,11,"Okay, let's start by looking at this smart contract. The user wants me to list all the vulnerabilities without suggesting mitigations. Alright, let's go through the code step by step.

First, the contract is called ConvexMasterChef, which seems to be a staking or farming contract, similar to MasterChef in SushiSwap. It uses SafeMath and SafeERC20 from OpenZeppelin, which is good for preventing overflows and safe token transfers. Let's check for common vulnerabilities.

Looking at the imports, they're using contracts from version 0.6.12. Wait, OpenZeppelin's contracts in 0.6.x might have some issues compared to newer versions, but maybe that's not a vulnerability per se. But sometimes older versions have known vulnerabilities. For example, the Context and Ownable contracts in 0.6 don't have the same features as newer versions, but maybe that's not directly exploitable here.

The UserInfo struct has amount and rewardDebt. The PoolInfo includes an IRewarder. The main contract has functions for adding pools, depositing, withdrawing, etc. Let's check the functions.

Starting with the add function: it's onlyOwner, which is fine. But when adding a new pool, the lastRewardBlock is set to block.number or startBlock. If the startBlock is in the future, then when the pool is added, lastRewardBlock could be startBlock. But when the pool is added after the startBlock, it uses block.number. That might affect reward calculations, but I'm not sure if that's a vulnerability yet.

Looking at the set function: it allows the owner to change the allocPoint and rewarder. If the rewarder can be set to a malicious contract, that could be an issue. But since it's onlyOwner, maybe it's a trust issue. But if the owner is malicious, they could set a bad rewarder. However, that's more of a centralization risk than a code vulnerability.

The getMultiplier function checks if the _from and _to are within the endBlock. If _from is after endBlock, returns clampedFrom as endBlock, so multiplier is zero. That seems okay.

pendingCvx function: calculates pending rewards. It uses pool.accCvxPerShare and lpSupply. If lpSupply is zero, no rewards are calculated. That's correct. But if someone donates tokens to the pool, increasing lpSupply, would that affect the rewards? Let me think. The lpSupply is the balanceOf(this) for the lpToken. So if someone transfers tokens directly to the contract, the lpSupply increases, which would dilute the accCvxPerShare. That could be a problem. For example, a malicious user could send tokens to the pool, making lpSupply larger, thus making the rewards per share smaller, and then other users' pending rewards would be less. That's a possible vulnerability. Because the contract doesn't track the actual deposited amount but uses the balance, it's susceptible to inflation attacks. This is similar to the issue in some staking contracts where the reward calculation depends on the actual balance, not the sum of user deposits. So if someone adds tokens to the pool without going through deposit, it can manipulate the rewards. That's a big issue.

In the deposit function: when a user deposits, it calls updatePool, which updates the pool's accCvxPerShare based on the current lpSupply. If someone donates tokens to the pool before this, it would dilute the rewards. So the pending rewards are calculated based on the balance, not the sum of user.amount. That's a problem. So this contract is vulnerable to fake deposit attacks or inflation attacks. This is a critical vulnerability.

Another point: in the deposit function, after transferring the lpToken from the user, user.amount is increased. But if the lpToken is a fee-on-transfer token, the actual received amount might be less than _amount. For example, if the token takes a fee on transfer, the contract's balance increases by less than _amount. But the code here adds _amount to user.amount, which would not match the actual balance. So if the lpToken is a fee-on-transfer token, this would cause discrepancies in the accounting. The contract doesn't check the balance before and after the transfer to compute the actual received amount. That's another vulnerability.

Similarly, in withdraw: when the user withdraws, it's assumed that transferring _amount will succeed, but again, if the token has fees, the actual amount transferred might be less. But in this case, the user's amount is being subtracted by _amount, which could lead to underflow if the actual transferred amount is less. Wait, no: because the user's amount is tracked by the contract, and the transfer is done via SafeERC20's safeTransfer, which should revert if the contract doesn't have enough. But if the token is a fee-on-transfer, then the contract's balance might not match the sum of user deposits, leading to issues. So using fee-on-transfer tokens as lpToken would break the accounting. So the contract doesn't handle such tokens, which is a vulnerability if such tokens are allowed as lpToken.

Next, the safeRewardTransfer function: when transferring rewards, if the contract doesn't have enough cvx, it sends the remaining balance. So if the reward calculation says the user should get _amount, but the contract has less, they get whatever is left. That's a design choice, but could be considered a vulnerability if the contract is underfunded, leading to users not receiving their full rewards. However, since the MasterChef is supposed to have enough cvx, this might be intentional to prevent reverts. But in that case, users might not get their due rewards. It's a potential issue if the contract's cvx balance is not properly maintained.

Looking at the emergencyWithdraw function: it transfers user.amount to the user, but doesn't update the pool's rewards. The user's rewardDebt is set to zero, but does this function properly account for any pending rewards? The function doesn't claim any pending rewards, so the user loses any unclaimed rewards when using emergencyWithdraw. But the event emitted is EmergencyWithdraw, and RewardPaid is not called here. However, the function calls the rewarder.onReward with pending=0. So if the rewarder expects pending rewards, they might not be handled here. But according to the code, emergencyWithdraw is for emergencies where the user just wants to withdraw their funds without caring about the rewards. So that's a design decision, not a vulnerability per se.

Another thing: the rewardPerBlock is immutable, and the endBlock is set. Once the endBlock is reached, no more rewards are generated. That's okay, but if the endBlock is too far in the future, the rewards might be issued for longer than intended. However, that's setup during construction, so depends on deployment parameters.

Reentrancy: The deposit and withdraw functions use the nonReentrant modifier from SafeERC20? Wait, no. The code here doesn't have any reentrancy guards. The deposit function does transferFrom, then updates the user's amount and rewardDebt. If the lpToken is a malicious contract that calls back into deposit or withdraw, it could cause reentrancy attacks. For example, if during the transferFrom, the token calls back into the contract, the user could manipulate their rewards or state before the contract updates their balance. Since there are no reentrancy guards, this is a possible vulnerability. This is a common issue in contracts that interact with external tokens without using checks-effects-interactions pattern. Let's check the deposit function:

In deposit:
1. updatePool (external call via updatePool)
2. if user.amount > 0, transfer rewards (safeRewardTransfer)
3. transferFrom (user to contract)
4. update user.amount and rewardDebt
5. call rewarder.onReward

The transferFrom is after the reward transfer. Wait, no: the code transfers the lpToken after calculating and sending the pending rewards. So during the transferFrom, if the token is malicious and reenters, the user's state hasn't been updated yet. For example, suppose a user calls deposit, the contract first updates the pool, sends pending rewards (if any), then does transferFrom. If the token's transferFrom function calls back into deposit, the user's user.amount hasn't been updated yet. So the new deposit would be processed with the old user.amount. But maybe that's not critical. However, without reentrancy guards, this could allow for reentrancy attacks. So the contract is vulnerable to reentrancy if the lpToken or rewarder is malicious.

Another point: the rewarder.onReward is called in deposit, withdraw, emergencyWithdraw, and claim. The IRewarder's onReward function is external, so if the rewarder is a malicious contract, it could do anything. But the rewarder is set by the owner, so if the owner is trusted, it's okay. But if the owner is compromised or sets a malicious rewarder, that's a problem. But since the owner can set the rewarder via the set function, this is a centralization risk. However, the question is about vulnerabilities in the code, not trust issues. So if the code allows the owner to set a malicious rewarder, that's a vulnerability only if there's no access control, but here it's onlyOwner. So maybe that's not a code vulnerability but a trust issue.

Another possible issue: division in Solidity rounds down. For example, when calculating cvxReward.mul(1e12).div(lpSupply), if the multiplication and division leads to truncation, rewards could be slightly less than expected. However, that's a common issue and usually accepted as part of the design.

Looking at the claim function: it's external, so anyone can call it for any _pid and _account. Wait, no. The claim function allows any user to trigger a claim for any _account. For example, I can call claim(_pid, Alice) and it will calculate Alice's pending rewards and send them to her. Is that a problem? Let's see. The code updates the pool, calculates pending, sends the reward, updates the rewardDebt, and calls the rewarder.onReward with _account as the recipient. Since the reward is sent to _account, and the rewarder is called with _account as the receiver, there's no immediate issue here. However, allowing anyone to trigger a claim on behalf of another user could lead to front-running or griefing, but maybe that's intended. However, in some cases, this could be used to trigger a reward claim when the user didn't want to, possibly causing tax implications or other issues. But this is more of a design choice than a vulnerability. Alternatively, if the rewarder's onReward function has side effects that can be triggered by anyone, that could be a problem. But again, if the rewarder is trusted, this is okay. So unless there's a specific vulnerability here, it's probably not an issue.

In the set function, when _updateRewarder is true, the rewarder is updated. However, there's no check that the new rewarder is a valid contract. If the owner sets a broken rewarder (e.g., address(0)), then calls to onReward would fail. For example, when a user deposits or withdraws, if the rewarder is set to a contract that doesn't implement the onReward function, those transactions would revert. But since the owner controls this, it's more of an availability issue than a security vulnerability.

Another thing: the totalAllocPoint is updated in add and set. However, in add, when the pool is pushed, the allocPoint is added to totalAllocPoint. If the totalAllocPoint is zero, adding a pool with allocPoint would set totalAllocPoint to that value, but if all pools are removed (by setting their allocPoint to zero), then totalAllocPoint could be zero. If that happens, the calculation of cvxReward would be division by zero in pendingCvx and updatePool. Let's check:

In pendingCvx:
cvxReward = multiplier.mul(rewardPerBlock).mul(pool.allocPoint).div(totalAllocPoint);
If totalAllocPoint is zero, this would revert. However, when adding a pool via add function, totalAllocPoint is set to totalAllocPoint.add(_allocPoint). So the first pool added must have _allocPoint > 0, which is not enforced. If the owner adds a pool with _allocPoint zero, then totalAllocPoint would be zero. Then, in pendingCvx, the division by zero would happen. So the code doesn't check that _allocPoint is non-zero when adding a pool, leading to possible division by zero. That's a vulnerability.

Similarly, in the set function, if the owner sets a pool's allocPoint such that totalAllocPoint becomes zero, then any calls to pendingCvx or updatePool would revert due to division by zero.

Also, in the add function, the owner can add a pool with _allocPoint zero. So if the owner is malicious or makes a mistake, this can cause the contract to become inoperable.

Another possible issue: the startBlock and endBlock are set in the constructor. If startBlock is after the current block during deployment, rewards start later. But if the endBlock is set to a block before the startBlock, the getMultiplier would return zero. The constructor doesn't check that startBlock <= endBlock. So if the deployment parameters are incorrect, the contract would not function. But since these are immutable, once set, there's no way to fix it. This is a potential vulnerability if the contract is deployed with incorrect parameters.

Now, let's summarize the vulnerabilities found:

1. **Inflation Attack / Fake Deposit Vulnerability**: The contract uses the lpToken's balance to calculate rewards (lpSupply = pool.lpToken.balanceOf(address(this))). This allows an attacker to inflate the lpSupply by directly transferring tokens to the contract, thereby diluting the rewards for existing users. This can be exploited by donating tokens to the pool, reducing the rewards per share.

2. **Fee-on-Transfer Token Handling**: The contract does not account for fee-on-transfer tokens. When a user deposits, the contract assumes that the transferred amount equals the received amount, which is not the case for tokens that take a fee on transfer. This leads to incorrect accounting of user balances (user.amount) relative to the actual contract balance.

3. **Reentrancy Vulnerabilities**: The deposit, withdraw, and other functions do not include reentrancy guards. If the lpToken or rewarder contract is malicious and implements a reentrant call, an attacker could manipulate the contract state during the token transfer.

4. **Division by Zero in Reward Calculation**: If the totalAllocPoint is zero (e.g., if all pools have allocPoint set to zero), then calculations in pendingCvx and updatePool will divide by zero, causing transactions to revert. This can occur if the owner adds a pool with _allocPoint zero or sets existing pools' allocPoint to zero, making totalAllocPoint zero.

5. **Lack of Input Validation in add Function**: The add function does not validate that _allocPoint is greater than zero. Allowing a pool with zero allocPoint can lead to division by zero if totalAllocPoint becomes zero.

6. **No Check for startBlock <= endBlock in Constructor**: The contract does not enforce that startBlock is less than or equal to endBlock. If endBlock is set to a block number before startBlock, the getMultiplier function will always return zero, resulting in no rewards being distributed.

7. **Unsafe Use of ERC20 Tokens with Callbacks**: The contract interacts with ERC20 tokens without considering potential callback attacks (though ERC20 standard doesn't include callbacks, some tokens like ERC777 do). If the lpToken is an ERC777 token with hooks, a malicious user could perform reentrancy attacks.

8. **Insufficient Reward Balance Handling**: The safeRewardTransfer function sends the remaining CVX balance if the calculated reward exceeds the contract's balance. This could lead to users not receiving their full rewards if the contract is underfunded, which might be a design choice but can be seen as a potential issue.

9. **Arbitrary Claim Function**: The claim function allows any user to trigger a claim for any other user. While not a direct vulnerability, it could lead to unexpected behavior or gas costs for users if exploited maliciously.

Wait, maybe point 9 is more of a design choice. Let me think. Allowing anyone to call claim on behalf of another user could be used to front-run or cause unexpected transfers, but since the rewards are sent to the rightful owner, it's not directly stealing funds. However, this could be used to trigger the rewarder's onReward function, which might have side effects. If the rewarder is designed to perform certain actions only when the user claims, allowing anyone to trigger this might be a vulnerability depending on the rewarder's implementation. However, since the rewarder is set by the owner, this is more of an integration issue than a contract vulnerability.

Another thing: the updatePool function is public and can be called by anyone. This is normal in MasterChef contracts to allow accurate reward calculations. So that's not a vulnerability.

Potential issue with block.number usage: The code uses block.number for calculating blocks, which is standard, but if the blockchain's block time is variable, rewards could be affected. Not a code vulnerability.

Also, the BONUS_MULTIPLIER is declared as a constant but not used anywhere. That's dead code, but not a vulnerability. However, if the multiplier was intended to be used in getMultiplier and isn't, that's a bug. Looking at getMultiplier, it returns clampedTo - clampedFrom, without applying the BONUS_MULTIPLIER. The comment mentions ""including bonus"" but the code doesn't use it. Wait, looking back, the original code has BONUS_MULTIPLIER = 2, but in getMultiplier, it's not used. So this is a mistake. The multiplier is supposed to multiply by BONUS_MULTIPLIER but doesn't. This would mean that rewards are not doubled as intended. That's a bug, leading to incorrect reward distribution.

Looking at the code for getMultiplier:

function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {
    uint256 clampedTo = _to > endBlock ? endBlock : _to;
    uint256 clampedFrom = _from > endBlock ? endBlock : _from;
    return clampedTo.sub(clampedFrom);
}

So it's just the difference between the clamped blocks. But the comment at BONUS_MULTIPLIER says ""To make it easier for users to figure out"", but the multiplier is not applied. This indicates a logic error where the bonus is not being used. For example, if the code was supposed to apply BONUS_MULTIPLIER during certain periods (like a bonus period), but it's not implemented. This would result in lower rewards than intended, which is a vulnerability in the contract's logic.

So that's another vulnerability: Unused BONUS_MULTIPLIER leading to incorrect reward calculation.

Putting it all together, here's the list of vulnerabilities I found.","```
1. Insufficient Reward Balance Handling
2. Reentrancy Vulnerabilities
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Insufficient Reward Balance Handling"" appears at rank 9.
   - ""Reentrancy Vulnerabilities"" appears at rank 3.

2. **Calculate the precision at each rank where a true positive appears**:
   - For rank 3: \( P@3 = \frac{1}{3} \approx 0.333 \)
   - For rank 9: \( P@9 = \frac{2}{9} \approx 0.222 \)

3. **Average the precision values**:
   - \( AP = \frac{0.333 + 0.222}{2} = \frac{0.555}{2} \approx 0.2775 \)

**Average Precision (AP)**: 0.2775"
,,,,,,,,1,16,,,3,2,12,26,,,
