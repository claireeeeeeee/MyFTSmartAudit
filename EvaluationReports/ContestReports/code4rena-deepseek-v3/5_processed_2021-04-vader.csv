nameid,code,tokens,loc,issue,vulnumber,code_snippet,processtokens,high_severity_count,medium_severity_count,Findings,Comparison,Correct Matches,Partially Correct,Missed,GPT-generated,matchList,MAP
Pools.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iFACTORY.sol"";

contract Pools {

    // Parameters
    bool private inited;
    uint public pooledVADER;
    uint public pooledUSDV;
    
    address public VADER;
    address public USDV;
    address public ROUTER;
    address public FACTORY;

    mapping(address => bool) _isMember;
    mapping(address => bool) _isAsset;
    mapping(address => bool) _isAnchor;

    mapping(address => uint) public mapToken_Units;
    mapping(address => mapping(address => uint)) public mapTokenMember_Units;
    mapping(address => uint) public mapToken_baseAmount;
    mapping(address => uint) public mapToken_tokenAmount;

    // Events
    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);
    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);
    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);
    event Sync(address indexed token, address indexed pool, uint addedAmount);
    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}

    // Init
    function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {
        require(token != USDV && token != VADER); // Prohibited
        uint _actualInputBase;
        if(base == VADER){
            if(!isAnchor(token)){               // If new Anchor
                _isAnchor[token] = true;
            }
            _actualInputBase = getAddedAmount(VADER, token);
        } else if (base == USDV) {
            if(!isAsset(token)){               // If new Asset
                _isAsset[token] = true;
            }
            _actualInputBase = getAddedAmount(USDV, token);
        }
        uint _actualInputToken = getAddedAmount(token, token);
        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);
        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member
        mapToken_Units[token] += liquidityUnits;                // Add in total
        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE
        mapToken_tokenAmount[token] += _actualInputToken;       // Add token
        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); // Because this contract is wrapped by a router
    }
    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, msg.sender); // If want to interact directly
    }
    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {
        require(base == USDV || base == VADER);
        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);
        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);
        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);
        mapToken_Units[token] -=_units;
        mapTokenMember_Units[token][member] -= _units;
        mapToken_baseAmount[token] -= outputBase;
        mapToken_tokenAmount[token] -= outputToken;
        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);
        transferOut(base, outputBase, member);
        transferOut(token, outputToken, member);
        return (outputBase, outputToken);
    }
    
    //=======================================SWAP===========================================//
    
    // Designed to be called by a router, but can be called directly
    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {
        if(toBase){
            uint _actualInput = getAddedAmount(token, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            mapToken_tokenAmount[token] += _actualInput;
            mapToken_baseAmount[token] -= outputAmount;
            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);
            transferOut(base, outputAmount, member);
        } else {
            uint _actualInput = getAddedAmount(base, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            mapToken_baseAmount[token] += _actualInput;
            mapToken_tokenAmount[token] -= outputAmount;
            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);
            transferOut(token, outputAmount, member);
        }
    }

    // Add to balances directly (must send first)
    function sync(address token, address pool) external {
        uint _actualInput = getAddedAmount(token, pool);
        if (token == VADER || token == USDV){
            mapToken_baseAmount[pool] += _actualInput;
        } else {
            mapToken_tokenAmount[pool] += _actualInput;
        // } else if(isSynth()){
        //     //burnSynth && deleteUnits
        }
        emit Sync(token, pool, _actualInput);
    }

    //======================================SYNTH=========================================//

    // Should be done with intention, is gas-intensive
    function deploySynth(address token) external {
        require(token != VADER || token != USDV);
        iFACTORY(FACTORY).deploySynth(token);
    }

    // Mint a Synth against its own pool
    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {
        require(iFACTORY(FACTORY).isSynth(getSynth(token)), ""!synth"");
        uint _actualInputBase = getAddedAmount(base, token);                    // Get input
        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     // Get Units
        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   // Get output
        mapTokenMember_Units[token][address(this)] += _synthUnits;                  // Add units for self
        mapToken_Units[token] += _synthUnits;                                       // Add supply
        mapToken_baseAmount[token] += _actualInputBase;                             // Add BASE 
        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   // Add Liquidity Event
        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         // Ask factory to mint to member
    }
    // Burn a Synth to get out BASE
    function burnSynth(address base, address token, address member) external returns (uint outputBase) {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata
        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self
        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units
        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    // Get output
        mapToken_baseAmount[token] -= outputBase;                                   // Remove BASE
        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        // Remove liquidity event
        transferOut(base, outputBase, member);                                      // Send BASE to member
    }
    // Remove a synth, make other LPs richer
    function syncSynth(address token) external {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  // Get input
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); // Pro rata
        iERC20(getSynth(token)).burn(_actualInputSynth);                            // Burn it
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               // Delete units for self
        mapToken_Units[token] -= _unitsToDelete;                                    // Delete units
        emit SynthSync(token, _actualInputSynth, _unitsToDelete);
    }

    //======================================LENDING=========================================//
    
    // Assign units to callee (ie, a LendingRouter)
    function lockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][member] -= units;
        mapTokenMember_Units[token][msg.sender] += units;       // Assign to protocol
    }
    // Assign units to callee (ie, a LendingRouter)
    function unlockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][msg.sender] -= units;      
        mapTokenMember_Units[token][member] += units;
    }

    //======================================HELPERS=========================================//

    // Safe adds
    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(_token == VADER && _pool != VADER){  // Want to know added VADER
            addedAmount = _balance - pooledVADER;
            pooledVADER = pooledVADER + addedAmount;
        } else if(_token == USDV) {             // Want to know added USDV
            addedAmount = _balance - pooledUSDV;
            pooledUSDV = pooledUSDV + addedAmount;
        } else {                                // Want to know added Asset/Anchor
            addedAmount = _balance - mapToken_tokenAmount[_pool];
        }
    }
    function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; // Accounting
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount;  // Accounting
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }

    function isMember(address member) public view returns(bool) {
        return _isMember[member];
    }
    function isAsset(address token) public view returns(bool) {
        return _isAsset[token];
    }
    function isAnchor(address token) public view returns(bool) {
        return _isAnchor[token];
    }
    function getPoolAmounts(address token) external view returns(uint, uint) {
        return (getBaseAmount(token), getTokenAmount(token));
    }
    function getBaseAmount(address token) public view returns(uint) {
        return mapToken_baseAmount[token];
    }
    function getTokenAmount(address token) public view returns(uint) {
        return mapToken_tokenAmount[token];
    }
    function getUnits(address token) external view returns(uint) {
        return mapToken_Units[token];
    }
    function getMemberUnits(address token, address member) external view returns(uint) {
        return mapTokenMember_Units[token][member];
    }
    function getSynth(address token) public view returns (address) {
        return iFACTORY(FACTORY).getSynth(token);
    }
    function isSynth(address token) public view returns (bool) {
        return iFACTORY(FACTORY).isSynth(token);
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
}",2964.0,248.0,"[H-01] Unhandled return value of transfer in transferOut() of Pools.sol
ERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements to handle these failures.
The transfer call on L211 of transferOut() could be made on a user-supplied untrusted token address (from the different call sites) whose implementation can be malicious.
 [H-11] Swap token can be traded as fake base token
The Pools.swap function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call swap(token, token, member, toBase=false)
The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.
It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased (and token balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again.
Another example scenario is that the token pool amount can be stolen. Send tokenIn=baseAmount of tokens to the pool and call swap(base=token, token, member, toBase=false). Depending on the price of token relative to base this could be cheaper than trading with the base tokens.  [H-12] getAddedAmount can return wrong results
The getAddedAmount function only works correctly when called with (VADER/USDV, pool) or (pool, pool). However, when called with (token, pool) where token is neither VADER/USDV/pool, it returns the wrong results:
It gets the token balance
And subtracts it from the stored mapToken_tokenAmount[_pool] amount which can be that of a completely different token
Anyone can break individual pairs by calling sync(token1, token2) where the token1 balance is less than mapToken_tokenAmount[token2]. This will add the difference to mapToken_tokenAmount[token2] and break the accounting and result in a wrong swap logic.
 [H-13] 4 Synths can be minted with fake base token
The Pools.mintSynth function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call mintSynth(token, token, member).
The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result.
It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased.

[H-14] Missing access restriction on lockUnits/unlockUnits
The Pool.lockUnits allows anyone to steal pool tokens from a member and assign them to msg.sender. Anyone can steal pool tokens from any other user.
Recommend adding access control and require that msg.sender is the router or another authorized party.  [H-22] Users may unintentionally remove liquidity under a phishing attack.
The removeLiquidity function in Pools.sol uses tx.origin to determine the person who wants to remove liquidity. However, such a design is dangerous since the pool assumes that this function is called from the router, which may not be true if the user is under a phishing attack, and he could unintentionally remove liquidity.
 [M-01] User may not get IL protection if certain functions are called directly in Pools.sol
Functions removeLiquidity() and removeLiquidityDirectly() when called directly, do not provide the the user with IL protection unlike when calling the corresponding removeLiquidity() function in Router.sol. This should be prevented, at least for removeLiquidity() or highlighted in the specification and user documentation.  Recommend adding access control (e.g. via a modifier onlyRouter) so removeLiquidity() function of Pools contract can be called only from corresponding Router contract’s removeLiquidity() function which provides IL protection. Alternatively, highlight in the specification and user documentation about which contract interfaces provide IL protection to users.  [M-10] Incorrect operator used in deploySynth() of Pools.sol
The deploySynth() function in Pools.sol is expected to perform a check on the token parameter to determine that it is neither VADER or USDV before calling Factory’s deploySynth() function.
However, the require() incorrectly uses the ‘||’ operator instead of ‘&&’ which allows both VADER and USDV to be supplied as the token parameters. This will allow an attacker to deploy either VADER or USDV as a Synth which will break assumptions throughout the entire protocol. Protocol will break and funds may be lost.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call.  function init()  [M-14] Pool functions can be called before initialization in _init_() of Pools.sol
All the external/public functions of Pools.sol can be called by other contracts even before Pools.solcontract is initialized. This can lead to exceptions, state corruption or incorrect accounting in other contracts, which may require redeployment of said contract.",10.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iFACTORY.sol"";

contract Pools {

  
    bool private inited;
    uint public pooledVADER;
    uint public pooledUSDV;
    
    address public VADER;
    address public USDV;
    address public ROUTER;
    address public FACTORY;

    mapping(address => bool) _isMember;
    mapping(address => bool) _isAsset;
    mapping(address => bool) _isAnchor;

    mapping(address => uint) public mapToken_Units;
    mapping(address => mapping(address => uint)) public mapTokenMember_Units;
    mapping(address => uint) public mapToken_baseAmount;
    mapping(address => uint) public mapToken_tokenAmount;

    
    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);
    event RemoveLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits, uint totalUnits);
    event Swap(address indexed member, address indexed inputToken, uint inputAmount, address indexed outputToken, uint outputAmount, uint swapFee);
    event Sync(address indexed token, address indexed pool, uint addedAmount);
    event SynthSync(address indexed token, uint burntSynth, uint deletedUnits);

    
    
    constructor() {}

    
    function init(address _vader, address _usdv, address _router, address _factory) public {
        require(inited == false);
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
    }

    

    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {
        require(token != USDV && token != VADER); 
        uint _actualInputBase;
        if(base == VADER){
            if(!isAnchor(token)){               
                _isAnchor[token] = true;
            }
            _actualInputBase = getAddedAmount(VADER, token);
        } else if (base == USDV) {
            if(!isAsset(token)){               
                _isAsset[token] = true;
            }
            _actualInputBase = getAddedAmount(USDV, token);
        }
        uint _actualInputToken = getAddedAmount(token, token);
        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);
        mapTokenMember_Units[token][member] += liquidityUnits;  
        mapToken_Units[token] += liquidityUnits;                
        mapToken_baseAmount[token] += _actualInputBase;         
        mapToken_tokenAmount[token] += _actualInputToken;       
        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, tx.origin); 
    }
    function removeLiquidityDirectly(address base, address token, uint basisPoints) external returns (uint outputBase, uint outputToken) {
        return _removeLiquidity(base, token, basisPoints, msg.sender); 
    }
    function _removeLiquidity(address base, address token, uint basisPoints, address member) internal returns (uint outputBase, uint outputToken) {
        require(base == USDV || base == VADER);
        uint _units = iUTILS(UTILS()).calcPart(basisPoints, mapTokenMember_Units[token][member]);
        outputBase = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_baseAmount[token]);
        outputToken = iUTILS(UTILS()).calcShare(_units, mapToken_Units[token], mapToken_tokenAmount[token]);
        mapToken_Units[token] -=_units;
        mapTokenMember_Units[token][member] -= _units;
        mapToken_baseAmount[token] -= outputBase;
        mapToken_tokenAmount[token] -= outputToken;
        emit RemoveLiquidity(member, base, outputBase, token, outputToken, _units, mapToken_Units[token]);
        transferOut(base, outputBase, member);
        transferOut(token, outputToken, member);
        return (outputBase, outputToken);
    }
    
    
    
    
    function swap(address base, address token, address member, bool toBase) external returns (uint outputAmount) {
        if(toBase){
            uint _actualInput = getAddedAmount(token, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_tokenAmount[token], mapToken_baseAmount[token]);
            mapToken_tokenAmount[token] += _actualInput;
            mapToken_baseAmount[token] -= outputAmount;
            emit Swap(member, token, _actualInput, base, outputAmount, _swapFee);
            transferOut(base, outputAmount, member);
        } else {
            uint _actualInput = getAddedAmount(base, token);
            outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            uint _swapFee = iUTILS(UTILS()).calcSwapFee(_actualInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]);
            mapToken_baseAmount[token] += _actualInput;
            mapToken_tokenAmount[token] -= outputAmount;
            emit Swap(member, base, _actualInput, token, outputAmount, _swapFee);
            transferOut(token, outputAmount, member);
        }
    }

    
    function sync(address token, address pool) external {
        uint _actualInput = getAddedAmount(token, pool);
        if (token == VADER || token == USDV){
            mapToken_baseAmount[pool] += _actualInput;
        } else {
            mapToken_tokenAmount[pool] += _actualInput;
        
        
        }
        emit Sync(token, pool, _actualInput);
    }

    

    
    function deploySynth(address token) external {
        require(token != VADER || token != USDV);
        iFACTORY(FACTORY).deploySynth(token);
    }

    
    function mintSynth(address base, address token, address member) external returns (uint outputAmount) {
        require(iFACTORY(FACTORY).isSynth(getSynth(token)), ""!synth"");
        uint _actualInputBase = getAddedAmount(base, token);                    
        uint _synthUnits = iUTILS(UTILS()).calcSynthUnits(_actualInputBase, mapToken_baseAmount[token], mapToken_Units[token]);     
        outputAmount = iUTILS(UTILS()).calcSwapOutput(_actualInputBase, mapToken_baseAmount[token], mapToken_tokenAmount[token]);   
        mapTokenMember_Units[token][address(this)] += _synthUnits;                  
        mapToken_Units[token] += _synthUnits;                                       
        mapToken_baseAmount[token] += _actualInputBase;                             
        emit AddLiquidity(member, base, _actualInputBase, token, 0, _synthUnits);   
        iFACTORY(FACTORY).mintSynth(getSynth(token), member, outputAmount);         
    }
    
    function burnSynth(address base, address token, address member) external returns (uint outputBase) {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               
        mapToken_Units[token] -= _unitsToDelete;                                    
        outputBase = iUTILS(UTILS()).calcSwapOutput(_actualInputSynth, mapToken_tokenAmount[token], mapToken_baseAmount[token]);    
        mapToken_baseAmount[token] -= outputBase;                                   
        emit RemoveLiquidity(member, base, outputBase, token, 0, _unitsToDelete, mapToken_Units[token]);        
        transferOut(base, outputBase, member);                                      
    }
    
    function syncSynth(address token) external {
        uint _actualInputSynth = iERC20(getSynth(token)).balanceOf(address(this));  
        uint _unitsToDelete = iUTILS(UTILS()).calcShare(_actualInputSynth, iERC20(getSynth(token)).totalSupply(), mapTokenMember_Units[token][address(this)]); 
        iERC20(getSynth(token)).burn(_actualInputSynth);                            
        mapTokenMember_Units[token][address(this)] -= _unitsToDelete;               
        mapToken_Units[token] -= _unitsToDelete;                                    
        emit SynthSync(token, _actualInputSynth, _unitsToDelete);
    }

    
    
    
    function lockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][member] -= units;
        mapTokenMember_Units[token][msg.sender] += units;       
    }
    
    function unlockUnits(uint units, address token, address member) external {
        mapTokenMember_Units[token][msg.sender] -= units;      
        mapTokenMember_Units[token][member] += units;
    }

    

    
    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(_token == VADER && _pool != VADER){  
            addedAmount = _balance - pooledVADER;
            pooledVADER = pooledVADER + addedAmount;
        } else if(_token == USDV) {             
            addedAmount = _balance - pooledUSDV;
            pooledUSDV = pooledUSDV + addedAmount;
        } else {                                
            addedAmount = _balance - mapToken_tokenAmount[_pool];
        }
    }
    function transferOut(address _token, uint _amount, address _recipient) internal {
        if(_token == VADER){
            pooledVADER = pooledVADER - _amount; 
        } else if(_token == USDV) {
            pooledUSDV = pooledUSDV - _amount;  
        }
        if(_recipient != address(this)){
            iERC20(_token).transfer(_recipient, _amount);
        }
    }

    function isMember(address member) public view returns(bool) {
        return _isMember[member];
    }
    function isAsset(address token) public view returns(bool) {
        return _isAsset[token];
    }
    function isAnchor(address token) public view returns(bool) {
        return _isAnchor[token];
    }
    function getPoolAmounts(address token) external view returns(uint, uint) {
        return (getBaseAmount(token), getTokenAmount(token));
    }
    function getBaseAmount(address token) public view returns(uint) {
        return mapToken_baseAmount[token];
    }
    function getTokenAmount(address token) public view returns(uint) {
        return mapToken_tokenAmount[token];
    }
    function getUnits(address token) external view returns(uint) {
        return mapToken_Units[token];
    }
    function getMemberUnits(address token, address member) external view returns(uint) {
        return mapTokenMember_Units[token][member];
    }
    function getSynth(address token) public view returns (address) {
        return iFACTORY(FACTORY).getSynth(token);
    }
    function isSynth(address token) public view returns (bool) {
        return iFACTORY(FACTORY).isSynth(token);
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
}",2584.0,6,4,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy Vulnerability**
   - **Location**: `transferOut` function and functions that call it (`removeLiquidity`, `swap`, `burnSynth`, etc.).
   - **Description**: The `transferOut` function transfers tokens to an external address (`_recipient`) before updating the contract's state. If the recipient is a malicious contract, it could re-enter the calling function and exploit the state before it is updated.
   - **Example**: In `removeLiquidity`, the state is updated after `transferOut`, which could allow reentrancy attacks.

---

### 2. **Lack of Access Control**
   - **Location**: `init`, `deploySynth`, `mintSynth`, `burnSynth`, `syncSynth`, `lockUnits`, `unlockUnits`.
   - **Description**: Critical functions like `init`, `deploySynth`, and `mintSynth` do not have access control modifiers. This allows any external address to call these functions, potentially disrupting the contract's logic or draining funds.
   - **Example**: `init` can be called by anyone, allowing an attacker to reset or manipulate the contract's initialization state.

---

### 3. **Integer Overflow/Underflow**
   - **Location**: Arithmetic operations in `addLiquidity`, `removeLiquidity`, `swap`, `sync`, `mintSynth`, `burnSynth`, `syncSynth`, `getAddedAmount`, and `transferOut`.
   - **Description**: The contract uses Solidity 0.8.3, which has built-in overflow/underflow checks. However, if the contract were to be compiled with an older version of Solidity (pre-0.8.0), these vulnerabilities would exist.
   - **Example**: In `getAddedAmount`, subtracting balances could underflow if `pooledVADER` or `pooledUSDV` is greater than the current balance.

---

### 4. **Logical Error in `deploySynth`**
   - **Location**: `deploySynth` function.
   - **Description**: The `require` statement `require(token != VADER || token != USDV)` is logically incorrect. This condition will always evaluate to `true` because a token cannot be both `VADER` and `USDV` simultaneously. The intended condition is likely `require(token != VADER && token != USDV)`.
   - **Impact**: This could allow the deployment of synths for `VADER` or `USDV`, which may not be intended.

---

### 5. **Uninitialized `UTILS` Address**
   - **Location**: `UTILS` function and functions that call it (`addLiquidity`, `removeLiquidity`, `swap`, etc.).
   - **Description**: The `UTILS` function retrieves the `UTILS` address from the `VADER` contract, but there is no guarantee that `VADER` is initialized or that the `UTILS` address is valid. If `VADER` is not set or returns an invalid address, calls to `iUTILS(UTILS())` will fail.
   - **Impact**: This could cause the contract to revert unexpectedly.

---

### 6. **Incorrect State Updates in `sync`**
   - **Location**: `sync` function.
   - **Description**: The `sync` function updates `mapToken_baseAmount` or `mapToken_tokenAmount` based on whether the token is `VADER` or `USDV`. However, the logic does not account for cases where the token is neither, potentially leading to incorrect state updates.
   - **Example**: If `token` is neither `VADER` nor `USDV`, the function will not update `mapToken_tokenAmount[pool]` correctly.

---

### 7. **Lack of Input Validation**
   - **Location**: Multiple functions (`addLiquidity`, `removeLiquidity`, `swap`, `sync`, etc.).
   - **Description**: Many functions do not validate input parameters, such as ensuring that `token` or `base` addresses are valid ERC-20 tokens or that `basisPoints` is within a valid range (e.g., 0–10,000).
   - **Impact**: Invalid inputs could lead to unexpected behavior or loss of funds.

---

### 8. **Potential Front-Running in `swap`**
   - **Location**: `swap` function.
   - **Description**: The `swap` function calculates output amounts based on the current state of the pool, which could be manipulated by front-running attacks. An attacker could observe a pending transaction and execute a swap with a higher gas price to manipulate the pool's state.
   - **Impact**: This could lead to unfair swaps and loss of funds for users.

---

### 9. **Unrestricted `lockUnits` and `unlockUnits`**
   - **Location**: `lockUnits` and `unlockUnits` functions.
   - **Description**: These functions allow any address to lock or unlock units for any member without restrictions. This could be exploited to manipulate liquidity or steal funds.
   - **Impact**: An attacker could lock or unlock units for other users, disrupting the contract's functionality.

---

### 10. **Incorrect Event Emission in `mintSynth`**
   - **Location**: `mintSynth` function.
   - **Description**: The `AddLiquidity` event is emitted with `tokenAmount` set to `0`, which may not accurately reflect the state change. This could mislead off-chain systems monitoring the contract.
   - **Impact**: Off-chain systems relying on event data may misinterpret the contract's state.

---

### 11. **Potential Division by Zero**
   - **Location**: Functions calling `iUTILS(UTILS()).calcShare` or similar calculations (`removeLiquidity`, `burnSynth`, `syncSynth`).
   - **Description**: If `mapToken_Units[token]` or `totalSupply` is zero, division by zero could occur in utility functions like `calcShare`.
   - **Impact**: The contract could revert unexpectedly, disrupting functionality.

---

### 12. **Unhandled Edge Cases in `getAddedAmount`**
   - **Location**: `getAddedAmount` function.
   - **Description**: The function does not handle cases where the token balance decreases (e.g., due to a fee or transfer). This could result in underflow or incorrect `addedAmount` calculations.
   - **Impact**: Incorrect liquidity calculations could lead to loss of funds or contract reverts.

---

### 13. **Lack of Error Handling for External Calls**
   - **Location**: Functions interacting with external contracts (`iERC20`, `iFACTORY`, `iUTILS`).
   - **Description**: The contract does not handle cases where external calls fail (e.g., due to insufficient balance or a revert in the external contract).
   - **Impact**: The contract could revert unexpectedly, leaving the state inconsistent.

---

### 14. **Uninitialized `inited` State**
   - **Location**: `init` function.
   - **Description**: The `inited` state variable is not initialized in the constructor, meaning it defaults to `false`. However, if the contract is deployed without calling `init`, it could remain in an uninitialized state, leading to unexpected behavior.
   - **Impact**: Critical functionality may not work as intended.

---

### 15. **Potential Denial of Service (DoS)**
   - **Location**: Functions that iterate over mappings or perform complex calculations (`addLiquidity`, `removeLiquidity`, `swap`).
   - **Description**: If the contract becomes too large (e.g., too many tokens or members), gas costs could become prohibitively high, leading to potential DoS.
   - **Impact**: Users may be unable to interact with the contract.

---

These vulnerabilities highlight the need for careful auditing and testing before deploying the contract to a production environment.","### **Comparison of Issue Report and Response List**

---

#### **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol**

**Report Description**:  
The `transferOut()` function in `Pools.sol` does not handle the return value of the `transfer` call. Some ERC20 tokens may return `false` on failure instead of reverting. Not checking the return value could allow token transfers to silently fail, especially when dealing with untrusted tokens supplied by users. This oversight may lead to discrepancies in token balances and potential security vulnerabilities if malicious tokens are used.

**Match in Response List**:  
No direct match found. The response list does not explicitly address the issue of unhandled return values in `transfer` calls.

**Validation**:  
**Incorrect**. The response list does not cover this specific issue, which is a critical vulnerability in Solidity smart contracts. The lack of handling for return values from `transfer` calls is a well-known security risk, and it should have been included in the response list.

---

#### **[H-11] Swap token can be traded as fake base token**

**Report Description**:  
The `Pools.swap` function does not check if `base` is one of the base tokens. An attacker can transfer tokens to the pool, set `base=token`, and call `swap(token, token, member, toBase=false)`. This breaks the accounting for the pool, as tokens are transferred in, but the `base` balance is increased (and `token` balance decreased). This can lead to incorrect swap results, liquidity provider (LP) withdrawal issues, and potential token theft.

**Match in Response List**:  
No direct match found. The response list does not address the issue of fake base tokens in the `swap` function.

**Validation**:  
**Incorrect**. The response list misses this critical issue, which could lead to severe accounting errors and potential token theft. The lack of validation for `base` tokens in the `swap` function is a significant oversight.

---

#### **[H-12] getAddedAmount can return wrong results**

**Report Description**:  
The `getAddedAmount` function only works correctly when called with `(VADER/USDV, pool)` or `(pool, pool)`. When called with `(token, pool)` where `token` is neither `VADER` nor `USDV`, it returns incorrect results. This can break individual pairs by calling `sync(token1, token2)` where the `token1` balance is less than `mapToken_tokenAmount[token2]`. This will add the difference to `mapToken_tokenAmount[token2]`, breaking the accounting and resulting in incorrect swap logic.

**Match in Response List**:  
Partially matches with **""Unhandled Edge Cases in `getAddedAmount`""**.

**Validation**:  
**Partially Correct**. The response list identifies edge cases in `getAddedAmount` but does not fully capture the specific issue of incorrect results when `token` is neither `VADER` nor `USDV`. The response could have been more detailed in explaining the impact on accounting and swap logic.

---

#### **[H-13] Synths can be minted with fake base token**

**Report Description**:  
The `Pools.mintSynth` function does not check if `base` is one of the base tokens. An attacker can transfer tokens to the pool, set `base=token`, and call `mintSynth(token, token, member)`. This breaks the accounting for the pool, as tokens are transferred in, but the `base` balance is increased. This can lead to incorrect swap results and potential token theft.

**Match in Response List**:  
No direct match found. The response list does not address the issue of fake base tokens in the `mintSynth` function.

**Validation**:  
**Incorrect**. The response list misses this critical issue, which could lead to severe accounting errors and potential token theft. The lack of validation for `base` tokens in the `mintSynth` function is a significant oversight.

---

#### **[H-14] Missing access restriction on lockUnits/unlockUnits**

**Report Description**:  
The `Pool.lockUnits` function allows anyone to steal pool tokens from a `member` and assign them to `msg.sender`. There is no access control, and anyone can steal pool tokens from any other user. This is a critical vulnerability that could lead to token theft.

**Match in Response List**:  
Matches with **""Unrestricted `lockUnits` and `unlockUnits`""**.

**Validation**:  
**Correct**. The response list accurately identifies the issue with unrestricted access to `lockUnits` and `unlockUnits`. It correctly explains the risks associated with these functions, which aligns with the issue report.

---

#### **[H-22] Users may unintentionally remove liquidity under a phishing attack**

**Report Description**:  
The `removeLiquidity` function in `Pools.sol` uses `tx.origin` to determine the person who wants to remove liquidity. This design is dangerous because the pool assumes that this function is called from the router. If a user is under a phishing attack, they could unintentionally remove liquidity, leading to potential loss of funds.

**Match in Response List**:  
No direct match found. The response list does not address the issue of using `tx.origin` in the `removeLiquidity` function.

**Validation**:  
**Incorrect**. The response list misses this critical issue, which could lead to users unintentionally removing liquidity under a phishing attack. The use of `tx.origin` is a well-known anti-pattern in Solidity, and it should have been included in the response list.

---

#### **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**

**Report Description**:  
Functions `removeLiquidity()` and `removeLiquidityDirectly()` in `Pools.sol` do not provide the user with impermanent loss (IL) protection when called directly, unlike when calling the corresponding `removeLiquidity()` function in `Router.sol`. This should be prevented or highlighted in the specification and user documentation.

**Match in Response List**:  
No direct match found. The response list does not address the issue of missing IL protection in `removeLiquidity()` and `removeLiquidityDirectly()`.

**Validation**:  
**Incorrect**. The response list misses this issue, which could lead to users not receiving IL protection when calling these functions directly. This is a significant oversight in the response list.

---

#### **[M-10] Incorrect operator used in deploySynth() of Pools.sol**

**Report Description**:  
The `deploySynth()` function in `Pools.sol` incorrectly uses the `||` operator instead of `&&` in the `require` statement. This allows both `VADER` and `USDV` to be supplied as the token parameters, which could break assumptions throughout the entire protocol and lead to loss of funds.

**Match in Response List**:  
Matches with **""Logical Error in `deploySynth`""**.

**Validation**:  
**Correct**. The response list accurately identifies the logical error in the `deploySynth` function. It correctly explains the issue with the `||` operator and the potential impact on the protocol.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function in `Pools.sol` can be called by anyone, allowing an attacker to reset or manipulate the contract's initialization state.

**Match in Response List**:  
Matches with **""Lack of Access Control""**.

**Validation**:  
**Correct**. The response list accurately identifies the issue with the `init` function lacking access control. It correctly explains the risks associated with unrestricted access to this function.

---

#### **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

**Report Description**:  
All the external/public functions of `Pools.sol` can be called by other contracts even before `Pools.sol` is initialized. This can lead to exceptions, state corruption, or incorrect accounting in other contracts, which may require redeployment of said contract.

**Match in Response List**:  
Partially matches with **""Uninitialized `inited` State""**.

**Validation**:  
**Partially Correct**. The response list identifies the issue with the `inited` state but does not fully capture the impact of calling functions before initialization. The response could have been more detailed in explaining the potential for state corruption and incorrect accounting.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-14] Missing access restriction on lockUnits/unlockUnits**
- **[M-10] Incorrect operator used in deploySynth() of Pools.sol**
- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- **[H-12] getAddedAmount can return wrong results**
- **[M-14] Pool functions can be called before initialization in _init_() of Pools.sol**

**Missed Issues from Issue Report**:

- **[H-01] Unhandled return value of transfer in transferOut() of Pools.sol**
- **[H-11] Swap token can be traded as fake base token**
- **[H-13] Synths can be minted with fake base token**
- **[H-22] Users may unintentionally remove liquidity under a phishing attack**
- **[M-01] User may not get IL protection if certain functions are called directly in Pools.sol**

---

The response list covers some critical issues but misses several others, particularly those related to unhandled return values, fake base tokens, and phishing attacks. These gaps highlight the need for a more comprehensive review of the smart contract's vulnerabilities.",3,2,5,15,"```
1. Unrestricted `lockUnits` and `unlockUnits`
2. Logical Error in `deploySynth`
3. Lack of Access Control
```",0.6666666666666666
USDV.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";

contract USDV is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    uint public nextEraTime;
    uint public blockDelay;

    address public VADER;
    address public VAULT;
    address public ROUTER;

    mapping(address => uint) public lastBlock;

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool isMatured){
        if(lastBlock[tx.origin] + blockDelay <= block.number){ // Stops an EOA doing a flash attack in same block
            return true;
        }
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER STABLE DOLLAR';
        symbol = 'USDV';
        decimals = 18;
        totalSupply = 0;
    }
    function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(sender != address(0), ""sender"");
            _balances[sender] -= amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
            _checkIncentives();
        }
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(account != address(0), ""recipient"");
            totalSupply += amount;
            _balances[account] += amount;
            emit Transfer(address(0), account, amount);
        }
    }
    // Burn supply
    function burn(uint amount) external virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender)- amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        if(amount > 0){                                     // Due to design, this function may be called with 0
            require(account != address(0), ""address err"");
            _balances[account] -= amount;
            totalSupply -= amount;
            emit Transfer(account, address(0), amount);
        }
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newDelay) external onlyDAO {
        blockDelay = newDelay;
    }

   //======================================INCENTIVES========================================//
    // Internal - Update incentives function
    function _checkIncentives() private {
        if (block.timestamp >= nextEraTime && emitting()) {                 // If new Era
            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _balance = iERC20(VADER).balanceOf(address(this));         // Get spare VADER
            if(_balance > 4){
                uint _USDVShare = _balance/2;                                   // Get 50%
                _convert(address(this), _USDVShare);                            // Convert it
                if(balanceOf(address(this)) > 2){
                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              // Send half USDV to ROUTER
                    _transfer(address(this), VAULT, balanceOf(address(this)));                   // Send rest to VAULT
                }
                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   // Send half VADER to ROUTER
                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      // Send rest to VAULT
            }
        }
    }
    
    //======================================ASSET MINTING========================================//
    // Convert to USDV
    function convert(uint amount) external returns(uint) {
        return convertForMember(msg.sender, amount);
    }
    // Convert for members
    function convertForMember(address member, uint amount) public returns(uint) {
        getFunds(VADER, amount);
        return _convert(member, amount);
    }
    // Internal convert
    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){
        if(minting()){
            lastBlock[tx.origin] = block.number;                    // Record first
            iERC20(VADER).burn(amount);
            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); // Critical pricing functionality
            _mint(_member, _convertAmount);
        }
    }
    // Redeem to VADER
    function redeem(uint amount) external returns(uint) {
        return redeemForMember(msg.sender, amount);
    }
    // Contracts to redeem for members
    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {
        _transfer(msg.sender, VADER, amount);                   // Move funds
        redeemAmount = iVADER(VADER).redeemToMember(member);    // Ask VADER to redeem
        lastBlock[tx.origin] = block.number;                    // Must record block AFTER the tx
    }

    //============================== ASSETS ================================//

    function getFunds(address token, uint amount) internal {
        if(token == address(this)){
            _transfer(msg.sender, address(this), amount);
        } else {
            if(tx.origin==msg.sender){
                require(iERC20(token).transferTo(address(this), amount));
            }else{
                require(iERC20(token).transferFrom(msg.sender, address(this), amount));
            }
        }
    }

    //============================== HELPERS ================================//

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function minting() public view returns(bool){
        return iVADER(VADER).minting();
    }

}",1842.0,219.0,"[H-02] Flash attack mitigation does not work as intended in USDV.sol
One of the stated protocol (review) goals is to detect susceptibility to “Any attack vectors using flash loans on Anchor price, synths or lending.” As such, USDV contract aims to protect against flash attacks using flashProof() modifier which uses the following check in isMature() to determine if currently executing contract context is at least blockDelay duration ahead of the previous context: lastBlock[tx.origin] + blockDelay <= block.number However, blockDelay state variable is not initialized which means it has a default uint value of 0. So unless it is set to >= 1 by setParams() which can be called only by the DAO (which currently does not have the capability to call setParams() function), blockDelay will be 0, which allows current executing context (block.number) to be the same as the previous one (lastBlock[tx.origin]). This effectively allows multiple calls on this contract to be executed in the same transaction of a block which enables flash attacks as opposed to what is expected as commented on L41: ""// Stops an EOA from doing a flash attack in the same block""
  [H-16] Tokens can be stolen through transferTo
VADER, USDV, SYNTHS all employ the `transferTo(`) function, which interrogates for `tx.origin` and skips approvals. The author does not subscribe to the belief that this is dangerous   [M-13] Init function can be called by everyone
Most of the solidity contracts have an `init` function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.",3.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";

contract USDV is iERC20 {

    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;
    
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    bool private inited;
    uint public nextEraTime;
    uint public blockDelay;

    address public VADER;
    address public VAULT;
    address public ROUTER;

    mapping(address => uint) public lastBlock;

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }
    
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool isMatured){
        if(lastBlock[tx.origin] + blockDelay <= block.number){ 
            return true;
        }
    }

    constructor() {
        name = 'VADER STABLE DOLLAR';
        symbol = 'USDV';
        decimals = 18;
        totalSupply = 0;
    }
    function init(address _vader, address _vault, address _router) external {
        require(inited == false);
        inited = true;
        VADER = _vader;
        VAULT = _vault;
        ROUTER = _router;
        nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra();
    }

    
    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    
    
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        if(amount > 0){                                     
            require(sender != address(0), ""sender"");
            _balances[sender] -= amount;
            _balances[recipient] += amount;
            emit Transfer(sender, recipient, amount);
            _checkIncentives();
        }
    }
    
    function _mint(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""recipient"");
            totalSupply += amount;
            _balances[account] += amount;
            emit Transfer(address(0), account, amount);
        }
    }
    
    function burn(uint amount) external virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender)- amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        if(amount > 0){                                     
            require(account != address(0), ""address err"");
            _balances[account] -= amount;
            totalSupply -= amount;
            emit Transfer(account, address(0), amount);
        }
    }

    
    
    function setParams(uint newDelay) external onlyDAO {
        blockDelay = newDelay;
    }

   
    
    function _checkIncentives() private {
        if (block.timestamp >= nextEraTime && emitting()) {                 
            nextEraTime = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _balance = iERC20(VADER).balanceOf(address(this));         
            if(_balance > 4){
                uint _USDVShare = _balance/2;                                   
                _convert(address(this), _USDVShare);                            
                if(balanceOf(address(this)) > 2){
                    _transfer(address(this), ROUTER, balanceOf(address(this)) / 2);              
                    _transfer(address(this), VAULT, balanceOf(address(this)));                   
                }
                iERC20(VADER).transfer(ROUTER, iERC20(VADER).balanceOf(address(this))/2);   
                iERC20(VADER).transfer(VAULT, iERC20(VADER).balanceOf(address(this)));      
            }
        }
    }
    
    
    
    function convert(uint amount) external returns(uint) {
        return convertForMember(msg.sender, amount);
    }
    
    function convertForMember(address member, uint amount) public returns(uint) {
        getFunds(VADER, amount);
        return _convert(member, amount);
    }
    
    function _convert(address _member, uint amount) internal flashProof returns(uint _convertAmount){
        if(minting()){
            lastBlock[tx.origin] = block.number;                    
            iERC20(VADER).burn(amount);
            _convertAmount = iROUTER(ROUTER).getUSDVAmount(amount); 
            _mint(_member, _convertAmount);
        }
    }
    
    function redeem(uint amount) external returns(uint) {
        return redeemForMember(msg.sender, amount);
    }
    
    function redeemForMember(address member, uint amount) public returns(uint redeemAmount) {
        _transfer(msg.sender, VADER, amount);                   
        redeemAmount = iVADER(VADER).redeemToMember(member);    
        lastBlock[tx.origin] = block.number;                    
    }

    

    function getFunds(address token, uint amount) internal {
        if(token == address(this)){
            _transfer(msg.sender, address(this), amount);
        } else {
            if(tx.origin==msg.sender){
                require(iERC20(token).transferTo(address(this), amount));
            }else{
                require(iERC20(token).transferFrom(msg.sender, address(this), amount));
            }
        }
    }

    

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function minting() public view returns(bool){
        return iVADER(VADER).minting();
    }

}",1487.0,2,1,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy Vulnerability**
   - The `_transfer` function updates balances after transferring tokens, which could allow a reentrancy attack if the recipient is a malicious contract. This is particularly risky if external calls are made during the transfer process.
   - The `_checkIncentives` function makes external calls to `iERC20(VADER).transfer` and `iERC20(VADER).transferFrom`, which could be exploited if the `VADER` token contract is malicious or has a callback mechanism.

---

### 2. **Uninitialized State Variables**
   - The `inited` variable is used to ensure the contract is initialized only once, but there is no mechanism to prevent the `init` function from being called by anyone before the contract is properly set up. This could lead to unauthorized initialization.

---

### 3. **Lack of Input Validation**
   - The `init` function does not validate the addresses passed to it (`_vader`, `_vault`, `_router`). If these addresses are invalid or zero, the contract could become unusable or behave unexpectedly.
   - The `setParams` function allows the `blockDelay` to be set to any value without validation, which could lead to unexpected behavior or exploitation.

---

### 4. **Flash Loan Vulnerability**
   - The `flashProof` modifier is intended to prevent flash loan attacks by ensuring that transactions are not executed in the same block. However, the `isMature` function does not properly enforce this check. It only checks if the `lastBlock[tx.origin] + blockDelay <= block.number`, but `tx.origin` can be manipulated, and the check might not be sufficient to prevent flash loan attacks.

---

### 5. **Incorrect Balance Update in `transferFrom`**
   - The `transferFrom` function subtracts the `amount` from the allowance but does not check if the allowance is sufficient before performing the transfer. This could lead to underflow errors or unexpected behavior if the allowance is less than the `amount`.

---

### 6. **Potential Integer Underflow/Overflow**
   - The contract uses Solidity 0.8.3, which has built-in overflow/underflow checks. However, the logic in functions like `burnFrom` and `transferFrom` could still lead to unexpected behavior if the calculations are not carefully handled.

---

### 7. **Lack of Access Control**
   - The `onlyDAO` modifier restricts certain functions to the DAO, but there is no mechanism to ensure that the DAO address is valid or secure. If the DAO address is compromised, an attacker could gain control over critical functions like `setParams`.

---

### 8. **Inconsistent State Updates**
   - The `_checkIncentives` function updates the `nextEraTime` and performs token transfers, but there is no mechanism to ensure that these operations are atomic. If an external call fails, the state could be left inconsistent.

---

### 9. **Unchecked External Calls**
   - The contract makes several external calls (e.g., `iERC20(VADER).transfer`, `iERC20(VADER).transferFrom`, `iVADER(VADER).redeemToMember`) without checking the return values or handling potential failures. This could lead to unexpected behavior if the external calls fail.

---

### 10. **Improper Use of `tx.origin`**
   - The contract uses `tx.origin` in the `transferTo` function and the `isMature` function. This is generally discouraged because `tx.origin` refers to the original sender of the transaction, which could be a malicious contract. This could lead to phishing attacks or other vulnerabilities.

---

### 11. **Lack of Event Emission for Critical Operations**
   - The `setParams` function updates the `blockDelay` but does not emit an event to log this change. This makes it difficult to track changes to critical parameters.

---

### 12. **Potential Division by Zero**
   - The `_checkIncentives` function divides `_balance` by 2 and performs other divisions without checking if the divisor is zero. While this is unlikely to occur in practice, it could lead to runtime errors if the conditions are not properly enforced.

---

### 13. **Inconsistent Token Handling**
   - The `getFunds` function handles transfers differently depending on whether the token is the contract itself or an external token. This inconsistency could lead to unexpected behavior or vulnerabilities if not properly managed.

---

### 14. **Unclear Incentive Mechanism**
   - The `_checkIncentives` function distributes tokens to the `ROUTER` and `VAULT` addresses, but the logic for determining the amounts and conditions is not clearly documented. This could lead to unintended behavior or exploitation if the conditions are not properly enforced.

---

### 15. **Lack of Error Messages**
   - Some `require` statements (e.g., in `_approve` and `_transfer`) use generic error messages like ""sender"" or ""spender,"" which make it difficult to debug issues or understand the cause of failures.

---

### 16. **Potential Front-Running**
   - The `convert` and `redeem` functions update the `lastBlock` mapping, which could be exploited by front-running attacks. An attacker could monitor the blockchain for pending transactions and exploit the timing of these updates.

---

### 17. **Unclear Role of `VAULT` and `ROUTER`**
   - The roles of the `VAULT` and `ROUTER` addresses are not clearly defined in the contract. If these addresses are compromised or misconfigured, it could lead to loss of funds or other vulnerabilities.

---

### 18. **No Mechanism to Pause or Disable Functions**
   - The contract does not include a pause mechanism or emergency stop function. If a vulnerability is discovered, there is no way to temporarily disable the contract to prevent further damage.

---

### 19. **Potential Gas Limit Issues**
   - The `_checkIncentives` function performs multiple external calls and state updates, which could exceed the gas limit for a single transaction. This could lead to failed transactions or inconsistent state updates.

---

### 20. **Lack of Documentation**
   - The contract lacks sufficient comments and documentation, making it difficult to understand the intended behavior and potential risks. This increases the likelihood of errors or vulnerabilities being introduced during development or maintenance.","### **[H-02] Flash attack mitigation does not work as intended in USDV.sol**

**Report Description**:
The `flashProof()` modifier in `USDV.sol` is intended to prevent flash attacks by ensuring that transactions are not executed in the same block. However, the `blockDelay` state variable is uninitialized, defaulting to 0. This means that unless `setParams()` is called by the DAO (which currently cannot do so), `blockDelay` remains 0, allowing multiple calls to be executed in the same block. This effectively enables flash attacks, contrary to the intended protection.

**Match in Response List**:
Matches with the issue titled **""Flash Loan Vulnerability""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the `flashProof` modifier and the uninitialized `blockDelay` state variable. It correctly explains the risks associated with the lack of proper initialization and enforcement of the block delay, which aligns with the reported issue.

---

### **[H-16] Tokens can be stolen through transferTo**

**Report Description**:
The `transferTo()` function in `VADER`, `USDV`, and `SYNTHS` contracts uses `tx.origin` and skips approvals, which is considered dangerous. This design choice could allow tokens to be stolen if `tx.origin` is manipulated by a malicious contract.

**Match in Response List**:
Matches with the issue titled **""Improper Use of `tx.origin`""**.

**Validation**:
**Correct**. The response correctly identifies the issue with the use of `tx.origin` in the `transferTo` function. It explains the risks associated with using `tx.origin`, which aligns with the reported issue.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function in most Solidity contracts can be called by anyone, leading to a race condition upon deployment. A hacker could call the `init` function immediately after deployment, rendering the contracts useless and requiring redeployment, which would incur significant gas costs.

**Match in Response List**:
Matches with the issue titled **""Uninitialized State Variables""**.

**Validation**:
**Partially Correct**. The response identifies the issue with the `init` function being callable by anyone but does not fully address the race condition and the potential for rendering the contracts useless. It focuses more on the lack of initialization rather than the broader security implications of unauthorized `init` calls.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-02] Flash attack mitigation does not work as intended in USDV.sol**
- **[H-16] Tokens can be stolen through transferTo**

**Partially Correct Matches**:

- **[M-13] Init function can be called by everyone**

**Missed Issues from Issue Report**:

- *None*

---

### **Overall Assessment**

The `response_list` provides a comprehensive analysis of the vulnerabilities in the smart contract, accurately identifying and addressing most of the issues reported in the `issue` list. However, the response to the `init` function issue could be more detailed, particularly in addressing the race condition and the broader security implications of unauthorized initialization. Overall, the responses are well-aligned with Solidity best practices and security standards.",2,1,0,20,"```
1. Flash Loan Vulnerability
2. Improper Use of `tx.origin`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - **Flash Loan Vulnerability** appears at rank **4**.
   - **Improper Use of `tx.origin`** appears at rank **10**.

2. **Calculate the precision at each rank**:
   - For **Flash Loan Vulnerability** at rank 4:
     \[
     P@4 = \frac{\text{Number of true positives up to rank 4}}{\text{Rank}} = \frac{1}{4} = 0.25
     \]
   - For **Improper Use of `tx.origin`** at rank 10:
     \[
     P@10 = \frac{\text{Number of true positives up to rank 10}}{\text{Rank}} = \frac{2}{10} = 0.2
     \]

3. **Average the precision values**:
   \[
   AP = \frac{P@4 + P@10}{2} = \frac{0.25 + 0.2}{2} = 0.225
   \]

**Output**:
\[
\boxed{0.225}
\]"
Vader.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iUSDV.sol"";
import ""./interfaces/iROUTER.sol"";

contract Vader is iERC20 {

    // ERC-20 Parameters
    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    // Parameters
    bool private inited;
    bool public emitting;
    bool public minting;
    uint _1m;
    uint public baseline;
    uint public emissionCurve;
    uint public maxSupply;
    uint public secondsPerEra;
    uint public currentEra;
    uint public nextEraTime;
    uint public feeOnTransfer;

    address public VETHER;
    address public USDV;
    address public UTILS;
    address public burnAddress;
    address public rewardAddress;
    address public DAO;

    event NewEra(uint currentEra, uint nextEraTime, uint emission);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO, ""Not DAO"");
        _;
    }
    // Stop flash attacks
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool){
        return iUSDV(USDV).isMature();
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {
        name = 'VADER PROTOCOL TOKEN';
        symbol = 'VADER';
        decimals = 18;
        _1m = 10**6 * 10 ** decimals; //1m
        baseline = _1m;
        totalSupply = 0;
        maxSupply = 2 * _1m;
        currentEra = 1;
        secondsPerEra = 1; //86400;
        nextEraTime = block.timestamp + secondsPerEra;
        emissionCurve = 900;
        DAO = msg.sender;
        burnAddress = 0x0111011001100001011011000111010101100101;
    }
    // Can only be called once
    function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }

    //========================================iERC20=========================================//
    function balanceOf(address account) external view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    // TransferTo function
    // Risks: User can be phished, or tx.origin may be deprecated, optionality should exist in the system. 
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    // Internal transfer function
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        require(sender != address(0), ""sender"");
        require(recipient != address(this), ""recipient"");
        _balances[sender] -= amount;
        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  // Critical functionality
        if(_fee >= 0 && _fee <= amount){                            // Stops reverts if UTILS corrupted
            amount -= _fee;
            _burn(msg.sender, _fee);
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _checkEmission();
    }
    // Internal mint (upgrading and daily emissions)
    function _mint(address account, uint amount) internal virtual {
        require(account != address(0), ""recipient"");
        if((totalSupply + amount) >= maxSupply){
            amount = maxSupply - totalSupply;       // Safety, can't mint above maxSupply
        }
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    // Burn supply
    function burn(uint amount) public virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        require(account != address(0), ""address err"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    //=========================================DAO=========================================//
    // Can start
    function flipEmissions() external onlyDAO {
        if(emitting){
            emitting = false;
        } else {
            emitting = true;
        }
    }
    // Can stop
    function flipMinting() external onlyDAO {
        if(minting){
            minting = false;
        } else {
            minting = true;
        }
    }
    // Can set params
    function setParams(uint newEra, uint newCurve) external onlyDAO {
        secondsPerEra = newEra;
        emissionCurve = newCurve;
    }
    // Can set reward address
    function setRewardAddress(address newAddress) external onlyDAO {
        rewardAddress = newAddress;
    }
    // Can change UTILS
    function changeUTILS(address newUTILS) external onlyDAO {
        require(newUTILS != address(0), ""address err"");
        UTILS = newUTILS;
    }
    // Can change DAO
    function changeDAO(address newDAO) external onlyDAO {
        require(newDAO != address(0), ""address err"");
        DAO = newDAO;
    }
    // Can purge DAO
    function purgeDAO() external onlyDAO{
        DAO = address(0);
    }

   //======================================EMISSION========================================//
    // Internal - Update emission function
    function _checkEmission() private {
        if ((block.timestamp >= nextEraTime) && emitting) {                                // If new Era and allowed to emit
            currentEra += 1;                                                               // Increment Era
            nextEraTime = block.timestamp + secondsPerEra;                                 // Set next Era time
            uint _emission = getDailyEmission();                                           // Get Daily Dmission
            _mint(rewardAddress, _emission);                                               // Mint to the Rewad Address
            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        // UpdateFeeOnTransfer
            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                // Max 10% if UTILS corrupted
            emit NewEra(currentEra, nextEraTime, _emission);                               // Emit Event
        }
    }
    // Calculate Daily Emission
    function getDailyEmission() public view returns (uint) {
        uint _adjustedMax;
        if(totalSupply <= baseline){ // If less than 1m, then adjust cap down
            _adjustedMax = (maxSupply * totalSupply) / baseline; // 2m * 0.5m / 1m = 2m * 50% = 1.5m
        } else {
            _adjustedMax = maxSupply;  // 2m
        }
        return (_adjustedMax - totalSupply) / (emissionCurve); // outstanding / curve 
    }

    //======================================ASSET MINTING========================================//
    // VETHER Owners to Upgrade
    function upgrade(uint amount) external {
        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));
        _mint(msg.sender, amount);
    }
    // Directly redeem back to VADER (must have sent USDV first)
    function redeem() external returns (uint redeemAmount){
        return redeemToMember(msg.sender);
    }
    // Redeem on behalf of member (must have sent USDV first)
    function redeemToMember(address member) public flashProof returns (uint redeemAmount){
        if(minting){
            uint _amount = iERC20(USDV).balanceOf(address(this)); 
            iERC20(USDV).burn(_amount);
            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); // Critical pricing functionality
            _mint(member, redeemAmount);
        }
    }
}",2091.0,245.0,"[H-03] Missing DAO functionality to call changeDAO() function in Vader.sol
`changeDAO()` is authorized to be called only from the DAO (per modifier) but DAO contract has no corresponding functionality to call `changeDAO()` function. As a result, DAO address cannot be changed (L192-L196).
  [H-06] Incorrect burn address in Vader.sol
The `internal _transfer()` function is called from external facing `transfer()`, `transferFrom()`, and transferTo() functions all of which have different sender addresses. It is msg.sender for transfer(), sender parameter for transferFrom() and tx.origin for transferTo().
These different senders are reflected in the sender parameter of _transfer() function. While this sender parameter is correctly used for transfer of tokens within _transfer, the call to _burn() on L129 incorrectly uses msg.sender as the burn address which is correct only in the case of the transfer() caller's context. This is incorrect for transferFrom() and transferTo() caller contexts.
This will incorrectly burn the fees from a different (intermediate contract) account for all users of the protocol interacting with the transferTo() and transferFrom() functions and lead to incorrect accounting of token balances or exceptional conditions. Protocol will break and lead to fund loss.
  [H-16] Tokens can be stolen through transferTo
VADER, USDV, SYNTHS all employ the transferTo() function, which interrogates for tx.origin and skips approvals. The author does not subscribe to the belief that this is dangerous   [H-17] Transfer fee is burned on wrong accounts
The Vader._transfer function burns the transfer fee on msg.sender but this address might not be involved in the transfer at all due to transferFrom.
Smart contracts that simply relay transfers like aggregators have their Vader balance burned or the transaction fails because these accounts don't have any balance to burn, breaking the functionality.

 [H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol
Incorrect initialization (perhaps testing parameterization mistakenly carried over to deployment) of secondsPerEra to 1 sec instead of 86400 secs (1 day) causes what should be the daily emission rate to be a secondly emission rate.
This causes inflation of VADER token and likely breaks VADER<>USDV peg and other protocol invariants. Protocol will break and funds will be lost.
  [M-04] flashProof is not flash-proof
The flashProof modifier is supposed to prevent flash-loan attacks by disallowing performing several sensitive functions in the same block.
However, it performs this check on tx.origin and not on an individual user address basis. This only prevents flash loan attacks from happening within a single transaction.
  [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the `init` function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()   [M-15] changeDAO should be a two-step process in Vader.sol
`changeDAO()` updates DAO address in one-step. If an incorrect address is mistakenly used (and voted upon) then future administrative access or recovering from this mistake is prevented because onlyDAO modifier is used for changeDAO(), which requires msg.sender to be the incorrectly used DAO address (for which private keys may not be available to sign transactions). See finding #6 from Trail of Bits audit of Hermez Network.   [M-17] Vader.redeemToMember() vulnerable to front running
The USDV balance of the Vader contract is vulnerable to theft through the Vader.redeemToMember() function. A particular case is through USDV redemption front-running. Users can redeem USDV for Vader through the USDV.redeemForMember() function or the Vader.redeemToMember() function.",9.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iUSDV.sol"";
import ""./interfaces/iROUTER.sol"";

contract Vader is iERC20 {

    string public override name; string public override symbol;
    uint public override decimals; uint public override totalSupply;

    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;

    
    bool private inited;
    bool public emitting;
    bool public minting;
    uint _1m;
    uint public baseline;
    uint public emissionCurve;
    uint public maxSupply;
    uint public secondsPerEra;
    uint public currentEra;
    uint public nextEraTime;
    uint public feeOnTransfer;

    address public VETHER;
    address public USDV;
    address public UTILS;
    address public burnAddress;
    address public rewardAddress;
    address public DAO;

    event NewEra(uint currentEra, uint nextEraTime, uint emission);

    
    modifier onlyDAO() {
        require(msg.sender == DAO, ""Not DAO"");
        _;
    }
    
    modifier flashProof() {
        require(isMature(), ""No flash"");
        _;
    }
    function isMature() public view returns(bool){
        return iUSDV(USDV).isMature();
    }

    
    
    constructor() {
        name = 'VADER PROTOCOL TOKEN';
        symbol = 'VADER';
        decimals = 18;
        _1m = 10**6 * 10 ** decimals; 
        baseline = _1m;
        totalSupply = 0;
        maxSupply = 2 * _1m;
        currentEra = 1;
        secondsPerEra = 1; 
        nextEraTime = block.timestamp + secondsPerEra;
        emissionCurve = 900;
        DAO = msg.sender;
        burnAddress = 0x0111011001100001011011000111010101100101;
    }
    
    function init(address _vether, address _USDV, address _utils) external {
        require(inited == false);
        inited = true;
        VETHER = _vether;
        USDV = _USDV;
        UTILS = _utils;
        rewardAddress = _USDV;
    }

    
    function balanceOf(address account) external view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) external virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""sender"");
        require(spender != address(0), ""spender"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) external virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

    
    
    function transferTo(address recipient, uint amount) external virtual override returns (bool) {
        _transfer(tx.origin, recipient, amount);
        return true;
    }

    
    function _transfer(address sender, address recipient, uint amount) internal virtual {
        require(sender != address(0), ""sender"");
        require(recipient != address(this), ""recipient"");
        _balances[sender] -= amount;
        uint _fee = iUTILS(UTILS).calcPart(feeOnTransfer, amount);  
        if(_fee >= 0 && _fee <= amount){                            
            amount -= _fee;
            _burn(msg.sender, _fee);
        }
        _balances[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        _checkEmission();
    }
    
    function _mint(address account, uint amount) internal virtual {
        require(account != address(0), ""recipient"");
        if((totalSupply + amount) >= maxSupply){
            amount = maxSupply - totalSupply;       
        }
        totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    
    function burn(uint amount) public virtual override {
        _burn(msg.sender, amount);
    }
    function burnFrom(address account, uint amount) external virtual override {
        uint decreasedAllowance = allowance(account, msg.sender) - amount;
        _approve(account, msg.sender, decreasedAllowance);
        _burn(account, amount);
    }
    function _burn(address account, uint amount) internal virtual {
        require(account != address(0), ""address err"");
        _balances[account] -= amount;
        totalSupply -= amount;
        emit Transfer(account, address(0), amount);
    }

    
    
    function flipEmissions() external onlyDAO {
        if(emitting){
            emitting = false;
        } else {
            emitting = true;
        }
    }
    
    function flipMinting() external onlyDAO {
        if(minting){
            minting = false;
        } else {
            minting = true;
        }
    }
    
    function setParams(uint newEra, uint newCurve) external onlyDAO {
        secondsPerEra = newEra;
        emissionCurve = newCurve;
    }
    
    function setRewardAddress(address newAddress) external onlyDAO {
        rewardAddress = newAddress;
    }
    
    function changeUTILS(address newUTILS) external onlyDAO {
        require(newUTILS != address(0), ""address err"");
        UTILS = newUTILS;
    }
    
    function changeDAO(address newDAO) external onlyDAO {
        require(newDAO != address(0), ""address err"");
        DAO = newDAO;
    }
    
    function purgeDAO() external onlyDAO{
        DAO = address(0);
    }

   
    
    function _checkEmission() private {
        if ((block.timestamp >= nextEraTime) && emitting) {                                
            currentEra += 1;                                                               
            nextEraTime = block.timestamp + secondsPerEra;                                 
            uint _emission = getDailyEmission();                                           
            _mint(rewardAddress, _emission);                                               
            feeOnTransfer = iUTILS(UTILS).getFeeOnTransfer(totalSupply, maxSupply);        
            if(feeOnTransfer > 1000){feeOnTransfer = 1000;}                                
            emit NewEra(currentEra, nextEraTime, _emission);                               
        }
    }
    
    function getDailyEmission() public view returns (uint) {
        uint _adjustedMax;
        if(totalSupply <= baseline){ 
            _adjustedMax = (maxSupply * totalSupply) / baseline; 
        } else {
            _adjustedMax = maxSupply;  
        }
        return (_adjustedMax - totalSupply) / (emissionCurve); 
    }

    
    
    function upgrade(uint amount) external {
        require(iERC20(VETHER).transferFrom(msg.sender, burnAddress, amount));
        _mint(msg.sender, amount);
    }
    
    function redeem() external returns (uint redeemAmount){
        return redeemToMember(msg.sender);
    }
    
    function redeemToMember(address member) public flashProof returns (uint redeemAmount){
        if(minting){
            uint _amount = iERC20(USDV).balanceOf(address(this)); 
            iERC20(USDV).burn(_amount);
            redeemAmount = iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount(_amount); 
            _mint(member, redeemAmount);
        }
    }
}",1699.0,5,4,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Reentrancy Vulnerability**
   - **Location**: `_transfer` function and `redeemToMember` function.
   - **Description**: The contract does not use the Checks-Effects-Interactions pattern consistently. For example:
     - In `_transfer`, the external call to `iUTILS(UTILS).calcPart` is made before state changes are finalized.
     - In `redeemToMember`, the external call to `iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount` is made before state changes.
   - **Impact**: A malicious contract could potentially re-enter the function and manipulate the state.

---

### 2. **Lack of Input Validation**
   - **Location**: Multiple functions, including `init`, `setParams`, `setRewardAddress`, `changeUTILS`, and `changeDAO`.
   - **Description**: The contract does not validate inputs adequately. For example:
     - In `init`, the `_vether`, `_USDV`, and `_utils` addresses are not checked for zero addresses.
     - In `setParams`, the `newEra` and `newCurve` values are not validated for reasonable ranges.
   - **Impact**: Invalid inputs could lead to unexpected behavior or vulnerabilities.

---

### 3. **Integer Overflow/Underflow**
   - **Location**: Arithmetic operations in functions like `_transfer`, `_mint`, `_burn`, and `transferFrom`.
   - **Description**: Although Solidity 0.8.x has built-in overflow/underflow checks, the contract does not handle cases where arithmetic operations might revert due to these checks.
   - **Impact**: Transactions could fail unexpectedly, leading to potential denial-of-service (DoS) scenarios.

---

### 4. **Centralization Risks**
   - **Location**: Functions with the `onlyDAO` modifier, such as `flipEmissions`, `flipMinting`, `setParams`, `setRewardAddress`, `changeUTILS`, `changeDAO`, and `purgeDAO`.
   - **Description**: The contract relies heavily on the `DAO` address for critical operations. If the `DAO` address is compromised or acts maliciously, it could manipulate the contract's behavior.
   - **Impact**: Centralization risks could lead to loss of funds or control over the contract.

---

### 5. **Lack of Event Emission for Critical State Changes**
   - **Location**: Functions like `changeUTILS`, `changeDAO`, `setRewardAddress`, and `purgeDAO`.
   - **Description**: The contract does not emit events for critical state changes, making it difficult to track changes off-chain.
   - **Impact**: Lack of transparency and auditability.

---

### 6. **Potential Front-Running in `upgrade` and `redeemToMember`**
   - **Location**: `upgrade` and `redeemToMember` functions.
   - **Description**: These functions involve transferring tokens and minting new tokens. A malicious actor could front-run these transactions to manipulate the outcome.
   - **Impact**: Loss of funds or unfair advantage to attackers.

---

### 7. **Uninitialized `feeOnTransfer`**
   - **Location**: `_transfer` function.
   - **Description**: The `feeOnTransfer` variable is used in `_transfer` but is not initialized in the constructor or `init` function. Its initial value is 0, which might not be the intended behavior.
   - **Impact**: Incorrect fee calculations could lead to unexpected behavior.

---

### 8. **Hardcoded Addresses**
   - **Location**: `burnAddress` in the constructor.
   - **Description**: The `burnAddress` is hardcoded to `0x0111011001100001011011000111010101100101`, which is unconventional and could lead to errors.
   - **Impact**: If the address is invalid or inaccessible, burning tokens could fail.

---

### 9. **Inconsistent Use of `flashProof` Modifier**
   - **Location**: `redeemToMember` function.
   - **Description**: The `flashProof` modifier is used to prevent flash loans, but its implementation relies on an external contract (`iUSDV(USDV).isMature()`). If the external contract is compromised or behaves unexpectedly, the modifier might not work as intended.
   - **Impact**: Flash loan attacks could still occur.

---

### 10. **Unbounded Loops in Emission Calculation**
   - **Location**: `_checkEmission` and `getDailyEmission` functions.
   - **Description**: The emission calculation involves division and subtraction, which could lead to unexpected results if the `emissionCurve` or `totalSupply` values are not properly managed.
   - **Impact**: Incorrect emission calculations could lead to inflation or deflation of the token supply.

---

### 11. **Lack of Error Messages in `require` Statements**
   - **Location**: Multiple `require` statements, such as in `_approve`, `_transfer`, and `_burn`.
   - **Description**: Some `require` statements do not provide informative error messages, making it difficult to debug issues.
   - **Impact**: Poor user experience and difficulty in diagnosing failures.

---

### 12. **Potential DoS in `_mint` Function**
   - **Location**: `_mint` function.
   - **Description**: If the `maxSupply` is reached, the function will mint only the remaining amount. However, this could lead to partial mints and unexpected behavior.
   - **Impact**: Users might not receive the expected amount of tokens.

---

### 13. **Unused Variables**
   - **Location**: `_1m`, `baseline`, and `rewardAddress`.
   - **Description**: Some variables, such as `_1m` and `baseline`, are defined but not used in the contract logic. The `rewardAddress` is set but not utilized in all relevant functions.
   - **Impact**: Unnecessary complexity and potential confusion.

---

### 14. **Lack of Fallback or Receive Function**
   - **Location**: Contract level.
   - **Description**: The contract does not have a `fallback` or `receive` function, which means it cannot accept Ether directly.
   - **Impact**: Users might accidentally send Ether to the contract, resulting in lost funds.

---

### 15. **Potential Division by Zero**
   - **Location**: `getDailyEmission` function.
   - **Description**: If `emissionCurve` is set to 0, the division operation in `getDailyEmission` will revert.
   - **Impact**: The contract could become unusable if `emissionCurve` is improperly set.

---

### 16. **Unchecked External Calls**
   - **Location**: `upgrade` and `redeemToMember` functions.
   - **Description**: The contract makes external calls to other contracts (e.g., `iERC20(VETHER).transferFrom`, `iERC20(USDV).burn`, `iROUTER(iUSDV(USDV).ROUTER()).getVADERAmount`) without checking the return values or handling potential failures.
   - **Impact**: External calls could fail silently, leading to unexpected behavior.

---

### 17. **Inconsistent Naming Conventions**
   - **Location**: Variable and function names.
   - **Description**: Some variables and functions do not follow consistent naming conventions (e.g., `_1m`, `_checkEmission`, `flashProof`).
   - **Impact**: Reduced readability and maintainability of the code.

---

### 18. **Uninitialized `inited` Variable**
   - **Location**: `init` function.
   - **Description**: The `inited` variable is used to prevent re-initialization, but it is not explicitly initialized in the constructor.
   - **Impact**: The contract might behave unexpectedly if `init` is called before `inited` is set.","### **[H-03] Missing DAO functionality to call changeDAO() function in Vader.sol**

**Report Description**:  
The `changeDAO()` function in `Vader.sol` is authorized to be called only from the DAO (via the `onlyDAO` modifier). However, the DAO contract lacks the corresponding functionality to call `changeDAO()`. As a result, the DAO address cannot be changed, rendering the function effectively unusable (L192-L196).

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of missing DAO functionality to call `changeDAO()`. This is a critical oversight, as it prevents the DAO from updating its own address, which could lead to governance issues.

---

### **[H-06] Incorrect burn address in Vader.sol**

**Report Description**:  
The `_transfer()` function in `Vader.sol` is called from external-facing functions (`transfer()`, `transferFrom()`, and `transferTo()`), each with different sender addresses. While the sender parameter is correctly used for token transfers, the call to `_burn()` on L129 incorrectly uses `msg.sender` as the burn address. This is only correct for `transfer()` but incorrect for `transferFrom()` and `transferTo()`. This misalignment can lead to incorrect accounting of token balances, protocol breakdown, and potential fund loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect burn address usage in `_transfer()`. This is a critical vulnerability that could lead to incorrect token accounting and fund loss.

---

### **[H-16] Tokens can be stolen through transferTo**

**Report Description**:  
The `transferTo()` function in VADER, USDV, and SYNTHS contracts interrogates `tx.origin` and skips approvals. This design is inherently dangerous, as it allows tokens to be stolen by malicious actors who can manipulate `tx.origin`.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of token theft through `transferTo()`. This is a high-risk vulnerability that could lead to significant fund loss.

---

### **[H-17] Transfer fee is burned on wrong accounts**

**Report Description**:  
The `Vader._transfer` function burns the transfer fee on `msg.sender`, which might not be involved in the transfer due to `transferFrom()`. This can result in burning fees from intermediate contract accounts, leading to incorrect accounting or transaction failures, especially for smart contracts that relay transfers.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of burning fees on incorrect accounts. This could lead to protocol breakdown and fund loss.

---

### **[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol**

**Report Description**:  
The `secondsPerEra` variable in `Vader.sol` is incorrectly initialized to 1 second instead of 86400 seconds (1 day). This causes the daily emission rate to become a secondly emission rate, leading to VADER token inflation, breaking the VADER<>USDV peg, and potentially causing fund loss.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect initialization of `secondsPerEra`. This is a critical vulnerability that could lead to protocol breakdown and fund loss.

---

### **[M-04] flashProof is not flash-proof**

**Report Description**:  
The `flashProof` modifier is intended to prevent flash-loan attacks by disallowing sensitive functions from being executed in the same block. However, it checks `tx.origin` instead of individual user addresses, which only prevents attacks within a single transaction, not across multiple transactions.

**Match in Response List**:  
**Partially Correct**. Matches with the issue titled **""Inconsistent Use of `flashProof` Modifier""**.

**Validation**:  
**Partially Correct**. The response identifies the issue with the `flashProof` modifier but does not fully explain the risk of checking `tx.origin` instead of individual user addresses. This leaves the contract vulnerable to flash-loan attacks across multiple transactions.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function in most Solidity contracts can be called by anyone, leading to a race condition during deployment. A hacker could call the `init` function and render the deployed contracts useless, requiring redeployment and incurring significant gas costs.

**Match in Response List**:  
**Correct**. Matches with the issue titled **""Lack of Input Validation""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `init` function, highlighting the lack of access control and the potential for race conditions. This aligns with Solidity best practices for secure contract initialization.

---

### **[M-15] changeDAO should be a two-step process in Vader.sol**

**Report Description**:  
The `changeDAO()` function updates the DAO address in a single step. If an incorrect address is mistakenly used (and voted upon), future administrative access or recovery is prevented because the `onlyDAO` modifier requires `msg.sender` to be the incorrect DAO address. This could lead to permanent loss of control over the contract.

**Match in Response List**:  
**No match found**.

**Validation**:  
**Incorrect**. The response list does not address the issue of `changeDAO()` being a single-step process. This is a critical governance vulnerability that could lead to permanent loss of control over the contract.

---

### **[M-17] Vader.redeemToMember() vulnerable to front running**

**Report Description**:  
The `Vader.redeemToMember()` function is vulnerable to front-running, particularly during USDV redemption. Malicious actors can front-run transactions to manipulate the outcome, leading to potential fund loss.

**Match in Response List**:  
**Correct**. Matches with the issue titled **""Potential Front-Running in `upgrade` and `redeemToMember`""**.

**Validation**:  
**Correct**. The response accurately identifies the front-running vulnerability in `redeemToMember()`, highlighting the risk of fund loss. This aligns with Solidity best practices for secure contract design.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone**
- **[M-17] Vader.redeemToMember() vulnerable to front running**

**Partially Correct Matches**:

- **[M-04] flashProof is not flash-proof**

**Missed Issues from Issue Report**:

- **[H-03] Missing DAO functionality to call changeDAO() function in Vader.sol**
- **[H-06] Incorrect burn address in Vader.sol**
- **[H-16] Tokens can be stolen through transferTo**
- **[H-17] Transfer fee is burned on wrong accounts**
- **[H-25] Incorrect initialization causes VADER emission rate of 1 second instead of 1 day in Vader.sol**
- **[M-15] changeDAO should be a two-step process in Vader.sol**

---",2,1,6,18,"```
1. Lack of Input Validation
2. Potential Front-Running in `upgrade` and `redeemToMember`
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Lack of Input Validation"" appears at rank 2.
   - ""Potential Front-Running in `upgrade` and `redeemToMember`"" appears at rank 6.

2. **Calculate the precision at each rank**:
   - For rank 2: \( P@2 = \frac{1}{2} = 0.5 \)
   - For rank 6: \( P@6 = \frac{2}{6} \approx 0.333 \)

3. **Average the precision values**:
   - \( AP = \frac{0.5 + 0.333}{2} = \frac{0.833}{2} \approx 0.4165 \)

**Average Precision (AP)**: 0.4165"
DAO.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   // Amount of seconds per era (Inherited from BASE contract; intended to be ~1 day)
    uint256 public coolOffPeriod;   // Amount of time a proposal will need to be in finalising stage before it can be finalised
    uint256 public proposalCount;   // Count of proposals
    uint256 public majorityFactor;  // Number used to calculate majority; intended to be 6666bp === 2/3
    uint256 public erasToEarn;      // Amount of eras that make up the targeted RESERVE depletion; regulates incentives
    uint256 public daoClaim;        // The DAOVault's portion of rewards; intended to be ~10% initially
    uint256 public daoFee;          // The SPARTA fee for a user to create a new proposal, intended to be 100 SPARTA initially
    uint256 public currentProposal; // The most recent proposal; should be === proposalCount
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; // Only used in UI; is intended to be a historical array of all past Bond listed assets
    uint256 public bondingPeriodSeconds = 15552000; // Vesting period for bonders (6 months)
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; // Used internally to get CURRENT listed Bond assets
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    // Restrict access
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    //==================================== PROTOCOL CONTRACTs SETTER =================================//

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    // Can purge deployer once DAO is stable and final
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    // Can change vesting period for bonders
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    //============================== USER - DEPOSIT/WITHDRAW ================================//

    // User deposits LP tokens in the DAOVault
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    // Contract deposits LP tokens for member
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); // Pool must be Curated
        require(amount > 0, ""!amount""); // Deposit amount must be valid
        if (isMember[member] != true) {
            arrayMembers.push(member); // If not a member; add user to member array
            isMember[member] = true; // If not a member; register the user as member
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); // Send user's deposit to the DAOVault
        _DAOVAULT.depositLP(pool, amount, member); // Update user's deposit balance & weight
        mapMember_lastTime[member] = block.timestamp; // Reset user's last harvest time
        emit MemberDeposits(member, pool, amount);
    }
    
    // User withdraws all of their selected asset from the DAOVault
    function withdraw(address pool) external {
        removeVote(); // Users weight is removed from the current open DAO proposal
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); // User receives their withdrawal
    }

    //============================== REWARDS ================================//
    
    // User claims their DAOVault incentives
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); // Reserve must have emissions turned on
        uint reward = calcCurrentReward(msg.sender); // Calculate the user's claimable incentive
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); // Get total BASE balance of RESERVE
        uint daoReward = (reserve * daoClaim) / 10000; // Get DAO's share of BASE balance of RESERVE (max user claim amount)
        if(reward > daoReward){
            reward = daoReward; // User cannot claim more than the daoReward limit
        }
        _RESERVE.grantFunds(reward, msg.sender); // Send the claim to the user
    }

    // Calculate the user's current incentive-claim per era
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; // Get seconds passed since last claim
        uint share = calcReward(member); // Get share of rewards for user
        uint reward = (share * secondsSinceClaim) / secondsPerEra; // User's share times eras since they last claimed
        return reward;
    }

    // Calculate the user's current total claimable incentive
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); // Get combined total weights (scope: user)
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total weights (scope: vaults)
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; // Aim to deplete reserve over a number of days
        uint daoReward = (reserve * daoClaim) / 10000; // Get the DAO's share of that
        return _UTILS.calcShare(weight, _totalWeight, daoReward); // Get users's share of that (1 era worth)
    }

    //================================ BOND Feature ==================================//

    // Can burn the SPARTA remaining in this contract (Bond allocations held in the DAO)
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    // Can transfer the SPARTA remaining in this contract to a new DAO (If DAO is upgraded)
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    // List an asset to be enabled for Bonding
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; // Register as a currently enabled asset
            listedBondAssets.push(asset); // Add to historical record of past Bond assets
        }
        emit ListedAsset(msg.sender, asset);
    }

    // Delist an asset from the Bond program
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; // Unregister as a currently enabled asset
        emit DelistedAsset(msg.sender, asset);
    }

    // User deposits assets to be Bonded
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); // Amount must be valid
        require(isListed[asset], '!listed'); // Asset must be listed for Bond
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); // If user is not a member; add them to the member array
            isMember[msg.sender] = true; // Register user as a member
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); // If member has existing weight; force harvest to block manipulation of lastTime + harvest
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); // Add liquidity and calculate LP units
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); // Deposit the Bonded LP units in the BondVault
        mapMember_lastTime[msg.sender] = block.timestamp; // Reset user's last harvest time
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    // Add Bonded assets as liquidity and calculate LP units
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); // Get the SPARTA swap value of the bonded assets
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); // Increase SPARTA allowance if required
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & BNB as liquidity to mint LP tokens
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer user's assets to Dao contract
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); // Increase allowance if required
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); // Add spartaAllocation & assets as liquidity to mint LP tokens
        } 
    }

    // User claims all of their unlocked Bonded LPs
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; // Get array of bond assets
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); // Check user's unlocked Bonded LPs for each asset
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); // Claim LPs if any unlocked
            }
        }
        return true;
    }

    // User claims unlocked Bond units of a selected asset
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); // Check user's unlocked Bonded LPs
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); // Claim LPs if any unlocked
        }
        return true;
    }
    
    // Calculate user's unlocked Bond units of a selected asset
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); // Check user's unlocked Bonded LPs
        return claimAmount;
    }

    //============================== CREATE PROPOSALS ================================//

    // New ID, but specify type, one type for each function call
    // Votes counted to IDs
    // IDs are finalised
    // IDs are executed, but type specifies unique logic

    // New DAO proposal: Simple action
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: uint parameter
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_param[currentProposal] = param; // Set the proposed parameter
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Address parameter
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        mapPID_address[currentProposal] = proposedAddress; // Set the proposed new address
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // New DAO proposal: Grant SPARTA to wallet
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); // If no open proposal; construct new one
        payFee(); // Pay SPARTA fee for new proposal
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; // Set the proposal type
        mapPID_address[currentProposal] = recipient; // Set the proposed grant recipient
        mapPID_param[currentProposal] = amount; // Set the proposed grant amount
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    // If no existing open DAO proposal; register a new one
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); // There must not be an existing open proposal
        proposalCount += 1; // Increase proposal count
        currentProposal = proposalCount; // Set current proposal to the new count
        mapPID_open[currentProposal] = true; // Set new proposal as open status
        mapPID_startTime[currentProposal] = block.timestamp; // Set the start time of the proposal to now
    }
    
    // Pay the fee for a new DAO proposal
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); // Convert DAO fee to WEI
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); // User pays the new proposal fee
        return true;
    } 

    //============================== VOTE && FINALISE ================================//

    // Vote for a proposal
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); // Proposal must be open status
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeight = countVotes(); // Vote for proposal and recount
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); // Critical proposals require 'majority' consensus to enter finalization phase
                }
            } else {
                _finalise(); // Other proposals require 'quorum' consensus to enter finalization phase
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    // Remove vote from a proposal
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; // Get user's current vote weight
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; // Remove user's votes from propsal (scope: proposal)
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; // Remove user's votes from propsal (scope: member)
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    // Push the proposal into 'finalising' status
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
        mapPID_finalising[currentProposal] = true; // Set finalising status to true
        mapPID_coolOffTime[currentProposal] = block.timestamp; // Set timestamp to calc cooloff time from
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    // Attempt to cancel the open proposal
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); // Proposal must not be new
        mapPID_votes[currentProposal] = 0; // Clear all votes from the proposal
        mapPID_open[currentProposal] = false; // Set the proposal as not open (closed status)
        emit CancelProposal(msg.sender, currentProposal);
    }

    // A finalising-stage proposal can be finalised after the cool off period
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); // Must be past cooloff period
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); // Must be in finalising stage
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; // If proposal has lost quorum consensus; kick it out of the finalising stage
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); // Get the proposal type
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    // Change the DAO to a new contract address
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        DAO = _proposedAddress; // Change the DAO to point to the new DAO address
        iBASE(BASE).changeDAO(_proposedAddress); // Change the BASE contract to point to the new DAO address
        daoHasMoved = true; // Set status of this old DAO
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the ROUTER to a new contract address
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _ROUTER = iROUTER(_proposedAddress); // Change the DAO to point to the new ROUTER address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the UTILS to a new contract address
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _UTILS = iUTILS(_proposedAddress); // Change the DAO to point to the new UTILS address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change the RESERVE to a new contract address
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new address
        require(_proposedAddress != address(0), ""!address""); // Proposed address must be valid
        _RESERVE = iRESERVE(_proposedAddress); // Change the DAO to point to the new RESERVE address
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Flip the BASE emissions on/off
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); // Toggle emissions on the BASE contract
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change cool off period (Period of time until a finalising proposal can be finalised)
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        coolOffPeriod = _proposedParam; // Change coolOffPeriod
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Change erasToEarn (Used to regulate the incentives flow)
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; // Get the proposed new param
        require(_proposedParam != 0, ""!param""); // Proposed param must be valid
        erasToEarn = _proposedParam; // Change erasToEarn
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Grant SPARTA to the proposed recipient
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; // Get the proposed SPARTA grant amount
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed SPARTA grant recipient
        require(_proposedAmount != 0, ""!param""); // Proposed grant amount must be valid
        require(_proposedAddress != address(0), ""!address""); // Proposed recipient must be valid
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); // Grant the funds to the recipient
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Mint a 2.5M SPARTA allocation for the Bond program
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; //_2.5m
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); // Mint SPARTA and send to DAO to hold
        completeProposal(_proposalID); // Finalise the proposal
    }

    // List an asset to be enabled for Bonding
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; // Register asset as listed for Bond
            listedBondAssets.push(_proposedAddress); // Add asset to array of listed Bond assets
        }
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Delist an asset from being allowed to Bond
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        isListed[_proposedAddress] = false; // Unregister asset as listed for Bond (Keep it in the array though; as this is used in the UI)
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Add a pool as 'Curated' to enable synths, weight and incentives
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed new asset
        _POOLFACTORY.addCuratedPool(_proposedAddress); // Add the pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }

    // Remove a pool from Curated status
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; // Get the proposed asset for removal
        _POOLFACTORY.removeCuratedPool(_proposedAddress); // Remove pool as Curated
        completeProposal(_proposalID); // Finalise the proposal
    }
    
    // After completing the proposal's action; close it
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; // Get proposal type
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; // Reset proposal votes to 0
        mapPID_finalised[_proposalID] = true; // Finalise the proposal
        mapPID_finalising[_proposalID] = false; // Remove proposal from 'finalising' stage
        mapPID_open[_proposalID] = false; // Close the proposal
    }

    //============================== CONSENSUS ================================//
    
    // Add user's total weight to proposal and recount
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; // Remove user's current votes from the open proposal
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); // Get user's combined total weights
        mapPID_votes[currentProposal] += voteWeight; // Add user's total weight to the current open proposal (scope: proposal)
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; // Add user's total weight to the current open proposal (scope: member)
        return voteWeight;
    }

    // Check if a proposal has Majority consensus
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight * majorityFactor / 10000; // Majority > 66.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Quorum consensus
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 2; // Quorum > 50%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    // Check if a proposal has Minority consensus
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; // Get the proposal's total voting weight
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); // Get combined total vault weights
        uint consensus = _totalWeight / 6; // Minority > 16.6%
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    //======================================PROTOCOL CONTRACTs GETTER=================================//
    
    // Get the ROUTER address that the DAO currently points to
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    // Get the UTILS address that the DAO currently points to
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    // Get the BONDVAULT address that the DAO currently points to
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    // Get the DAOVAULT address that the DAO currently points to
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    // Get the POOLFACTORY address that the DAO currently points to
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    // Get the SYNTHFACTORY address that the DAO currently points to
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    // Get the RESERVE address that the DAO currently points to
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    // Get the SYNTHVAULT address that the DAO currently points to
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    //============================== HELPERS ================================//
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }",8037.0,720.0,"[H-04] Proposals can be cancelled
Anyone can cancel any proposals by calling DAO.cancelProposal(id, id) with oldProposalID == newProposalID. This always passes the minority check as the proposal was approved.
An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.   [H-05] Flash loans can affect governance voting in DAO.sol Flash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which, they also deterministically influence the voting outcome to their choice.
This has already happened in the case of MakerDAO governance where a flash loan was used to affect voting outcome and noted by the Maker team as: “a practical example for the community that flash loans can and may impact system governance”
Given that flash loans are a noted concern, the impact of it to DAO governance which can control all critical protocol parameters should be mitigated as in other places.
  [M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol
Given that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in voteProposal() is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).
  [M-06] Canceled proposals can still be executed
Proposals that passed the threshold (""finalized"") can be cancelled by a minority again using the cancelProposal functions. It only sets mapPID_votes to zero but mapPID_timeStart and mapPID_finalising stay the same and pass the checks in finaliseProposal which queues them for execution.
Proposals cannot be cancelled.
  [M-07] Completed proposals can be voted on and executed again
A proposal that is completed has its state reset, including the votes. Users can just vote on it again and it can be executed again.
Completed proposals should most likely not be allowed to be voted on / executed again. This could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the FinalisedProposal event has fired.
 [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()",6.0,"pragma solidity 0.8.3;
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iRESERVE.sol"";
import ""./interfaces/iDAOVAULT.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iBONDVAULT.sol"";
import ""./interfaces/iBASE.sol""; 
import ""./interfaces/iBEP20.sol"";
import ""./interfaces/iPOOLFACTORY.sol"";
import ""./interfaces/iSYNTHFACTORY.sol"";
import ""./interfaces/iSYNTHVAULT.sol"";

contract Dao {
    address public DEPLOYER;
    address public BASE;

    uint256 public secondsPerEra;   
    uint256 public coolOffPeriod;   
    uint256 public proposalCount;   
    uint256 public majorityFactor;  
    uint256 public erasToEarn;      
    uint256 public daoClaim;        
    uint256 public daoFee;          
    uint256 public currentProposal; 
    
    struct MemberDetails {
        bool isMember;
        uint weight;
        uint lastBlock;
        uint poolCount;
    }
    struct ProposalDetails {
        uint id;
        string proposalType;
        uint votes;
        uint coolOffTime;
        bool finalising;
        bool finalised;
        uint param;
        address proposedAddress;
        bool open;
        uint startTime;
    }

    bool public daoHasMoved;
    address public DAO;

    iROUTER private _ROUTER;
    iUTILS private _UTILS;
    iBONDVAULT private _BONDVAULT;
    iDAOVAULT private _DAOVAULT;
    iPOOLFACTORY private _POOLFACTORY;
    iSYNTHFACTORY private _SYNTHFACTORY;
    iRESERVE private _RESERVE;
    iSYNTHVAULT private _SYNTHVAULT;

    address[] public arrayMembers;
    address [] listedBondAssets; 
    uint256 public bondingPeriodSeconds = 15552000; 
    
    mapping(address => bool) public isMember;
    mapping(address => bool) public isListed; 
    mapping(address => uint256) public mapMember_lastTime;

    mapping(uint256 => uint256) public mapPID_param;
    mapping(uint256 => address) public mapPID_address;
    mapping(uint256 => string) public mapPID_type;
    mapping(uint256 => uint256) public mapPID_votes;
    mapping(uint256 => uint256) public mapPID_coolOffTime;
    mapping(uint256 => bool) public mapPID_finalising;
    mapping(uint256 => bool) public mapPID_finalised;
    mapping(uint256 => bool) public mapPID_open;
    mapping(uint256 => uint256) public mapPID_startTime;
    mapping(uint256 => mapping(address => uint256)) public mapPIDMember_votes;

    event MemberDeposits(address indexed member, address indexed pool, uint256 amount);
    event MemberWithdraws(address indexed member, address indexed pool, uint256 balance);

    event NewProposal(address indexed member, uint indexed proposalID, string proposalType);
    event NewVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event RemovedVote(address indexed member, uint indexed proposalID, uint voteWeight, uint totalVotes, string proposalType);
    event ProposalFinalising(address indexed member, uint indexed proposalID, uint timeFinalised, string proposalType);
    event CancelProposal(address indexed member, uint indexed proposalID);
    event FinalisedProposal(address indexed member, uint indexed proposalID, uint votesCast, uint totalWeight, string proposalType);
    event ListedAsset(address indexed DAO, address indexed asset);
    event DelistedAsset(address indexed DAO, address indexed asset);
    event DepositAsset(address indexed owner, uint256 depositAmount, uint256 bondedLP);

    
    modifier onlyDAO() {
        require(msg.sender == DEPLOYER);
        _;
    }

    constructor (address _base){
        BASE = _base;
        DEPLOYER = msg.sender;
        DAO = address(this);
        coolOffPeriod = 259200;
        erasToEarn = 30;
        majorityFactor = 6666;
        daoClaim = 1000;
        daoFee = 100;
        proposalCount = 0;
        secondsPerEra = iBASE(BASE).secondsPerEra();
    }

    

    function setGenesisAddresses(address _router, address _utils, address _reserve) external onlyDAO {
        _ROUTER = iROUTER(_router);
        _UTILS = iUTILS(_utils);
        _RESERVE = iRESERVE(_reserve);
    }

    function setVaultAddresses(address _daovault, address _bondvault, address _synthVault) external onlyDAO {
        _DAOVAULT = iDAOVAULT(_daovault);
        _BONDVAULT = iBONDVAULT(_bondvault);
        _SYNTHVAULT = iSYNTHVAULT(_synthVault); 
    }
    
    function setFactoryAddresses(address _poolFactory, address _synthFactory) external onlyDAO {
        _POOLFACTORY = iPOOLFACTORY(_poolFactory);
        _SYNTHFACTORY = iSYNTHFACTORY(_synthFactory);
    }

    function setGenesisFactors(uint32 _coolOff, uint32 _daysToEarn, uint32 _majorityFactor, uint32 _daoClaim, uint32 _daoFee) external onlyDAO {
        coolOffPeriod = _coolOff;
        erasToEarn = _daysToEarn;
        majorityFactor = _majorityFactor;
        daoClaim = _daoClaim;
        daoFee = _daoFee;
    }

    
    function purgeDeployer() external onlyDAO {
        DEPLOYER = address(0);
    }

    
    function changeBondingPeriod(uint256 bondingSeconds) external onlyDAO{
        bondingPeriodSeconds = bondingSeconds;
    }

    

    
    function deposit(address pool, uint256 amount) external {
        depositLPForMember(pool, amount, msg.sender);
    }

    
    function depositLPForMember(address pool, uint256 amount, address member) public {
        require(_POOLFACTORY.isCuratedPool(pool) == true, ""!curated""); 
        require(amount > 0, ""!amount""); 
        if (isMember[member] != true) {
            arrayMembers.push(member); 
            isMember[member] = true; 
        }
        if((_DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member)) > 0) {
            harvest(); 
        }
        require(iBEP20(pool).transferFrom(msg.sender, address(_DAOVAULT), amount), ""!funds""); 
        _DAOVAULT.depositLP(pool, amount, member); 
        mapMember_lastTime[member] = block.timestamp; 
        emit MemberDeposits(member, pool, amount);
    }
    
    
    function withdraw(address pool) external {
        removeVote(); 
        require(_DAOVAULT.withdraw(pool, msg.sender), ""!transfer""); 
    }

    
    
    
    function harvest() public {
        require(_RESERVE.emissions(), ""!emissions""); 
        uint reward = calcCurrentReward(msg.sender); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)); 
        uint daoReward = (reserve * daoClaim) / 10000; 
        if(reward > daoReward){
            reward = daoReward; 
        }
        _RESERVE.grantFunds(reward, msg.sender); 
    }

    
    function calcCurrentReward(address member) public view returns(uint){
        uint secondsSinceClaim = block.timestamp - mapMember_lastTime[member]; 
        uint share = calcReward(member); 
        uint reward = (share * secondsSinceClaim) / secondsPerEra; 
        return reward;
    }

    
    function calcReward(address member) public view returns(uint){
        uint weight = _DAOVAULT.getMemberWeight(member) + _BONDVAULT.getMemberWeight(member); 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint reserve = iBEP20(BASE).balanceOf(address(_RESERVE)) / erasToEarn; 
        uint daoReward = (reserve * daoClaim) / 10000; 
        return _UTILS.calcShare(weight, _totalWeight, daoReward); 
    }

    

    
    function burnBalance() external onlyDAO returns (bool){
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBASE(BASE).burn(baseBal);   
        return true;
    }

    
    function moveBASEBalance(address newDAO) external onlyDAO {
        uint256 baseBal = iBEP20(BASE).balanceOf(address(this));
        iBEP20(BASE).transfer(newDAO, baseBal);
    }

    
    function listBondAsset(address asset) external onlyDAO {
        if(!isListed[asset]){
            isListed[asset] = true; 
            listedBondAssets.push(asset); 
        }
        emit ListedAsset(msg.sender, asset);
    }

    
    function delistBondAsset(address asset) external onlyDAO {
        isListed[asset] = false; 
        emit DelistedAsset(msg.sender, asset);
    }

    
    function bond(address asset, uint256 amount) external payable returns (bool success) {
        require(amount > 0, '!amount'); 
        require(isListed[asset], '!listed'); 
        if (isMember[msg.sender] != true) {
            arrayMembers.push(msg.sender); 
            isMember[msg.sender] = true; 
        }
        if((_DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender)) > 0) {
            harvest(); 
        }
        uint256 liquidityUnits = handleTransferIn(asset, amount); 
        _BONDVAULT.depositForMember(asset, msg.sender, liquidityUnits); 
        mapMember_lastTime[msg.sender] = block.timestamp; 
        emit DepositAsset(msg.sender, amount, liquidityUnits);
        return true;
    }

    
    function handleTransferIn(address _token, uint _amount) internal returns (uint LPunits){
        uint256 spartaAllocation = _UTILS.calcSwapValueInBase(_token, _amount); 
        if(iBEP20(BASE).allowance(address(this), address(_ROUTER)) < spartaAllocation){
            iBEP20(BASE).approve(address(_ROUTER), iBEP20(BASE).totalSupply()); 
        }
        if(_token == address(0)){
            require((_amount == msg.value), ""!amount"");
            LPunits = _ROUTER.addLiquidityForMember{value:_amount}(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } else {
            iBEP20(_token).transferFrom(msg.sender, address(this), _amount); 
            if(iBEP20(_token).allowance(address(this), address(_ROUTER)) < _amount){
                uint256 approvalTNK = iBEP20(_token).totalSupply();
                iBEP20(_token).approve(address(_ROUTER), approvalTNK); 
            }
            LPunits = _ROUTER.addLiquidityForMember(spartaAllocation, _amount, _token, address(_BONDVAULT)); 
        } 
    }

    
    function claimAllForMember(address member) external returns (bool){
        address [] memory listedAssets = listedBondAssets; 
        for(uint i = 0; i < listedAssets.length; i++){
            uint claimA = calcClaimBondedLP(member, listedAssets[i]); 
            if(claimA > 0){
               _BONDVAULT.claimForMember(listedAssets[i], member); 
            }
        }
        return true;
    }

    
    function claimForMember(address asset) external returns (bool){
        uint claimA = calcClaimBondedLP(msg.sender, asset); 
        if(claimA > 0){
            _BONDVAULT.claimForMember(asset, msg.sender); 
        }
        return true;
    }
    
    
    function calcClaimBondedLP(address bondedMember, address asset) public returns (uint){
        uint claimAmount = _BONDVAULT.calcBondedLP(bondedMember, asset); 
        return claimAmount;
    }

    

    
    
    
    

    
    function newActionProposal(string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newParamProposal(uint32 param, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_param[currentProposal] = param; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newAddressProposal(address proposedAddress, string memory typeStr) external returns(uint) {
        checkProposal(); 
        payFee(); 
        mapPID_address[currentProposal] = proposedAddress; 
        mapPID_type[currentProposal] = typeStr; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function newGrantProposal(address recipient, uint amount) external returns(uint) {
        checkProposal(); 
        payFee(); 
        string memory typeStr = ""GRANT"";
        mapPID_type[currentProposal] = typeStr; 
        mapPID_address[currentProposal] = recipient; 
        mapPID_param[currentProposal] = amount; 
        emit NewProposal(msg.sender, currentProposal, typeStr);
        return currentProposal;
    }

    
    function checkProposal() internal {
        require(mapPID_open[currentProposal] == false, '!open'); 
        proposalCount += 1; 
        currentProposal = proposalCount; 
        mapPID_open[currentProposal] = true; 
        mapPID_startTime[currentProposal] = block.timestamp; 
    }
    
    
    function payFee() internal returns(bool){
        uint _amount = daoFee*(10**18); 
        require(iBEP20(BASE).transferFrom(msg.sender, address(_RESERVE), _amount), '!fee'); 
        return true;
    } 

    

    
    function voteProposal() external returns (uint voteWeight) {
        require(mapPID_open[currentProposal] == true, ""!open""); 
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeight = countVotes(); 
        if(hasQuorum(currentProposal) && mapPID_finalising[currentProposal] == false){
            if(isEqual(_type, 'DAO') || isEqual(_type, 'UTILS') || isEqual(_type, 'RESERVE') ||isEqual(_type, 'GET_SPARTA') || isEqual(_type, 'ROUTER') || isEqual(_type, 'LIST_BOND')|| isEqual(_type, 'GRANT')|| isEqual(_type, 'ADD_CURATED_POOL')){
                if(hasMajority(currentProposal)){
                    _finalise(); 
                }
            } else {
                _finalise(); 
            }
        }
        emit NewVote(msg.sender, currentProposal, voteWeight, mapPID_votes[currentProposal], string(_type));
    }

    
    function removeVote() public returns (uint voteWeightRemoved){
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        voteWeightRemoved = mapPIDMember_votes[currentProposal][msg.sender]; 
        if(mapPID_open[currentProposal]){
            mapPID_votes[currentProposal] -= voteWeightRemoved; 
        }
        mapPIDMember_votes[currentProposal][msg.sender] = 0; 
        emit RemovedVote(msg.sender, currentProposal, voteWeightRemoved, mapPID_votes[currentProposal], string(_type));
        return voteWeightRemoved;
    }

    
    function _finalise() internal {
        bytes memory _type = bytes(mapPID_type[currentProposal]); 
        mapPID_finalising[currentProposal] = true; 
        mapPID_coolOffTime[currentProposal] = block.timestamp; 
        emit ProposalFinalising(msg.sender, currentProposal, block.timestamp+coolOffPeriod, string(_type));
    }

    
    function cancelProposal() external {
        require(block.timestamp > (mapPID_startTime[currentProposal] + 1296000), ""!days""); 
        mapPID_votes[currentProposal] = 0; 
        mapPID_open[currentProposal] = false; 
        emit CancelProposal(msg.sender, currentProposal);
    }

    
    function finaliseProposal() external {
        require((block.timestamp - mapPID_coolOffTime[currentProposal]) > coolOffPeriod, ""!cooloff""); 
        require(mapPID_finalising[currentProposal] == true, ""!finalising""); 
        if(!hasQuorum(currentProposal)){
            mapPID_finalising[currentProposal] = false; 
        } else {
            bytes memory _type = bytes(mapPID_type[currentProposal]); 
            if(isEqual(_type, 'DAO')){
                moveDao(currentProposal);
            } else if (isEqual(_type, 'ROUTER')) {
                moveRouter(currentProposal);
            } else if (isEqual(_type, 'UTILS')){
                moveUtils(currentProposal);
            } else if (isEqual(_type, 'RESERVE')){
                moveReserve(currentProposal);
            } else if (isEqual(_type, 'FLIP_EMISSIONS')){
                flipEmissions(currentProposal);
            } else if (isEqual(_type, 'COOL_OFF')){
                changeCooloff(currentProposal);
            } else if (isEqual(_type, 'ERAS_TO_EARN')){
                changeEras(currentProposal);
            } else if (isEqual(_type, 'GRANT')){
                grantFunds(currentProposal);
            } else if (isEqual(_type, 'GET_SPARTA')){
                _increaseSpartaAllocation(currentProposal);
            } else if (isEqual(_type, 'LIST_BOND')){
                _listBondingAsset(currentProposal);
            } else if (isEqual(_type, 'DELIST_BOND')){
                _delistBondingAsset(currentProposal);
            } else if (isEqual(_type, 'ADD_CURATED_POOL')){
                _addCuratedPool(currentProposal);
            } else if (isEqual(_type, 'REMOVE_CURATED_POOL')){
                _removeCuratedPool(currentProposal);
            } 
        }
    }

    
    function moveDao(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        DAO = _proposedAddress; 
        iBASE(BASE).changeDAO(_proposedAddress); 
        daoHasMoved = true; 
        completeProposal(_proposalID); 
    }

    
    function moveRouter(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _ROUTER = iROUTER(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveUtils(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _UTILS = iUTILS(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function moveReserve(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE = iRESERVE(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function flipEmissions(uint _proposalID) internal {
        iBASE(BASE).flipEmissions(); 
        completeProposal(_proposalID); 
    }

    
    function changeCooloff(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        coolOffPeriod = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function changeEras(uint _proposalID) internal {
        uint256 _proposedParam = mapPID_param[_proposalID]; 
        require(_proposedParam != 0, ""!param""); 
        erasToEarn = _proposedParam; 
        completeProposal(_proposalID); 
    }

    
    function grantFunds(uint _proposalID) internal {
        uint256 _proposedAmount = mapPID_param[_proposalID]; 
        address _proposedAddress = mapPID_address[_proposalID]; 
        require(_proposedAmount != 0, ""!param""); 
        require(_proposedAddress != address(0), ""!address""); 
        _RESERVE.grantFunds(_proposedAmount, _proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _increaseSpartaAllocation(uint _proposalID) internal {
        uint256 _2point5m = 2.5*10**6*10**18; 
        iBASE(BASE).mintFromDAO(_2point5m, address(this)); 
        completeProposal(_proposalID); 
    }

    
    function _listBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        if(!isListed[_proposedAddress]){
            isListed[_proposedAddress] = true; 
            listedBondAssets.push(_proposedAddress); 
        }
        completeProposal(_proposalID); 
    }

    
    function _delistBondingAsset(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        isListed[_proposedAddress] = false; 
        completeProposal(_proposalID); 
    }

    
    function _addCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.addCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }

    
    function _removeCuratedPool(uint _proposalID) internal {
        address _proposedAddress = mapPID_address[_proposalID]; 
        _POOLFACTORY.removeCuratedPool(_proposedAddress); 
        completeProposal(_proposalID); 
    }
    
    
    function completeProposal(uint _proposalID) internal {
        string memory _typeStr = mapPID_type[_proposalID]; 
        emit FinalisedProposal(msg.sender, _proposalID, mapPID_votes[_proposalID], _DAOVAULT.totalWeight(), _typeStr);
        mapPID_votes[_proposalID] = 0; 
        mapPID_finalised[_proposalID] = true; 
        mapPID_finalising[_proposalID] = false; 
        mapPID_open[_proposalID] = false; 
    }

    
    
    
    function countVotes() internal returns (uint voteWeight){
        mapPID_votes[currentProposal] -= mapPIDMember_votes[currentProposal][msg.sender]; 
        voteWeight = _DAOVAULT.getMemberWeight(msg.sender) + _BONDVAULT.getMemberWeight(msg.sender); 
        mapPID_votes[currentProposal] += voteWeight; 
        mapPIDMember_votes[currentProposal][msg.sender] = voteWeight; 
        return voteWeight;
    }

    
    function hasMajority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight() + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight * majorityFactor / 10000; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasQuorum(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 2; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    function hasMinority(uint _proposalID) public view returns(bool){
        uint votes = mapPID_votes[_proposalID]; 
        uint _totalWeight = _DAOVAULT.totalWeight()  + _BONDVAULT.totalWeight(); 
        uint consensus = _totalWeight / 6; 
        if(votes > consensus){
            return true;
        } else {
            return false;
        }
    }

    
    
    
    function ROUTER() public view returns(iROUTER){
        if(daoHasMoved){
            return Dao(DAO).ROUTER();
        } else {
            return _ROUTER;
        }
    }

    
    function UTILS() public view returns(iUTILS){
        if(daoHasMoved){
            return Dao(DAO).UTILS();
        } else {
            return _UTILS;
        }
    }

    
    function BONDVAULT() public view returns(iBONDVAULT){
        if(daoHasMoved){
            return Dao(DAO).BONDVAULT();
        } else {
            return _BONDVAULT;
        }
    }

    
    function DAOVAULT() public view returns(iDAOVAULT){
        if(daoHasMoved){
            return Dao(DAO).DAOVAULT();
        } else {
            return _DAOVAULT;
        }
    }

    
    function POOLFACTORY() public view returns(iPOOLFACTORY){
        if(daoHasMoved){
            return Dao(DAO).POOLFACTORY();
        } else {
            return _POOLFACTORY;
        }
    }

    
    function SYNTHFACTORY() public view returns(iSYNTHFACTORY){
        if(daoHasMoved){
            return Dao(DAO).SYNTHFACTORY();
        } else {
            return _SYNTHFACTORY;
        }
    }

    
    function RESERVE() public view returns(iRESERVE){
        if(daoHasMoved){
            return Dao(DAO).RESERVE();
        } else {
            return _RESERVE;
        }
    }

    
    function SYNTHVAULT() public view returns(iSYNTHVAULT){
        if(daoHasMoved){
            return Dao(DAO).SYNTHVAULT();
        } else {
            return _SYNTHVAULT;
        }
    }

    
    
    function memberCount() external view returns(uint){
        return arrayMembers.length;
    }

    function getProposalDetails(uint proposalID) external view returns (ProposalDetails memory proposalDetails){
        proposalDetails.id = proposalID;
        proposalDetails.proposalType = mapPID_type[proposalID];
        proposalDetails.votes = mapPID_votes[proposalID];
        proposalDetails.coolOffTime = mapPID_coolOffTime[proposalID];
        proposalDetails.finalising = mapPID_finalising[proposalID];
        proposalDetails.finalised = mapPID_finalised[proposalID];
        proposalDetails.param = mapPID_param[proposalID];
        proposalDetails.proposedAddress = mapPID_address[proposalID];
        proposalDetails.open = mapPID_open[proposalID];
        proposalDetails.startTime = mapPID_startTime[proposalID];
        return proposalDetails;
    }

    function assetListedCount() external view returns (uint256 count){
        return listedBondAssets.length;
    }

    function allListedAssets() external view returns (address[] memory _allListedAssets){
        return listedBondAssets;
    }
    
    function isEqual(bytes memory part1, bytes memory part2) private pure returns(bool){
        if(sha256(part1) == sha256(part2)){
            return true;
        } else {
            return false;
        }",5820.0,2,4,"The provided smart contract contains several vulnerabilities and potential issues. Below is a list of the identified vulnerabilities:

### 1. **Reentrancy Vulnerability**
   - **Location**: `withdraw`, `harvest`, `bond`, `handleTransferIn`, `claimAllForMember`, `claimForMember`, `payFee`, `voteProposal`, `removeVote`, `finaliseProposal`, `moveDao`, `moveRouter`, `moveUtils`, `moveReserve`, `flipEmissions`, `changeCooloff`, `changeEras`, `grantFunds`, `_increaseSpartaAllocation`, `_listBondingAsset`, `_delistBondingAsset`, `_addCuratedPool`, `_removeCuratedPool`, `completeProposal`, `countVotes`.
   - **Description**: The contract interacts with external contracts (e.g., `iBEP20`, `iROUTER`, `iDAOVAULT`, `iBONDVAULT`, etc.) without following the checks-effects-interactions pattern. This could potentially lead to reentrancy attacks, where an attacker could recursively call back into the contract before the state is updated.

### 2. **Unrestricted Access to Critical Functions**
   - **Location**: `setGenesisAddresses`, `setVaultAddresses`, `setFactoryAddresses`, `setGenesisFactors`, `purgeDeployer`, `changeBondingPeriod`, `burnBalance`, `moveBASEBalance`, `listBondAsset`, `delistBondAsset`.
   - **Description**: These functions are protected by the `onlyDAO` modifier, which only checks if the caller is the `DEPLOYER`. However, if the `DEPLOYER` is compromised or if the `DEPLOYER` is not properly managed, an attacker could gain control over these critical functions, leading to potential loss of funds or manipulation of the contract state.

### 3. **Integer Overflow/Underflow**
   - **Location**: `calcCurrentReward`, `calcReward`, `harvest`, `bond`, `handleTransferIn`, `countVotes`, `hasMajority`, `hasQuorum`, `hasMinority`.
   - **Description**: The contract performs arithmetic operations without using SafeMath or similar protections. Although Solidity 0.8.x has built-in overflow/underflow checks, the contract should still be reviewed to ensure that all arithmetic operations are safe.

### 4. **Lack of Input Validation**
   - **Location**: `depositLPForMember`, `withdraw`, `bond`, `handleTransferIn`, `newActionProposal`, `newParamProposal`, `newAddressProposal`, `newGrantProposal`, `voteProposal`, `removeVote`, `finaliseProposal`, `moveDao`, `moveRouter`, `moveUtils`, `moveReserve`, `flipEmissions`, `changeCooloff`, `changeEras`, `grantFunds`, `_increaseSpartaAllocation`, `_listBondingAsset`, `_delistBondingAsset`, `_addCuratedPool`, `_removeCuratedPool`.
   - **Description**: Many functions do not validate input parameters adequately. For example, `newAddressProposal` does not check if the proposed address is a valid contract address, and `newParamProposal` does not validate the range of the proposed parameter.

### 5. **Potential Denial of Service (DoS)**
   - **Location**: `arrayMembers.push(member)`, `listedBondAssets.push(asset)`.
   - **Description**: The contract uses dynamic arrays (`arrayMembers` and `listedBondAssets`) without any mechanism to limit their size. An attacker could potentially cause the contract to run out of gas by adding a large number of members or assets, leading to a denial of service.

### 6. **Uninitialized Storage Pointers**
   - **Location**: `ProposalDetails` struct in `getProposalDetails`.
   - **Description**: The `getProposalDetails` function returns a `ProposalDetails` struct that is populated from storage mappings. If a proposal ID does not exist, the returned struct will contain uninitialized values, which could lead to unexpected behavior.

### 7. **Incorrect Use of `msg.value`**
   - **Location**: `handleTransferIn`.
   - **Description**: The function checks if `_amount == msg.value` when `_token` is `address(0)`. However, this check is not sufficient to ensure that the correct amount of Ether is sent, especially if the function is called with additional data or in a complex transaction.

### 8. **Potential Front-Running**
   - **Location**: `newActionProposal`, `newParamProposal`, `newAddressProposal`, `newGrantProposal`.
   - **Description**: These functions allow users to create new proposals, but there is no mechanism to prevent front-running. An attacker could monitor the mempool for proposal submissions and front-run them to manipulate the outcome.

### 9. **Lack of Event Emission in Critical Functions**
   - **Location**: `setGenesisAddresses`, `setVaultAddresses`, `setFactoryAddresses`, `setGenesisFactors`, `purgeDeployer`, `changeBondingPeriod`, `burnBalance`, `moveBASEBalance`.
   - **Description**: These functions do not emit events after changing critical state variables. This makes it difficult to track changes and could lead to a lack of transparency.

### 10. **Potential Gas Limit Issues**
   - **Location**: `claimAllForMember`, `allListedAssets`.
   - **Description**: The `claimAllForMember` function iterates over all listed bond assets, which could potentially run out of gas if the number of assets is large. Similarly, `allListedAssets` returns a dynamic array, which could also lead to gas issues if the array is too large.

### 11. **Incorrect Use of `sha256` for String Comparison**
   - **Location**: `isEqual`.
   - **Description**: The `isEqual` function uses `sha256` to compare two strings. This is not a secure way to compare strings, as it could lead to hash collisions. A more secure approach would be to use `keccak256` or directly compare the strings.

### 12. **Lack of Error Messages in `require` Statements**
   - **Location**: `depositLPForMember`, `withdraw`, `harvest`, `bond`, `handleTransferIn`, `payFee`, `voteProposal`, `removeVote`, `finaliseProposal`, `moveDao`, `moveRouter`, `moveUtils`, `moveReserve`, `flipEmissions`, `changeCooloff`, `changeEras`, `grantFunds`, `_increaseSpartaAllocation`, `_listBondingAsset`, `_delistBondingAsset`, `_addCuratedPool`, `_removeCuratedPool`.
   - **Description**: Many `require` statements do not include error messages, making it difficult to debug and understand why a transaction failed.

### 13. **Potential Division by Zero**
   - **Location**: `calcCurrentReward`, `calcReward`, `hasMajority`, `hasQuorum`, `hasMinority`.
   - **Description**: These functions perform division operations without checking if the denominator is zero, which could lead to a runtime error.

### 14. **Unrestricted Minting in `_increaseSpartaAllocation`**
   - **Location**: `_increaseSpartaAllocation`.
   - **Description**: The function mints a fixed amount of tokens (`2.5 million`) without any checks or restrictions. This could lead to inflation or other economic issues if not properly managed.

### 15. **Lack of Access Control on `completeProposal`**
   - **Location**: `completeProposal`.
   - **Description**: The `completeProposal` function is internal but is called by various functions that finalize proposals. There is no access control to ensure that only authorized entities can finalize proposals, which could lead to unauthorized changes.

### 16. **Potential Unintended Behavior in `moveDao`**
   - **Location**: `moveDao`.
   - **Description**: The `moveDao` function changes the `DAO` address and updates the `daoHasMoved` flag. However, if the `DAO` address is set to an invalid or malicious contract, it could lead to unintended behavior or loss of control over the contract.

### 17. **Incorrect Use of `transferFrom`**
   - **Location**: `depositLPForMember`, `payFee`.
   - **Description**: The `transferFrom` function is used without checking the return value. If the transfer fails, the function will not revert, leading to potential loss of funds.

### 18. **Potential Unintended Behavior in `handleTransferIn`**
   - **Location**: `handleTransferIn`.
   - **Description**: The function approves the `_ROUTER` to spend an unlimited amount of tokens (`totalSupply`). This could lead to unintended behavior if the `_ROUTER` is compromised or if the approval is not properly managed.

### 19. **Lack of Checks on `mapPID_open`**
   - **Location**: `voteProposal`, `removeVote`, `finaliseProposal`.
   - **Description**: The contract does not check if `mapPID_open[currentProposal]` is `true` before performing operations on it. This could lead to unexpected behavior if a proposal is not open.

### 20. **Potential Unintended Behavior in `finaliseProposal`**
   - **Location**: `finaliseProposal`.
   - **Description**: The function does not check if the proposal has already been finalized, which could lead to multiple finalizations of the same proposal.

### 21. **Lack of Checks on `mapPID_finalised`**
   - **Location**: `finaliseProposal`.
   - **Description**: The function does not check if `mapPID_finalised[currentProposal]` is `true` before finalizing the proposal. This could lead to unexpected behavior if a proposal is already finalized.

### 22. **Potential Unintended Behavior in `cancelProposal`**
   - **Location**: `cancelProposal`.
   - **Description**: The function does not check if the proposal is open or if the caller is authorized to cancel the proposal. This could lead to unauthorized cancellations.

### 23. **Potential Unintended Behavior in `ROUTER`, `UTILS`, `BONDVAULT`, `DAOVAULT`, `POOLFACTORY`, `SYNTHFACTORY`, `RESERVE`, `SYNTHVAULT`**
   - **Location**: `ROUTER`, `UTILS`, `BONDVAULT`, `DAOVAULT`, `POOLFACTORY`, `SYNTHFACTORY`, `RESERVE`, `SYNTHVAULT`.
   - **Description**: These functions return the address of the respective contracts. If `daoHasMoved` is `true`, they call the same function on the new `DAO` contract. However, there is no check to ensure that the new `DAO` contract is valid, which could lead to unexpected behavior.

### 24. **Potential Unintended Behavior in `memberCount`**
   - **Location**: `memberCount`.
   - **Description**: The function returns the length of `arrayMembers`, but there is no check to ensure that `arrayMembers` is not empty. This could lead to unexpected behavior if `arrayMembers` is empty.

### 25. **Potential Unintended Behavior in `assetListedCount`**
   - **Location**: `assetListedCount`.
   - **Description**: The function returns the length of `listedBondAssets`, but there is no check to ensure that `listedBondAssets` is not empty. This could lead to unexpected behavior if `listedBondAssets` is empty.

### 26. **Potential Unintended Behavior in `allListedAssets`**
   - **Location**: `allListedAssets`.
   - **Description**: The function returns the `listedBondAssets` array, but there is no check to ensure that `listedBondAssets` is not empty. This could lead to unexpected behavior if `listedBondAssets` is empty.

### 27. **Potential Unintended Behavior in `isEqual`**
   - **Location**: `isEqual`.
   - **Description**: The function compares two byte arrays using `sha256`, but there is no check to ensure that the byte arrays are not empty. This could lead to unexpected behavior if the byte arrays are empty.

### 28. **Potential Unintended Behavior in `getProposalDetails`**
   - **Location**: `getProposalDetails`.
   - **Description**: The function returns a `ProposalDetails` struct, but there is no check to ensure that the proposal ID exists. This could lead to unexpected behavior if the proposal ID does not exist.

### 29. **Potential Unintended Behavior in `calcClaimBondedLP`**
   - **Location**: `calcClaimBondedLP`.
   - **Description**: The function calls `_BONDVAULT.calcBondedLP`, but there is no check to ensure that `_BONDVAULT` is a valid contract. This could lead to unexpected behavior if `_BONDVAULT` is not a valid contract.

### 30. **Potential Unintended Behavior in `claimForMember`**
   - **Location**: `claimForMember`.
   - **Description**: The function calls `_BONDVAULT.claimForMember`, but there is no check to ensure that `_BONDVAULT` is a valid contract. This could lead to unexpected behavior if `_BONDVAULT` is not a valid contract.","### **Comparison of Issues and Responses**

---

#### **[H-04] Proposals can be cancelled**

**Report Description**:
Anyone can cancel any proposals by calling `DAO.cancelProposal(id, id)` with `oldProposalID == newProposalID`. This always passes the minority check as the proposal was approved. An attacker can launch a denial of service attack on the DAO governance and prevent any proposals from being executed.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of unauthorized proposal cancellation or the potential denial of service attack. This is a critical governance vulnerability that is not covered in the response list.

---

#### **[H-05] Flash loans can affect governance voting in DAO.sol**

**Report Description**:
Flash loans can significantly increase a single voter's weight and be used to impact the voting outcome. A voter can borrow a significant quantity of tokens to increase their voting weight in a transaction within which they also deterministically influence the voting outcome to their choice. This has already happened in the case of MakerDAO governance, where a flash loan was used to affect the voting outcome. Given that flash loans are a noted concern, the impact of it to DAO governance, which can control all critical protocol parameters, should be mitigated as in other places.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of flash loans affecting governance voting. This is a significant risk, especially in DAO governance, and should be explicitly mitigated.

---

#### **[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol**

**Report Description**:
Given that there are only three proposal types (GRANT, UTILS, REWARD) that are actionable, it is unclear if 'DAO' type checked in `voteProposal()` is a typographical error and should really be 'GRANT'. Otherwise, GRANT proposals will only require quorum (33%) and not majority (50%).

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of undefined behavior for DAO and GRANT vote proposals. This could lead to incorrect voting thresholds and governance issues.

---

#### **[M-06] Canceled proposals can still be executed**

**Report Description**:
Proposals that passed the threshold (""finalized"") can be cancelled by a minority again using the `cancelProposal` functions. It only sets `mapPID_votes` to zero, but `mapPID_timeStart` and `mapPID_finalising` stay the same and pass the checks in `finaliseProposal`, which queues them for execution. Proposals cannot be cancelled.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of canceled proposals still being executable. This is a governance vulnerability that could lead to unintended proposal execution.

---

#### **[M-07] Completed proposals can be voted on and executed again**

**Report Description**:
A proposal that is completed has its state reset, including the votes. Users can just vote on it again, and it can be executed again. Completed proposals should most likely not be allowed to be voted on / executed again. This could also lead to issues in backend scripts that don't expect any voting/execution events to be fired again after the `FinalisedProposal` event has fired.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of completed proposals being voted on and executed again. This could lead to repeated execution of proposals and potential governance issues.

---

#### **[M-13] Init function can be called by everyone**

**Report Description**:
Most of the Solidity contracts have an `init` function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment, a hacker could call the `init` function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of the `init` function being callable by everyone. This is a critical deployment vulnerability that could lead to contract initialization being hijacked.

---

### **Summary of Matches and Gaps**

**Correct Matches**:
- *None*

**Partially Correct Matches**:
- *None*

**Missed Issues from Issue Report**:
- **[H-04] Proposals can be cancelled**
- **[H-05] Flash loans can affect governance voting in DAO.sol**
- **[M-02] Undefined behavior for DAO and GRANT vote proposals in DAO.sol**
- **[M-06] Canceled proposals can still be executed**
- **[M-07] Completed proposals can be voted on and executed again**
- **[M-13] Init function can be called by everyone**

---

### **Conclusion**
The response list does not adequately address the issues reported in the `issue` list. Several critical vulnerabilities, particularly those related to governance and initialization, are completely missed. The response list focuses on general vulnerabilities like reentrancy, integer overflow, and lack of input validation but fails to cover the specific issues outlined in the `issue` report. This indicates a significant gap in the coverage and accuracy of the responses.",0,0,6,30,"```
None.
```",0.0
utils.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Utils {

    uint private one = 10**18;
    uint private _10k = 10000;
    uint private _year = 31536000; // One Year (in seconds)

    bool private inited;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    constructor () {}

    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        POOLS = _pools;
        FACTORY = _factory;
    }
    //====================================SYSTEM FUNCTIONS====================================//
    // VADER FeeOnTransfer
    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){
        return calcShare(totalSupply, maxSupply, 100); // 0->100BP
    }

    function assetChecks(address collateralAsset, address debtAsset) external {
        if(collateralAsset == VADER){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        } else if(collateralAsset == USDV){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); // Can borrow Asset with VADER/ASSET-SYNTH
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); // Can borrow Anchor with VADER/ANCHOR-SYNTH
        }
    }

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    //====================================PRICING====================================//

    function calcValueInBase(address token, uint amount) public view returns (uint value){
       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
       if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _baseAmt) / _tokenAmt;
       }
    }

    function calcValueInToken(address token, uint amount) public view returns (uint value){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _tokenAmt) / _baseAmt;
       }
    }
    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){
            return calcValueInToken(token2, calcValueInBase(token1, amount));
    }

    function calcSwapValueInBase(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _tokenAmt, _baseAmt);
    }
    function calcSwapValueInToken(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _baseAmt, _tokenAmt);
    }

    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {
        uint _testingPrice = calcValueInBase(token, one);
        uint _lower = calcPart((_10k - bound), targetPrice);                // ie 98% of price
        uint _upper = (targetPrice * (_10k + bound)) / _10k;                // ie 105% of price
        if(inside){
            require((_testingPrice >= _lower && _testingPrice <= _upper), ""Not inside"");
        } else {
            require((_testingPrice <= _lower || _testingPrice >= _upper), ""Not outside"");
        }
    }

    //====================================INCENTIVES========================================//

    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {
        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){
            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);
            if (iPOOLS(POOLS).isAsset(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            } else if(iPOOLS(POOLS).isAnchor(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            }
        }
    }

    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {
        return calcShare(1, rewardReductionFactor, amount); // Reduce to stop depleting fast
    }

    //=================================IMPERMANENT LOSS=====================================//

    // Actual protection with 100 day rule and Reserve balance
    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {
        uint _coverage = getCoverage(member, token);
        if(iROUTER(ROUTER).isCurated(token)){
            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);
            if(_duration <= timeForFullProtection) {
                protection = calcShare(_duration, timeForFullProtection, _coverage); // Apply 100 day rule
            } else {
                protection = _coverage;
            }
        }
        return calcPart(basisPoints, protection);
    }
    // Theoretical coverage based on deposit/redemption values
    function getCoverage(address member, address token) public view returns (uint) {
        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);
        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);
        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));
        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));
        return calcCoverage(_B0, _T0, _B1, _T1);
    }

    //==================================== LENDING ====================================//

    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {
        uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio
        if(isBase(collateralAsset)){
            baseValue = _collateralAdjusted;
        }else if(isPool(collateralAsset)){
            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE
        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){
            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value
        }
        debt = calcSwapValueInToken(debtAsset, baseValue);        // get debt output
        return (debt, baseValue);
    }

    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {
        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); // Outstanding Debt
        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); // Collateral
        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);
        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);
        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); // Share of interest based on collateral
        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); 
        return (_collateralUnlocked, _memberInterestShare);
    }

    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {
        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); // Share of the payment over 1 year
        if(isBase(collateralAsset)){
            interestOwed = calcValueInBase(debtAsset, _interestPayment); // Back to base
        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {
            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); // Get value of Synth in debtAsset (doubleSwap)
        }
    }
    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);
        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; 
    }
    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);
        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);
        return (_debtIssued * 10000) / _debtDepth; 
    }

    //====================================CORE-MATH====================================//

    function calcPart(uint bp, uint total) public pure returns (uint){
        // 10,000 basis points = 100.00%
        require((bp <= 10000) && (bp >= 0), ""Must be correct BP"");
        return calcShare(bp, 10000, total);
    }

    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){
        // share = amount * part/total
        if(part > total){
            part = total;
        }
        if(total > 0){
            share = (amount * part) / total;
        }
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){
        // y = (x * X * Y )/(x + X)^2
        uint numerator = (x * X * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){
        // fee = (x * x * Y) / (x + X)^2
        uint numerator = (x * x * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }
    function calcSwapSlip(uint x, uint X) external pure returns (uint){
        // slip = (x) / (x + X)
        return (x*10000) / (x + X);
    }

    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){
        if(P == 0){
            return b;
        } else {
            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment
            // P * (part1 + part2) / (part3) * slipAdjustment
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = (t * B);
            uint part2 = (T * b);
            uint part3 = (T * B) * 2;
            uint _units = (((P * part1) + part2) / part3);
            return (_units * slipAdjustment) / one;  // Divide by 10**18
        }
    }

    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){
        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))
        // 1 - ABS(part1 - part2)/(part3 * part4))
        uint part1 = B * t;
        uint part2 = b * T;
        uint part3 = (b * 2) + B;
        uint part4 = t + T;
        uint numerator;
        if(part1 > part2){
            numerator = (part1 - part2);
        } else {
            numerator = (part2 - part1);
        }
        uint denominator = (part3 * part4);
        return one - (numerator * one) / denominator; // Multiply by 10**18
    }

    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){
        // (P * b)/(2*(b + B))
        return (P * b) / (2 * (b + B));
    }

    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){
        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3
        // (part1 * (part2 - part3 + part4)) / part5
        uint part1 = (u * A);
        uint part2 = ((U * U) * 2);
        uint part3 = ((U * u) * 2);
        uint part4 = (u * u);
        uint numerator = ((part1 * part2) - part3) + part4;
        uint part5 = ((U * U) * U);
        return (numerator / part5);
    }
    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){
        if(B0 > 0 && T1 > 0){
            uint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)
            uint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)
            if(_redemptionValue <= _depositValue){
                coverage = (_depositValue - _redemptionValue);
            }
        }
    }

    // Sorts array in memory from low to high, returns in-memory (Does not need to modify storage)
    function sortArray(uint[] memory array) external pure returns (uint[] memory) {
        uint l = array.length;
        for(uint i = 0; i < l; i++){
            for(uint j = i+1; j < l; j++){
                if(array[i] > array[j]){
                    uint temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }

}",3621.0,302.0,"[H-07] Wrong calcAsymmetricShare calculation
The inline-comment defines the number of asymmetric shares as (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3 but the Utils.calcAsymmetricShare function computes (uA * 2U^2 - 2uU + u^2) / U^3 which is not equivalent as can be seen from the A^2 term in the first term which does not occur in the second one.
The associativity on P * part1 is wrong, and part2 is not multiplied by P.
The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up.
  [H-08] Wrong liquidity units calculation
The spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments.
The associativity on P * part1 is wrong, and part2 is not multiplied by P.
The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.
  [M-05] Interest debt is capped after a year
The `Utils.getInterestOwed `function computes the _interestPayment as: However, calcShare caps timeElpased to _year and therefore the owed interest does not grow after a year has elapsed. The impact is probably small because the only call so far computes the elapsed time as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];` which most likely will never go beyond a year.   [M-09] Divide before multiply
Can't quite understand the assertion that a division is made before a multiply in the code outlined ```uint _units = (((P * part1) + part2) / part3);
    return (_units * slipAdjustment) / one;  // Divide by 10**18 ```   [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas function init()",5.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Utils {

    uint private one = 10**18;
    uint private _10k = 10000;
    uint private _year = 31536000; 

    bool private inited;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    constructor () {}

    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        POOLS = _pools;
        FACTORY = _factory;
    }
    
    
    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){
        return calcShare(totalSupply, maxSupply, 100); 
    }

    function assetChecks(address collateralAsset, address debtAsset) external {
        if(collateralAsset == VADER){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); 
        } else if(collateralAsset == USDV){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); 
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAnchor(debtAsset), ""Bad Combo""); 
        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){
            require(iPOOLS(POOLS).isAsset(debtAsset), ""Bad Combo""); 
        }
    }

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    

    function calcValueInBase(address token, uint amount) public view returns (uint value){
       (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
       if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _baseAmt) / _tokenAmt;
       }
    }

    function calcValueInToken(address token, uint amount) public view returns (uint value){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        if(_baseAmt > 0 && _tokenAmt > 0){
            return (amount * _tokenAmt) / _baseAmt;
       }
    }
    function calcValueOfTokenInToken(address token1, uint amount, address token2) public view returns (uint value){
            return calcValueInToken(token2, calcValueInBase(token1, amount));
    }

    function calcSwapValueInBase(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _tokenAmt, _baseAmt);
    }
    function calcSwapValueInToken(address token, uint amount) public view returns (uint){
        (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);
        return calcSwapOutput(amount, _baseAmt, _tokenAmt);
    }

    function requirePriceBounds(address token, uint bound, bool inside, uint targetPrice) external view {
        uint _testingPrice = calcValueInBase(token, one);
        uint _lower = calcPart((_10k - bound), targetPrice);                
        uint _upper = (targetPrice * (_10k + bound)) / _10k;                
        if(inside){
            require((_testingPrice >= _lower && _testingPrice <= _upper), ""Not inside"");
        } else {
            require((_testingPrice <= _lower || _testingPrice >= _upper), ""Not outside"");
        }
    }

    

    function getRewardShare(address token, uint rewardReductionFactor) external view returns (uint rewardShare) {
        if(iVADER(VADER).emitting() && iROUTER(ROUTER).isCurated(token)){
            uint _baseAmount = iPOOLS(POOLS).getBaseAmount(token);
            if (iPOOLS(POOLS).isAsset(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledUSDV(), iROUTER(ROUTER).reserveUSDV());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            } else if(iPOOLS(POOLS).isAnchor(token)) {
                uint _share = calcShare(_baseAmount, iPOOLS(POOLS).pooledVADER(), iROUTER(ROUTER).reserveVADER());
                rewardShare = getReducedShare(_share, rewardReductionFactor);
            }
        }
    }

    function getReducedShare(uint amount, uint rewardReductionFactor) public pure returns(uint) {
        return calcShare(1, rewardReductionFactor, amount); 
    }

    

    
    function getProtection(address member, address token, uint basisPoints, uint timeForFullProtection) public view returns(uint protection) {
        uint _coverage = getCoverage(member, token);
        if(iROUTER(ROUTER).isCurated(token)){
            uint _duration = block.timestamp - iROUTER(ROUTER).getMemberLastDeposit(member, token);
            if(_duration <= timeForFullProtection) {
                protection = calcShare(_duration, timeForFullProtection, _coverage); 
            } else {
                protection = _coverage;
            }
        }
        return calcPart(basisPoints, protection);
    }
    
    function getCoverage(address member, address token) public view returns (uint) {
        uint _B0 = iROUTER(ROUTER).getMemberBaseDeposit(member, token); uint _T0 = iROUTER(ROUTER).getMemberTokenDeposit(member, token);
        uint _units = iPOOLS(POOLS).getMemberUnits(token, member);
        uint _B1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getBaseAmount(token));
        uint _T1 = calcShare(_units, iPOOLS(POOLS).getUnits(token), iPOOLS(POOLS).getTokenAmount(token));
        return calcCoverage(_B0, _T0, _B1, _T1);
    }

    

    function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {
        uint _collateralAdjusted = (collateral * 6666) / 10000; 
        if(isBase(collateralAsset)){
            baseValue = _collateralAdjusted;
        }else if(isPool(collateralAsset)){
            baseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); 
        }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){
            baseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); 
        }
        debt = calcSwapValueInToken(debtAsset, baseValue);        
        return (debt, baseValue);
    }

    function getDebtValueInCollateral(address member, uint debt, address collateralAsset, address debtAsset) external view returns(uint, uint) {
        uint _memberDebt = iROUTER(ROUTER).getMemberDebt(member, collateralAsset, debtAsset); 
        uint _memberCollateral = iROUTER(ROUTER).getMemberCollateral(member, collateralAsset, debtAsset); 
        uint _collateral = iROUTER(ROUTER).getSystemCollateral(collateralAsset, debtAsset);
        uint _interestPaid = iROUTER(ROUTER).getSystemInterestPaid(collateralAsset, debtAsset);
        uint _memberInterestShare = calcShare(_memberCollateral, _collateral, _interestPaid); 
        uint _collateralUnlocked = calcShare(debt, _memberDebt, _memberCollateral); 
        return (_collateralUnlocked, _memberInterestShare);
    }

    function getInterestOwed(address collateralAsset, address debtAsset, uint timeElapsed) external view returns(uint interestOwed) {
        uint _interestPayment = calcShare(timeElapsed, _year, getInterestPayment(collateralAsset, debtAsset)); 
        if(isBase(collateralAsset)){
            interestOwed = calcValueInBase(debtAsset, _interestPayment); 
        } else if(iFACTORY(FACTORY).isSynth(collateralAsset)) {
            interestOwed = calcValueOfTokenInToken(debtAsset, _interestPayment, collateralAsset); 
        }
    }
    function getInterestPayment(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtLoading = getDebtLoading(collateralAsset, debtAsset);
        return (_debtLoading * iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset)) / 10000; 
    }
    function getDebtLoading(address collateralAsset, address debtAsset) public view returns(uint) {
        uint _debtIssued = iROUTER(ROUTER).getSystemDebt(collateralAsset, debtAsset);
        uint _debtDepth = iPOOLS(POOLS).getTokenAmount(debtAsset);
        return (_debtIssued * 10000) / _debtDepth; 
    }

    

    function calcPart(uint bp, uint total) public pure returns (uint){
        
        require((bp <= 10000) && (bp >= 0), ""Must be correct BP"");
        return calcShare(bp, 10000, total);
    }

    function calcShare(uint part, uint total, uint amount) public pure returns (uint share){
        
        if(part > total){
            part = total;
        }
        if(total > 0){
            share = (amount * part) / total;
        }
    }

    function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){
        
        uint numerator = (x * X * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }

    function calcSwapFee(uint x, uint X, uint Y) external pure returns (uint){
        
        uint numerator = (x * x * Y);
        uint denominator = (x + X) * (x + X);
        return (numerator / denominator);
    }
    function calcSwapSlip(uint x, uint X) external pure returns (uint){
        
        return (x*10000) / (x + X);
    }

    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){
        if(P == 0){
            return b;
        } else {
            
            
            uint slipAdjustment = getSlipAdustment(b, B, t, T);
            uint part1 = (t * B);
            uint part2 = (T * b);
            uint part3 = (T * B) * 2;
            uint _units = (((P * part1) + part2) / part3);
            return (_units * slipAdjustment) / one;  
        }
    }

    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){
        
        
        uint part1 = B * t;
        uint part2 = b * T;
        uint part3 = (b * 2) + B;
        uint part4 = t + T;
        uint numerator;
        if(part1 > part2){
            numerator = (part1 - part2);
        } else {
            numerator = (part2 - part1);
        }
        uint denominator = (part3 * part4);
        return one - (numerator * one) / denominator; 
    }

    function calcSynthUnits(uint b, uint B, uint P) external pure returns(uint){
        
        return (P * b) / (2 * (b + B));
    }

    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){
        
        
        uint part1 = (u * A);
        uint part2 = ((U * U) * 2);
        uint part3 = ((U * u) * 2);
        uint part4 = (u * u);
        uint numerator = ((part1 * part2) - part3) + part4;
        uint part5 = ((U * U) * U);
        return (numerator / part5);
    }
    function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){
        if(B0 > 0 && T1 > 0){
            uint _depositValue = B0 + (T0 * B1) / T1; 
            uint _redemptionValue = B1 + (T1 * B1) / T1; 
            if(_redemptionValue <= _depositValue){
                coverage = (_depositValue - _redemptionValue);
            }
        }
    }

    
    function sortArray(uint[] memory array) external pure returns (uint[] memory) {
        uint l = array.length;
        for(uint i = 0; i < l; i++){
            for(uint j = i+1; j < l; j++){
                if(array[i] > array[j]){
                    uint temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
        }
        return array;
    }

}",3097.0,2,3,"Here is a list of vulnerabilities and potential issues in the provided smart contract:

---

### 1. **Uninitialized State Variables**
   - The `inited` variable is used to ensure the contract is initialized only once, but the `init` function can be called by anyone. This could lead to reinitialization attacks if not properly restricted.
   - The `VADER`, `USDV`, `ROUTER`, `POOLS`, and `FACTORY` addresses are set during initialization, but there is no check to ensure these addresses are valid (e.g., non-zero addresses).

---

### 2. **Lack of Input Validation**
   - The `init` function does not validate the input addresses (`_vader`, `_usdv`, `_router`, `_pools`, `_factory`). Passing zero addresses or invalid addresses could lead to unexpected behavior.
   - Functions like `calcPart`, `calcShare`, and `calcSwapOutput` do not validate inputs for edge cases (e.g., zero values or division by zero).

---

### 3. **Division Precision Loss**
   - The contract frequently uses integer division, which can lead to precision loss. For example:
     - In `calcValueInBase` and `calcValueInToken`, division is performed without considering rounding errors.
     - In `calcSwapOutput`, the result of division may lose precision due to integer arithmetic.

---

### 4. **Reentrancy Risk**
   - While no external calls are made directly in this contract, the contract interacts with external contracts (e.g., `iPOOLS`, `iROUTER`, `iFACTORY`). If these external contracts are malicious or vulnerable, reentrancy attacks could occur.

---

### 5. **Incorrect Return Value in `isBase`**
   - The `isBase` function does not return a value in all code paths. If the `token` is neither `VADER` nor `USDV`, the function will not return any value, which could lead to undefined behavior.

---

### 6. **Incorrect Return Value in `isPool`**
   - The `isPool` function does not return a value in all code paths. If the `token` is neither an anchor nor an asset, the function will not return any value, which could lead to undefined behavior.

---

### 7. **Potential Integer Overflow/Underflow**
   - The contract uses Solidity 0.8.3, which has built-in overflow/underflow checks. However, some calculations (e.g., `calcSwapOutput`, `calcLiquidityUnits`) involve large multiplications and divisions, which could still lead to unexpected behavior if not carefully handled.

---

### 8. **Incorrect Logic in `calcCoverage`**
   - The `calcCoverage` function calculates coverage based on deposit and redemption values. However, the logic may not handle all edge cases correctly, such as when `T1` is zero or when `_redemptionValue` is greater than `_depositValue`.

---

### 9. **Unused Variables**
   - The variables `one`, `_10k`, and `_year` are defined but not used in the contract. This could indicate incomplete or unused functionality.

---

### 10. **Lack of Access Control**
   - The `init` function can be called by anyone, which could lead to unauthorized initialization of the contract. There is no access control mechanism to restrict this function to the contract owner or an authorized address.

---

### 11. **Incorrect Fee Calculation in `getFeeOnTransfer`**
   - The `getFeeOnTransfer` function always returns a fixed value of 100, which may not be the intended behavior. This could lead to incorrect fee calculations.

---

### 12. **Incorrect Logic in `requirePriceBounds`**
   - The `requirePriceBounds` function checks if a price is inside or outside a specified range. However, the logic for calculating `_lower` and `_upper` bounds may not be correct for all cases, especially when `bound` is zero.

---

### 13. **Incorrect Logic in `getRewardShare`**
   - The `getRewardShare` function calculates reward shares based on pool amounts and reserves. However, the logic may not handle edge cases correctly, such as when `_baseAmount` or `pooledUSDV` is zero.

---

### 14. **Incorrect Logic in `getProtection`**
   - The `getProtection` function calculates protection based on coverage and duration. However, the logic may not handle edge cases correctly, such as when `timeForFullProtection` is zero.

---

### 15. **Incorrect Logic in `getCollateralValueInBase`**
   - The `getCollateralValueInBase` function adjusts collateral by a fixed factor (6666 / 10000). This hardcoded value may not be appropriate for all scenarios and could lead to incorrect calculations.

---

### 16. **Incorrect Logic in `getDebtValueInCollateral`**
   - The `getDebtValueInCollateral` function calculates unlocked collateral and interest share. However, the logic may not handle edge cases correctly, such as when `_memberDebt` or `_collateral` is zero.

---

### 17. **Incorrect Logic in `getInterestOwed`**
   - The `getInterestOwed` function calculates interest owed based on time elapsed and interest payment. However, the logic may not handle edge cases correctly, such as when `timeElapsed` is zero.

---

### 18. **Incorrect Logic in `calcLiquidityUnits`**
   - The `calcLiquidityUnits` function calculates liquidity units based on pool amounts and slip adjustment. However, the logic may not handle edge cases correctly, such as when `P` is zero.

---

### 19. **Incorrect Logic in `calcAsymmetricShare`**
   - The `calcAsymmetricShare` function calculates an asymmetric share based on pool amounts. However, the logic may not handle edge cases correctly, such as when `U` or `A` is zero.

---

### 20. **Gas Inefficiency**
   - The contract uses nested loops in the `sortArray` function, which could lead to high gas costs for large arrays. This could make the function unusable for large datasets.

---

### 21. **Lack of Error Messages**
   - Many `require` statements do not include descriptive error messages, making it difficult to debug issues when the contract reverts.

---

### 22. **Unused Imports**
   - The contract imports several interfaces (`iERC20`, `iVADER`, `iROUTER`, `iPOOLS`, `iFACTORY`, `iSYNTH`) and the `hardhat/console.sol` library, but some of these may not be used in the contract. Unused imports increase deployment costs and complexity.

---

### 23. **Hardcoded Values**
   - The contract uses hardcoded values (e.g., `6666 / 10000` in `getCollateralValueInBase`), which reduces flexibility and could lead to incorrect calculations if the values are not appropriate for all scenarios.

---

### 24. **Incorrect Logic in `calcSwapSlip`**
   - The `calcSwapSlip` function calculates slippage based on input amounts. However, the logic may not handle edge cases correctly, such as when `x` or `X` is zero.

---

### 25. **Incorrect Logic in `calcSwapFee`**
   - The `calcSwapFee` function calculates swap fees based on input amounts. However, the logic may not handle edge cases correctly, such as when `x` or `X` is zero.","### **[H-07] Wrong calcAsymmetricShare calculation**

**Report Description**:
The `calcAsymmetricShare` function in `Utils.sol` incorrectly implements the mathematical formula defined in the spec. The inline-comment defines the number of asymmetric shares as `(u * U * (2 * A^2 - 2 * U * u + U^2))/U^3`, but the function computes `(uA * 2U^2 - 2uU + u^2) / U^3`. The discrepancy arises from the missing `A^2` term in the function's implementation. Additionally, the associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`. This incorrect implementation could lead to economic exploitation of the protocol, as the asymmetric share (used to determine collateral value in base tokens) may be miscalculated, potentially allowing users to borrow more than the collateral they provide.

**Match in Response List**:
Matches with the issue titled **""Incorrect Logic in `calcAsymmetricShare`""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the incorrect logic in the `calcAsymmetricShare` function. It correctly highlights the potential for edge cases (e.g., when `U` or `A` is zero) and aligns with the report's concern about the incorrect implementation of the mathematical formula.

---

### **[H-08] Wrong liquidity units calculation**

**Report Description**:
The `calcLiquidityUnits` function in `Utils.sol` incorrectly implements the mathematical formula defined in the spec. The spec defines the number of LP units to be minted as `units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments`, but the function computes `((P * part1) + part2) / part3 * slipAdjustments`. The associativity on `P * part1` is wrong, and `part2` is not multiplied by `P`. This incorrect implementation could lead to economic exploitation of the protocol, as redeeming the minted LP tokens may not return the initial tokens.

**Match in Response List**:
Matches with the issue titled **""Incorrect Logic in `calcLiquidityUnits`""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the incorrect logic in the `calcLiquidityUnits` function. It correctly highlights the potential for edge cases (e.g., when `P` is zero) and aligns with the report's concern about the incorrect implementation of the mathematical formula.

---

### **[M-05] Interest debt is capped after a year**

**Report Description**:
The `Utils.getInterestOwed` function caps the `timeElapsed` to `_year`, meaning the owed interest does not grow after a year has elapsed. While the impact is likely small because the elapsed time is calculated as `block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset]` (which is unlikely to exceed a year), this design choice could still lead to incorrect interest calculations in edge cases.

**Match in Response List**:
Matches with the issue titled **""Incorrect Logic in `getInterestOwed`""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the incorrect logic in the `getInterestOwed` function. It correctly highlights the potential for edge cases (e.g., when `timeElapsed` is zero) and aligns with the report's concern about the capped interest calculation.

---

### **[M-09] Divide before multiply**

**Report Description**:
The code snippet `uint _units = (((P * part1) + part2) / part3); return (_units * slipAdjustment) / one;` performs division before multiplication, which can lead to precision loss. This issue is not fully understood in the report, but the concern is valid as division before multiplication can result in incorrect calculations due to integer arithmetic in Solidity.

**Match in Response List**:
Matches with the issue titled **""Division Precision Loss""**.

**Validation**:
**Partially Correct**. The response correctly identifies the issue of precision loss due to division before multiplication. However, it does not specifically address the code snippet in question, making the match partially correct.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
The `init` function in most Solidity contracts can be called by anyone, leading to a race condition when the contract is deployed. A hacker could call the `init` function and make the deployed contracts useless, requiring redeployment and incurring significant gas costs.

**Match in Response List**:
Matches with the issue titled **""Lack of Access Control""**.

**Validation**:
**Correct**. The response accurately identifies the issue with the lack of access control in the `init` function. It correctly highlights the risk of unauthorized initialization and aligns with the report's concern about potential race conditions.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[H-07] Wrong calcAsymmetricShare calculation**
- **[H-08] Wrong liquidity units calculation**
- **[M-05] Interest debt is capped after a year**
- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- **[M-09] Divide before multiply**

**Missed Issues from Issue Report**:

- *None*

--- 

The responses in `response_list` effectively cover the issues in `issue`, with most matches being correct. The only partially correct match is for **[M-09]**, where the response identifies the general issue of precision loss but does not specifically address the code snippet in question. Overall, the `response_list` demonstrates a strong understanding of the vulnerabilities and risks in the provided smart contract.",4,1,0,25,"```
1. Incorrect Logic in `calcAsymmetricShare`
2. Incorrect Logic in `calcLiquidityUnits`
3. Incorrect Logic in `getInterestOwed`
4. Lack of Access Control
```","To calculate the **Average Precision (AP)**, we follow these steps:

1. **Identify the ranks of the true positives in the ranked list of predictions**:
   - ""Incorrect Logic in `calcAsymmetricShare`"" appears at rank **19**.
   - ""Incorrect Logic in `calcLiquidityUnits`"" appears at rank **18**.
   - ""Incorrect Logic in `getInterestOwed`"" appears at rank **17**.
   - ""Lack of Access Control"" appears at rank **10**.

2. **Calculate the precision at each rank**:
   - At rank **10**: \( P@10 = \frac{1}{10} = 0.1 \)
   - At rank **17**: \( P@17 = \frac{2}{17} \approx 0.118 \)
   - At rank **18**: \( P@18 = \frac{3}{18} \approx 0.167 \)
   - At rank **19**: \( P@19 = \frac{4}{19} \approx 0.211 \)

3. **Average the precision values**:
   \[
   AP = \frac{0.1 + 0.118 + 0.167 + 0.211}{4} \approx \frac{0.596}{4} \approx 0.149
   \]

**Average Precision (AP)**: **0.149**"
Router.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Router {

    // Parameters
    bool private inited;
    uint one = 10**18;
    uint public rewardReductionFactor;
    uint public timeForFullProtection;

    uint public curatedPoolLimit;
    uint public curatedPoolCount;
    mapping(address => bool) private _isCurated;
    
    address public VADER;
    address public USDV;
    address public POOLS;

    uint public anchorLimit;
    uint public insidePriceLimit;
    uint public outsidePriceLimit;
    address[] public arrayAnchors;
    uint[] public arrayPrices;

    uint public repayDelay = 3600;

    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;
    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;
    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;

    mapping(address => CollateralDetails) private mapMember_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; 
    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;

    struct CollateralDetails {
        uint ID;
        mapping(address => DebtDetails) mapCollateral_Debt;
    }
    struct DebtDetails{
        uint ID;
        mapping(address =>uint) debt; //assetC > AssetD > AmountDebt
        mapping(address =>uint) collateral; //assetC > AssetD > AmountCol
        // mapping(address =>uint) assetCollateralDeposit; //assetC > AssetD > AmountCol
        // mapping(address =>uint) timeBorrowed; // assetC > AssetD > time
        // mapping(address =>uint) currentDay; // assetC > AssetD > time
    }

    event PoolReward(address indexed base, address indexed token, uint amount);
    event Protection(address indexed member, uint amount);
    event Curated(address indexed curator, address indexed token);

    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);
    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    //=====================================CREATION=========================================//
    // Constructor
    constructor() {}
    // Init
    function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;//8640000; //100 days
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {
        rewardReductionFactor = newFactor;
        timeForFullProtection = newTime;
        curatedPoolLimit = newLimit;
    }
    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {
        anchorLimit = newLimit;
        insidePriceLimit = newInside;
        outsidePriceLimit = newOutside;
    }

    //====================================LIQUIDITY=========================================//

    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){
        uint _actualInputBase = moveTokenToPools(base, inputBase);
        uint _actualInputToken = moveTokenToPools(token, inputToken);
        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); 
        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {
        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);
        uint _protection = getILProtection(msg.sender, base, token, basisPoints);
        removeDepositData(msg.sender, token, basisPoints, _protection); 
        iERC20(base).transfer(msg.sender, _protection);
    }

      //=======================================SWAP===========================================//
    
    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);
    }
    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);
    }

    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);
    }

    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {
        address _member = msg.sender;
        if(!inSynth){
            moveTokenToPools(inputToken, inputAmount);
        } else {
            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);
        }
        address _base;
        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {
            _base = VADER;
        } else {
            _base = USDV;
        }
        if (isBase(outputToken)) {
            // Token||Synth -> BASE
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);
            } else {
                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);
            }
        } else if (isBase(inputToken)) {
            // BASE -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        } else if (!isBase(inputToken) && !isBase(outputToken)) {
            // Token||Synth -> Token||Synth
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);
            } else {
                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);
            }
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        }
        _handlePoolReward(_base, inputToken);
        _handlePoolReward(_base, outputToken);
        _handleAnchorPriceUpdate(inputToken);
        _handleAnchorPriceUpdate(outputToken); 
    }

    //====================================INCENTIVES========================================//

    function _handlePoolReward(address _base, address _token) internal{
        if(!isBase(_token)){                        // USDV or VADER is never a pool
            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);
            iERC20(_base).transfer(POOLS, _reward);
            iPOOLS(POOLS).sync(_base, _token);
            emit PoolReward(_base, _token, _reward);
        }
    }

    //=================================IMPERMANENT LOSS=====================================//
    
    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {
        mapMemberToken_depositBase[member][token] += amountBase;
        mapMemberToken_depositToken[member][token] += amountToken;
        mapMemberToken_lastDeposited[member][token] = block.timestamp;
    }
    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {
        mapMemberToken_depositBase[member][token] += protection;
        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);
        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);
        mapMemberToken_depositBase[member][token] -= _baseToRemove;
        mapMemberToken_depositToken[member][token] -= _tokenToRemove;
    }

    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {
        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);
        if(base == VADER){
            if(protection >= reserveVADER()){
                protection = reserveVADER(); // In case reserve is running out
            }
        } else {
            if(protection >= reserveUSDV()){
                protection = reserveUSDV(); // In case reserve is running out
            }
        }
    }
    
    //=====================================CURATION==========================================//

    function curatePool(address token) external {
        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));
        if(!isCurated(token)){
            if(curatedPoolCount < curatedPoolLimit){ // Limit
                _isCurated[token] = true;
                curatedPoolCount += 1;
            }
        }
        emit Curated(msg.sender, token);
    }
    function replacePool(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAsset(newToken));
        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ // Must be deeper
            _isCurated[oldToken] = false;
            _isCurated[newToken] = true;
            emit Curated(msg.sender, newToken);
        }
    }

    //=====================================ANCHORS==========================================//

    function listAnchor(address token) external {
        require(arrayAnchors.length < anchorLimit); // Limit
        require(iPOOLS(POOLS).isAnchor(token));     // Must be anchor
        arrayAnchors.push(token);                   // Add
        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));
        _isCurated[token] = true; 
        updateAnchorPrice(token);
    }

    function replaceAnchor(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAnchor(newToken), ""Not anchor"");
        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), ""Not deeper"");
        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             // if price oldToken >5%
        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               // if price newToken <2%
        _isCurated[oldToken] = false; 
        _isCurated[newToken] = true; 
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == oldToken){
                arrayAnchors[i] = newToken;
            }
        }
        updateAnchorPrice(newToken);
    }

    // Anyone to update prices
    function updateAnchorPrice(address token) public {
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == token){
                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);
            }
        }
    }

    function _handleAnchorPriceUpdate(address _token) internal{
        if(iPOOLS(POOLS).isAnchor(_token)){
            updateAnchorPrice(_token);
        }
    }

    // Price of 1 VADER in USD
    function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  // Sort price array, no need to modify storage
            anchorPrice = _sortedAnchorFeed[2];                         // Return the middle
        } else {
            anchorPrice = one;          // Edge case for first USDV mint
        }
    }

    // The correct amount of Vader for an input of USDV
    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){
        uint _price = getAnchorPrice();
        return (_price * USDVAmount) / one;
    }

    // The correct amount of USDV for an input of VADER
    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){
        uint _price = getAnchorPrice();
        return (vaderAmount * one) / _price;
    }
    
    
    //======================================LENDING=========================================//

    // Draw debt for self
    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {
        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);
    }

    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {
        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);
        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  // get collateral 
        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               // Record collateral 
        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            // Record debt
        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    // Update member details
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  // Send to pools
            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         // Execute swap to member
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  // Send to pools
            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         // Execute swap to member
        }
        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               // Event
        payInterest(collateralAsset, debtAsset);
        return _debtIssued;
    }

    // Repay for self
    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){
        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);
    }
     // Repay for member
    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){
        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));
        uint _debt = moveTokenToPools(debtAsset, _amount);    // Get Debt
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           // Swap Debt to Base back here
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           // Swap Debt to Base back here
        }
        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); // Unlock collateral that is pro-rata to re-paid debt ($50/$100 = 50%)
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               // Update collateral 
        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   // Update debt 
        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;
        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  // Remove
        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);
        _handleTransferOut(member, collateralAsset, _collateralUnlocked);
        payInterest(collateralAsset, debtAsset);
        return _collateralUnlocked;
    }

    // Called once a day to pay interest
    function payInterest(address collateralAsset, address debtAsset) internal {
        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              // If new Era
            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];
            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);
            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;
            _removeCollateral(_interestOwed, collateralAsset, debtAsset);
            if(isBase(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).sync(collateralAsset, debtAsset);
            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());
            }
        }
    }

    function checkLiquidate() public {
        // get member remaining Collateral: originalDeposit - shareOfInterestPayments
        // if remainingCollateral <= 101% * debtValueInCollateral
        // purge, send remaining collateral to liquidator
    }

    // function purgeMember() public {

    // }

    // Get Collateral
    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _inputAmount = _getFunds(_collateralAsset, _amount); // Get funds
        }else if(isPool(_collateralAsset)){
             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); // Lock units to protocol
             _inputAmount = _amount;
        }
    }
    // Send Collateral
    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _sendFunds(_collateralAsset, _member, _amount); // Send Base
        }else if(isPool(_collateralAsset)){
            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); // Unlock units to member
        }
    }

    function _getFunds(address _token, uint _amount) internal returns(uint) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(tx.origin==msg.sender){
            require(iERC20(_token).transferTo(address(this), _amount));
        }else{
            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));
        }
        return iERC20(_token).balanceOf(address(this)) - _balance;
    }

    function _sendFunds(address _token, address _member, uint _amount) internal {
        require(iERC20(_token).transfer(_member, _amount));
    }

    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;
    }
    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;
    }
    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {
        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               // Record collateral 
    }



    //======================================HELPERS=========================================//

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }

    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this));
    }
    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this));
    }

    // Optionality
    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {
        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){
            safeAmount = _amount;
            if(tx.origin==msg.sender){
                iERC20(_token).transferTo(POOLS, _amount);
            }else{
                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            }
        } else {
            uint _startBal = iERC20(_token).balanceOf(POOLS);
            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;
        }
    }

    

    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function isCurated(address token) public view returns(bool curated) {
        if(_isCurated[token]){
            curated = true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    function getMemberBaseDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositBase[member][token];
    }
    function getMemberTokenDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositToken[member][token];
    }
    function getMemberLastDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_lastDeposited[member][token];
    }
    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];
    }
    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];
    }
    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];
    }
    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Debt[collateralAsset][debtAsset];
    }
    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];
    }
    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];
    }
}",5851.0,511.0,"[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol
Incorrect initialization of timeForFullProtection to 1 sec instead of 8640000 secs (100 days) as indicated in code comments, appears to be a test setting mistakenly carried over for deployment. Therefore, unless timeForFullProtection is reset to 100 days by setParams() (calling this function is a missing functionality in the DAO currently), the Impermanent Loss (IL) protection ""rule"" of 100 days will not apply in Utils.getProtection().
This breaks a key value proposition of the Vader protocol which is IL protection as indicated in the specification:
“Impermanent Loss Protection: The deposit value for each member is recorded when they deposit. When they go to withdraw, the redemption value is computed. If it is less than the deposit value, the member is paid the deficit from the reserve. The protection issued increases from 0 to 100% linearly for 100 days.”
Recommend changing to “timeForFullProtection = 8640000; //100 days”  on L84
  [H-10] Anyone can list anchors / curate tokens
The `Router.listAnchor` function can be called by anyone and tokens can be added. The only check is that `require(iPOOLS(POOLS).isAnchor(token));` but this can easily be set by calling `Pools.addLiquidity(VADER, token, _)` once even without actually sending any tokens to the contract. This makes it an essentially useless check.
This only works initially as long as the `anchorLimit` has not been reached yet. However, the `replaceAnchor` can be used in the same way and flash loans can be used to get around the liquidity restrictions and push another anchor token out of the price range as these checks use the current reserves.
Anchored pools are automatically curated pools and determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control. After a pool has been anchored through flash loans, liquidity can be withdrawn which could make the anchor price easy to manipulate in the next block and launch other attacks.
Recommend revisiting the `_isAnchor[token] = true;` statement in addLiquidity, it seems strange without any further checks. Consider making listAnchor / replaceAnchor DAO-only functions and make them flash-loan secure. One should probably use time-weighted prices for these pools for the bounds check.
  [H-15] Wrong slippage protection on Token -> Token trades
The Router.swapWithSynthsWithLimit allows trading token to token and specifying slippage protection. A token to token trade consists of two trades:
(1) token to base
(2) base to token The slippage protection of the second trade (base to token) is computed wrong: ```
require(iUTILS(UTILS()).calcSwapSlip(
    inputAmount, // should use outToken here from prev trade
    iPOOLS(POOLS).getBaseAmount(outputToken)
  ) <= slipLimit
) ``` It compares the token input amount (of the first trade) to the base reserve of the second pair.
Slippage protection fails and either the trade is cancelled when it shouldn't be or it is accepted even though the user suffered more losses than expected.
Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.
  [H-23] Anyone can curate pools and steal rewards
The `Router.curatePool` and `replacePool` don't have any access restriction. An attacker can get a flash loan of base tokens and replace existing curated pools with their own curated pools.
Curated pools determine if a pool receives rewards. An attacker can remove rewards of a curated pool this way and add rewards to their own pool with a custom token they control. They can then go ahead and game the reward system by repeatedly swapping in their custom pool with useless tokens, withdraw liquidity, and in the end, pay back the base flashloan.
Recommend preventing the replacing of curations through flash loans. Also, consider making pool curations DAO-exclusive actions.
  [M-03] Lack of input validation in replacePool() allows curated pool limit bypass in Router.sol
There is no input validation in `replacePool()` function to check if `oldToken` exists and is curated. Using a non-existing `oldToken` (even 0 address) passes the check on L236 (because `Pools.getBaseAmount()` will return 0 for the non-existing token) and newToken will be made curated. This can be used to bypass the `curatedPoolLimit` enforced only in `curatePool()` function.   [M-11] Allowing duplicated anchors could cause bias on anchor price.
In Router.sol, the setup of the five anchors can be interrupted by anyone adding a new anchor due to the lack of access control of the listAnchor function. Also, duplicate anchors are allowed. If the same anchor is added three times, then this anchor biases the result of getAnchorPrice. Referenced code: Router.sol#L245-L252
PoC: Link to PoC See the file 200_listAnchor.js for a PoC of this attack. To run it, use npx hardhat test 200_listAnchor.js.
Recommend only allowing listAnchor to be called from the deployer by adding a require statement. Also, check if an anchor is added before by require(_isCurated == false).
  [M-13] Init function can be called by everyone
Most of the solidity contracts have an init function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()",7.0,"pragma solidity 0.8.3;


import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iSYNTH.sol"";

import ""hardhat/console.sol"";

contract Router {

    
    bool private inited;
    uint one = 10**18;
    uint public rewardReductionFactor;
    uint public timeForFullProtection;

    uint public curatedPoolLimit;
    uint public curatedPoolCount;
    mapping(address => bool) private _isCurated;
    
    address public VADER;
    address public USDV;
    address public POOLS;

    uint public anchorLimit;
    uint public insidePriceLimit;
    uint public outsidePriceLimit;
    address[] public arrayAnchors;
    uint[] public arrayPrices;

    uint public repayDelay = 3600;

    mapping(address => mapping(address => uint)) public mapMemberToken_depositBase;
    mapping(address => mapping(address => uint)) public mapMemberToken_depositToken;
    mapping(address => mapping(address => uint)) public mapMemberToken_lastDeposited;

    mapping(address => CollateralDetails) private mapMember_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Collateral;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_Debt;
    mapping(address => mapping(address => uint)) private mapCollateralDebt_interestPaid; 
    mapping(address => mapping(address => uint)) private mapCollateralAsset_NextEra;

    struct CollateralDetails {
        uint ID;
        mapping(address => DebtDetails) mapCollateral_Debt;
    }
    struct DebtDetails{
        uint ID;
        mapping(address =>uint) debt; 
        mapping(address =>uint) collateral; 
        
        
        
    }

    event PoolReward(address indexed base, address indexed token, uint amount);
    event Protection(address indexed member, uint amount);
    event Curated(address indexed curator, address indexed token);

    event AddCollateral(address indexed member, address indexed collateralAsset, uint collateralLocked, address indexed debtAsset, uint debtIssued);
    event RemoveCollateral(address indexed member, address indexed collateralAsset, uint collateralUnlocked, address indexed debtAsset, uint debtReturned);

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    
    
    constructor() {}
    
    function init(address _vader, address _usdv, address _pool) public {
        require(inited == false,  ""inited"");
        inited = true;
        VADER = _vader;
        USDV = _usdv;
        POOLS = _pool;
        rewardReductionFactor = 1;
        timeForFullProtection = 1;
        curatedPoolLimit = 1;
        anchorLimit = 5;
        insidePriceLimit = 200;
        outsidePriceLimit = 500;
    }

    
    
    function setParams(uint newFactor, uint newTime, uint newLimit) external onlyDAO {
        rewardReductionFactor = newFactor;
        timeForFullProtection = newTime;
        curatedPoolLimit = newLimit;
    }
    function setAnchorParams(uint newLimit, uint newInside, uint newOutside) external onlyDAO {
        anchorLimit = newLimit;
        insidePriceLimit = newInside;
        outsidePriceLimit = newOutside;
    }

    

    function addLiquidity(address base, uint inputBase, address token, uint inputToken) external returns(uint){
        uint _actualInputBase = moveTokenToPools(base, inputBase);
        uint _actualInputToken = moveTokenToPools(token, inputToken);
        addDepositData(msg.sender, token, _actualInputBase, _actualInputToken); 
        return iPOOLS(POOLS).addLiquidity(base, token, msg.sender);
    }

    function removeLiquidity(address base, address token, uint basisPoints) external returns (uint amountBase, uint amountToken) {
        (amountBase, amountToken) = iPOOLS(POOLS).removeLiquidity(base, token, basisPoints);
        uint _protection = getILProtection(msg.sender, base, token, basisPoints);
        removeDepositData(msg.sender, token, basisPoints, _protection); 
        iERC20(base).transfer(msg.sender, _protection);
    }

      
    
    function swap(uint inputAmount, address inputToken, address outputToken) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, 10000);
    }
    function swapWithLimit(uint inputAmount, address inputToken, address outputToken, uint slipLimit) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, false, outputToken, false, slipLimit);
    }

    function swapWithSynths(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth) external returns (uint outputAmount) {
        return swapWithSynthsWithLimit(inputAmount, inputToken, inSynth, outputToken, outSynth, 10000);
    }

    function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {
        address _member = msg.sender;
        if(!inSynth){
            moveTokenToPools(inputToken, inputAmount);
        } else {
            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);
        }
        address _base;
        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {
            _base = VADER;
        } else {
            _base = USDV;
        }
        if (isBase(outputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);
            } else {
                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);
            }
        } else if (isBase(inputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        } else if (!isBase(inputToken) && !isBase(outputToken)) {
            
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);
            if(!inSynth){
                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);
            } else {
                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);
            }
            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);
            if(!outSynth){
                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);
            } else {
                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);
            }
        }
        _handlePoolReward(_base, inputToken);
        _handlePoolReward(_base, outputToken);
        _handleAnchorPriceUpdate(inputToken);
        _handleAnchorPriceUpdate(outputToken); 
    }

    

    function _handlePoolReward(address _base, address _token) internal{
        if(!isBase(_token)){                        
            uint _reward = iUTILS(UTILS()).getRewardShare(_token, rewardReductionFactor);
            iERC20(_base).transfer(POOLS, _reward);
            iPOOLS(POOLS).sync(_base, _token);
            emit PoolReward(_base, _token, _reward);
        }
    }

    
    
    function addDepositData(address member, address token, uint amountBase, uint amountToken) internal {
        mapMemberToken_depositBase[member][token] += amountBase;
        mapMemberToken_depositToken[member][token] += amountToken;
        mapMemberToken_lastDeposited[member][token] = block.timestamp;
    }
    function removeDepositData(address member, address token, uint basisPoints, uint protection) internal {
        mapMemberToken_depositBase[member][token] += protection;
        uint _baseToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositBase[member][token]);
        uint _tokenToRemove = iUTILS(UTILS()).calcPart(basisPoints, mapMemberToken_depositToken[member][token]);
        mapMemberToken_depositBase[member][token] -= _baseToRemove;
        mapMemberToken_depositToken[member][token] -= _tokenToRemove;
    }

    function getILProtection(address member, address base, address token, uint basisPoints) public view returns(uint protection) {
        protection = iUTILS(UTILS()).getProtection(member, token, basisPoints, timeForFullProtection);
        if(base == VADER){
            if(protection >= reserveVADER()){
                protection = reserveVADER(); 
            }
        } else {
            if(protection >= reserveUSDV()){
                protection = reserveUSDV(); 
            }
        }
    }
    
    

    function curatePool(address token) external {
        require(iPOOLS(POOLS).isAsset(token) || iPOOLS(POOLS).isAnchor(token));
        if(!isCurated(token)){
            if(curatedPoolCount < curatedPoolLimit){ 
                _isCurated[token] = true;
                curatedPoolCount += 1;
            }
        }
        emit Curated(msg.sender, token);
    }
    function replacePool(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAsset(newToken));
        if(iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)){ 
            _isCurated[oldToken] = false;
            _isCurated[newToken] = true;
            emit Curated(msg.sender, newToken);
        }
    }

    

    function listAnchor(address token) external {
        require(arrayAnchors.length < anchorLimit); 
        require(iPOOLS(POOLS).isAnchor(token));     
        arrayAnchors.push(token);                   
        arrayPrices.push(iUTILS(UTILS()).calcValueInBase(token, one));
        _isCurated[token] = true; 
        updateAnchorPrice(token);
    }

    function replaceAnchor(address oldToken, address newToken) external {
        require(iPOOLS(POOLS).isAnchor(newToken), ""Not anchor"");
        require((iPOOLS(POOLS).getBaseAmount(newToken) > iPOOLS(POOLS).getBaseAmount(oldToken)), ""Not deeper"");
        iUTILS(UTILS()).requirePriceBounds(oldToken, outsidePriceLimit, false, getAnchorPrice());                             
        iUTILS(UTILS()).requirePriceBounds(newToken, insidePriceLimit, true, getAnchorPrice());                               
        _isCurated[oldToken] = false; 
        _isCurated[newToken] = true; 
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == oldToken){
                arrayAnchors[i] = newToken;
            }
        }
        updateAnchorPrice(newToken);
    }

    
    function updateAnchorPrice(address token) public {
        for(uint i = 0; i<arrayAnchors.length; i++){
            if(arrayAnchors[i] == token){
                arrayPrices[i] = iUTILS(UTILS()).calcValueInBase(arrayAnchors[i], one);
            }
        }
    }

    function _handleAnchorPriceUpdate(address _token) internal{
        if(iPOOLS(POOLS).isAnchor(_token)){
            updateAnchorPrice(_token);
        }
    }

    
    function getAnchorPrice() public view returns (uint anchorPrice) {
        if(arrayPrices.length > 0){
            uint[] memory _sortedAnchorFeed = iUTILS(UTILS()).sortArray(arrayPrices);  
            anchorPrice = _sortedAnchorFeed[2];                         
        } else {
            anchorPrice = one;          
        }
    }

    
    function getVADERAmount(uint USDVAmount) public view returns (uint vaderAmount){
        uint _price = getAnchorPrice();
        return (_price * USDVAmount) / one;
    }

    
    function getUSDVAmount(uint vaderAmount) public view returns (uint USDVAmount){
        uint _price = getAnchorPrice();
        return (vaderAmount * one) / _price;
    }
    
    
    

    
    function borrow(uint amount, address collateralAsset, address debtAsset) public returns (uint) {
        return borrowForMember(msg.sender, amount, collateralAsset, debtAsset);
    }

    function borrowForMember(address member, uint amount, address collateralAsset, address debtAsset) public returns(uint) {
        iUTILS(UTILS()).assetChecks(collateralAsset, debtAsset);
        uint _collateral = _handleTransferIn(member, collateralAsset, amount);                  
        (uint _debtIssued, uint _baseBorrowed) = iUTILS(UTILS()).getCollateralValueInBase(member, _collateral, collateralAsset, debtAsset);
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] += _collateral;               
        mapCollateralDebt_Debt[collateralAsset][debtAsset] += _debtIssued;                            
        _addDebtToMember(member, _collateral, collateralAsset, _debtIssued, debtAsset);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iERC20(VADER).transfer(POOLS, _baseBorrowed);                                  
            iPOOLS(POOLS).swap(VADER, debtAsset, member, false);                         
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iERC20(USDV).transfer(POOLS, _baseBorrowed);                                  
            iPOOLS(POOLS).swap(USDV, debtAsset, member, false);                         
        }
        emit AddCollateral(member, collateralAsset, amount, debtAsset, _debtIssued);               
        payInterest(collateralAsset, debtAsset);
        return _debtIssued;
    }

    
    function repay(uint amount, address collateralAsset, address debtAsset) public returns (uint){
        return repayForMember(msg.sender, amount, collateralAsset, debtAsset);
    }
     
    function repayForMember(address member, uint basisPoints, address collateralAsset, address debtAsset) public returns (uint){
        uint _amount = iUTILS(UTILS()).calcPart(basisPoints, getMemberDebt(member, collateralAsset, debtAsset));
        uint _debt = moveTokenToPools(debtAsset, _amount);    
        if(collateralAsset == VADER || iPOOLS(POOLS).isAnchor(debtAsset)){
            iPOOLS(POOLS).swap(VADER, debtAsset, address(this), true);           
        } else if(collateralAsset == USDV || iPOOLS(POOLS).isAsset(debtAsset)) {
            iPOOLS(POOLS).swap(USDV, debtAsset, address(this), true);           
        }
        (uint _collateralUnlocked,  uint _memberInterestShare) = iUTILS(UTILS()).getDebtValueInCollateral(member, _debt, collateralAsset, debtAsset); 
        mapCollateralDebt_Collateral[collateralAsset][debtAsset] -= _collateralUnlocked;               
        mapCollateralDebt_Debt[collateralAsset][debtAsset] -= _debt;                   
        mapCollateralDebt_interestPaid[collateralAsset][debtAsset] -= _memberInterestShare;
        _removeDebtFromMember(member, _collateralUnlocked, collateralAsset, _debt, debtAsset);  
        emit RemoveCollateral(member, collateralAsset, _collateralUnlocked, debtAsset, _debt);
        _handleTransferOut(member, collateralAsset, _collateralUnlocked);
        payInterest(collateralAsset, debtAsset);
        return _collateralUnlocked;
    }

    
    function payInterest(address collateralAsset, address debtAsset) internal {
        if (block.timestamp >= getNextEraTime(collateralAsset, debtAsset) && emitting()) {                              
            uint _timeElapsed = block.timestamp - mapCollateralAsset_NextEra[collateralAsset][debtAsset];
            mapCollateralAsset_NextEra[collateralAsset][debtAsset] = block.timestamp + iVADER(VADER).secondsPerEra(); 
            uint _interestOwed = iUTILS(UTILS()).getInterestOwed(collateralAsset, debtAsset, _timeElapsed);
            mapCollateralDebt_interestPaid[collateralAsset][debtAsset] += _interestOwed;
            _removeCollateral(_interestOwed, collateralAsset, debtAsset);
            if(isBase(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).sync(collateralAsset, debtAsset);
            } else if(iPOOLS(POOLS).isSynth(collateralAsset)){
                iERC20(collateralAsset).transfer(POOLS, _interestOwed);
                iPOOLS(POOLS).syncSynth(iSYNTH(collateralAsset).TOKEN());
            }
        }
    }

    function checkLiquidate() public {
        
        
        
    }

    

    

    
    function _handleTransferIn(address _member, address _collateralAsset, uint _amount) internal returns(uint _inputAmount){
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _inputAmount = _getFunds(_collateralAsset, _amount); 
        }else if(isPool(_collateralAsset)){
             iPOOLS(POOLS).lockUnits(_amount, _collateralAsset, _member); 
             _inputAmount = _amount;
        }
    }
    
    function _handleTransferOut(address _member, address _collateralAsset, uint _amount) internal{
        if(isBase(_collateralAsset) || iPOOLS(POOLS).isSynth(_collateralAsset)){
            _sendFunds(_collateralAsset, _member, _amount); 
        }else if(isPool(_collateralAsset)){
            iPOOLS(POOLS).unlockUnits(_amount, _collateralAsset, _member); 
        }
    }

    function _getFunds(address _token, uint _amount) internal returns(uint) {
        uint _balance = iERC20(_token).balanceOf(address(this));
        if(tx.origin==msg.sender){
            require(iERC20(_token).transferTo(address(this), _amount));
        }else{
            require(iERC20(_token).transferFrom(msg.sender, address(this), _amount));
        }
        return iERC20(_token).balanceOf(address(this)) - _balance;
    }

    function _sendFunds(address _token, address _member, uint _amount) internal {
        require(iERC20(_token).transfer(_member, _amount));
    }

    function _addDebtToMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] += _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] += _collateral;
    }
    function _removeDebtFromMember(address _member, uint _collateral, address _collateralAsset, uint _debt, address _debtAsset) internal {
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].debt[_debtAsset] -= _debt;
        mapMember_Collateral[_member].mapCollateral_Debt[_collateralAsset].collateral[_debtAsset] -= _collateral;
    }
    function _removeCollateral(uint _collateral, address _collateralAsset, address _debtAsset) internal {
        mapCollateralDebt_Collateral[_collateralAsset][_debtAsset] -= _collateral;               
    }



    

    function isBase(address token) public view returns(bool base) {
        if(token == VADER || token == USDV){
            return true;
        }
    }

    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this));
    }
    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this));
    }

    
    function moveTokenToPools(address _token, uint _amount) internal returns(uint safeAmount) {
        if(_token == VADER || _token == USDV || iPOOLS(POOLS).isSynth(_token)){
            safeAmount = _amount;
            if(tx.origin==msg.sender){
                iERC20(_token).transferTo(POOLS, _amount);
            }else{
                iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            }
        } else {
            uint _startBal = iERC20(_token).balanceOf(POOLS);
            iERC20(_token).transferFrom(msg.sender, POOLS, _amount);
            safeAmount = iERC20(_token).balanceOf(POOLS) - _startBal;
        }
    }

    

    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }
    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function emitting() public view returns(bool){
        return iVADER(VADER).emitting();
    }
    function isCurated(address token) public view returns(bool curated) {
        if(_isCurated[token]){
            curated = true;
        }
    }
    function isPool(address token) public view returns(bool pool) {
        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){
            pool = true;
        }
    }

    function getMemberBaseDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositBase[member][token];
    }
    function getMemberTokenDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_depositToken[member][token];
    }
    function getMemberLastDeposit(address member, address token) external view returns(uint) {
        return mapMemberToken_lastDeposited[member][token];
    }
    function getMemberCollateral(address member, address collateralAsset, address debtAsset) external view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].collateral[debtAsset];
    }
    function getMemberDebt(address member, address collateralAsset, address debtAsset) public view returns(uint) {
        return mapMember_Collateral[member].mapCollateral_Debt[collateralAsset].debt[debtAsset];
    }
    function getSystemCollateral(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Collateral[collateralAsset][debtAsset];
    }
    function getSystemDebt(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_Debt[collateralAsset][debtAsset];
    }
    function getSystemInterestPaid(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralDebt_interestPaid[collateralAsset][debtAsset];
    }
    function getNextEraTime(address collateralAsset, address debtAsset) public view returns(uint) {
        return mapCollateralAsset_NextEra[collateralAsset][debtAsset];
    }
}",5281.0,4,3,"The provided smart contract has several potential vulnerabilities and issues. Below is a list of the identified vulnerabilities:

### 1. **Reentrancy Vulnerability**
   - **Location**: Functions like `removeLiquidity`, `swapWithSynthsWithLimit`, `borrowForMember`, and `repayForMember` involve external calls (e.g., `transfer`, `transferFrom`, `swap`, etc.) before updating the contract's state.
   - **Risk**: An attacker could exploit this by recursively calling these functions before the state is updated, potentially draining funds or causing unexpected behavior.

### 2. **Uninitialized `UTILS` and `DAO` Addresses**
   - **Location**: The `UTILS()` and `DAO()` functions return addresses from the `iVADER` contract, but there is no explicit initialization check for these addresses.
   - **Risk**: If these addresses are not properly set, the contract could behave unexpectedly or fail to execute critical functions.

### 3. **Lack of Input Validation**
   - **Location**: Functions like `addLiquidity`, `removeLiquidity`, `swapWithSynthsWithLimit`, `borrowForMember`, and `repayForMember` do not validate all input parameters (e.g., zero address checks, zero value checks).
   - **Risk**: This could lead to unexpected behavior, such as transferring tokens to the zero address or allowing zero-value transactions that could disrupt the contract's logic.

### 4. **Incorrect Use of `transfer` and `transferFrom`**
   - **Location**: The `_getFunds` and `_sendFunds` functions use `transfer` and `transferFrom` without handling the return value properly.
   - **Risk**: Some ERC20 tokens do not revert on failure but instead return `false`. This could lead to silent failures where tokens are not actually transferred.

### 5. **Potential Integer Overflow/Underflow**
   - **Location**: Arithmetic operations in functions like `addDepositData`, `removeDepositData`, `getILProtection`, and `payInterest` could potentially overflow or underflow, especially in older Solidity versions (though Solidity 0.8.x has built-in overflow checks).
   - **Risk**: If not handled properly, this could lead to incorrect calculations and unexpected behavior.

### 6. **Unrestricted Access to Critical Functions**
   - **Location**: Functions like `setParams`, `setAnchorParams`, `curatePool`, `replacePool`, `listAnchor`, and `replaceAnchor` are not adequately restricted (only `onlyDAO` modifier is used).
   - **Risk**: If the `DAO` address is compromised or incorrectly set, an attacker could manipulate critical parameters, leading to loss of funds or disruption of the system.

### 7. **Inconsistent State Updates**
   - **Location**: Functions like `removeLiquidity` and `repayForMember` update state variables after external calls, which could lead to inconsistent states if the external calls fail.
   - **Risk**: This could result in a state where the contract's internal accounting does not match the actual token balances.

### 8. **Lack of Event Emission for Critical State Changes**
   - **Location**: Some state-changing functions like `setParams`, `setAnchorParams`, and `updateAnchorPrice` do not emit events.
   - **Risk**: This makes it difficult to track changes to the contract's state, which is crucial for transparency and debugging.

### 9. **Potential Front-Running in `swapWithSynthsWithLimit`**
   - **Location**: The `swapWithSynthsWithLimit` function calculates slippage based on the current state, which could be manipulated by front-running.
   - **Risk**: An attacker could front-run the transaction to manipulate the slippage calculation, leading to unfavorable swap rates for the user.

### 10. **Unhandled Edge Cases in `getAnchorPrice`**
   - **Location**: The `getAnchorPrice` function assumes that `arrayPrices` has at least 3 elements when calculating the median price.
   - **Risk**: If `arrayPrices` has fewer than 3 elements, the function could revert or return incorrect values, leading to incorrect price calculations.

### 11. **Incorrect Handling of Synth Tokens**
   - **Location**: The `swapWithSynthsWithLimit` function does not properly handle synth tokens in all cases, especially when swapping between synths and non-synths.
   - **Risk**: This could lead to incorrect token transfers or failed transactions.

### 12. **Lack of Liquidation Mechanism**
   - **Location**: The `checkLiquidate` function is empty and does not implement any liquidation logic.
   - **Risk**: If a borrower's collateral falls below the required threshold, there is no mechanism to liquidate their position, potentially leading to undercollateralized loans.

### 13. **Incorrect Use of `require` Statements**
   - **Location**: Some `require` statements (e.g., in `swapWithSynthsWithLimit`) do not provide informative error messages.
   - **Risk**: This makes it difficult to diagnose issues when transactions fail.

### 14. **Potential Denial of Service (DoS)**
   - **Location**: Functions like `listAnchor` and `replaceAnchor` could be exploited to fill the `arrayAnchors` array, potentially causing the contract to run out of gas when iterating over the array.
   - **Risk**: This could lead to a denial of service, preventing legitimate users from interacting with the contract.

### 15. **Incorrect Calculation of Interest**
   - **Location**: The `payInterest` function calculates interest based on the time elapsed since the last era, but it does not account for potential edge cases where the time elapsed is zero or negative.
   - **Risk**: This could lead to incorrect interest calculations, potentially causing financial losses for users.

### 16. **Lack of Fallback or Receive Function**
   - **Location**: The contract does not have a `fallback` or `receive` function.
   - **Risk**: If Ether is accidentally sent to the contract, it could be permanently locked, as there is no way to recover it.

### 17. **Incorrect Handling of `tx.origin`**
   - **Location**: The `_getFunds` function uses `tx.origin` to determine whether to call `transferTo` or `transferFrom`.
   - **Risk**: Using `tx.origin` for authorization is generally discouraged, as it can be manipulated by intermediate contracts, leading to security vulnerabilities.

### 18. **Potential Gas Limit Issues**
   - **Location**: Functions like `swapWithSynthsWithLimit` and `payInterest` involve multiple external calls and state updates, which could potentially exceed the gas limit.
   - **Risk**: This could cause transactions to fail, especially during periods of high network congestion.

### 19. **Incorrect Handling of `mapCollateralDebt_interestPaid`**
   - **Location**: The `payInterest` function updates `mapCollateralDebt_interestPaid` but does not handle cases where the interest paid exceeds the available collateral.
   - **Risk**: This could lead to incorrect accounting and potential loss of funds.

### 20. **Lack of Error Handling in External Calls**
   - **Location**: External calls to `iPOOLS`, `iERC20`, and other interfaces do not handle potential errors or failures.
   - **Risk**: If an external call fails, the contract could be left in an inconsistent state, leading to potential loss of funds or other issues.

### 21. **Incorrect Use of `mapCollateralDebt_Collateral`**
   - **Location**: The `_removeCollateral` function subtracts from `mapCollateralDebt_Collateral` without checking for underflow.
   - **Risk**: This could lead to incorrect accounting if the collateral to be removed exceeds the available collateral.

### 22. **Potential Race Conditions**
   - **Location**: Functions like `addLiquidity` and `removeLiquidity` involve multiple state updates and external calls, which could be subject to race conditions.
   - **Risk**: This could lead to inconsistent states or unexpected behavior if multiple transactions are executed concurrently.

### 23. **Incorrect Handling of `mapMemberToken_depositBase` and `mapMemberToken_depositToken`**
   - **Location**: The `removeDepositData` function updates `mapMemberToken_depositBase` and `mapMemberToken_depositToken` without checking for underflow.
   - **Risk**: This could lead to incorrect accounting if the amounts to be removed exceed the available deposits.

### 24. **Lack of Proper Access Control**
   - **Location**: Functions like `curatePool` and `replacePool` do not have proper access control mechanisms beyond the `onlyDAO` modifier.
   - **Risk**: If the `DAO` address is compromised, an attacker could manipulate the pool curation process, leading to potential loss of funds or disruption of the system.

### 25. **Incorrect Handling of `mapCollateralDebt_Debt`**
   - **Location**: The `repayForMember` function subtracts from `mapCollateralDebt_Debt` without checking for underflow.
   - **Risk**: This could lead to incorrect accounting if the debt to be repaid exceeds the available debt.

### 26. **Potential Division by Zero**
   - **Location**: The `getVADERAmount` and `getUSDVAmount` functions perform division operations without checking if the divisor is zero.
   - **Risk**: This could lead to runtime errors if the divisor is zero, causing the contract to revert.

### 27. **Incorrect Handling of `mapCollateralDebt_interestPaid`**
   - **Location**: The `payInterest` function updates `mapCollateralDebt_interestPaid` without checking for underflow.
   - **Risk**: This could lead to incorrect accounting if the interest paid exceeds the available interest.

### 28. **Lack of Proper Error Messages**
   - **Location**: Many `require` statements throughout the contract do not provide informative error messages.
   - **Risk**: This makes it difficult to diagnose issues when transactions fail, leading to a poor user experience.

### 29. **Incorrect Handling of `mapMember_Collateral`**
   - **Location**: The `_addDebtToMember` and `_removeDebtFromMember` functions update `mapMember_Collateral` without checking for underflow.
   - **Risk**: This could lead to incorrect accounting if the debt or collateral to be removed exceeds the available amounts.

### 30. **Potential Gas Griefing**
   - **Location**: Functions like `swapWithSynthsWithLimit` and `payInterest` involve complex logic and multiple external calls, which could be exploited to cause gas griefing.
   - **Risk**: An attacker could exploit this to cause legitimate transactions to fail by consuming excessive gas.","### **[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol**

**Report Description**:  
The `timeForFullProtection` variable in `Router.sol` is incorrectly initialized to 1 second instead of 8640000 seconds (100 days) as intended. This mistake appears to be a test setting that was mistakenly carried over for deployment. Unless `timeForFullProtection` is reset to 100 days via the `setParams()` function (which is currently missing in the DAO), the Impermanent Loss (IL) protection mechanism will not function as specified. This breaks a key value proposition of the Vader protocol, which promises IL protection increasing linearly from 0 to 100% over 100 days. The recommendation is to correct the initialization to `timeForFullProtection = 8640000; //100 days` on line 84.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect initialization of `timeForFullProtection`. This is a critical oversight as it directly impacts the functionality of the IL protection mechanism, which is a core feature of the protocol.

---

### **[H-10] Anyone can list anchors / curate tokens**

**Report Description**:  
The `Router.listAnchor` function can be called by anyone to add tokens as anchors. The only check is `require(iPOOLS(POOLS).isAnchor(token));`, which can be bypassed by calling `Pools.addLiquidity(VADER, token, _)` once, even without sending any tokens. This makes the check essentially useless. Additionally, the `replaceAnchor` function can be exploited using flash loans to manipulate anchor prices and remove rewards from curated pools. This allows attackers to game the reward system by adding their own pools with custom tokens. Recommendations include making `listAnchor` and `replaceAnchor` DAO-only functions and using time-weighted prices for bounds checks.

**Match in Response List**:  
Partially matches with **""Unrestricted Access to Critical Functions""** and **""Potential Denial of Service (DoS)""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unrestricted access to critical functions, which aligns with the vulnerability in `listAnchor` and `replaceAnchor`. However, it misses the specific risks associated with flash loans and the manipulation of anchor prices, which are critical to understanding the full impact of this issue.

---

### **[H-15] Wrong slippage protection on Token -> Token trades**

**Report Description**:  
The `Router.swapWithSynthsWithLimit` function incorrectly calculates slippage protection for token-to-token trades. The function performs two trades: (1) token to base and (2) base to token. The slippage protection for the second trade uses the input amount from the first trade instead of the base output from the first trade. This leads to incorrect slippage calculations, causing trades to be canceled when they shouldn't or accepted when the user suffers more losses than expected. The recommendation is to use the base output from the first trade for slippage protection and consider a formula to compute slippage for both trades at once.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of incorrect slippage protection in `swapWithSynthsWithLimit`. This is a significant oversight as it directly impacts the fairness and security of token-to-token trades.

---

### **[H-23] Anyone can curate pools and steal rewards**

**Report Description**:  
The `Router.curatePool` and `replacePool` functions lack access restrictions, allowing anyone to curate or replace pools. An attacker can use flash loans to replace existing curated pools with their own, removing rewards from legitimate pools and adding rewards to their own pools with custom tokens. This enables the attacker to game the reward system by repeatedly swapping in their custom pool, withdrawing liquidity, and repaying the flash loan. Recommendations include preventing pool curation through flash loans and making pool curations DAO-exclusive actions.

**Match in Response List**:  
Partially matches with **""Unrestricted Access to Critical Functions""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unrestricted access to critical functions, which aligns with the vulnerability in `curatePool` and `replacePool`. However, it misses the specific risks associated with flash loans and the manipulation of the reward system, which are critical to understanding the full impact of this issue.

---

### **[M-03] Lack of input validation in `replacePool()` allows curated pool limit bypass in Router.sol**

**Report Description**:  
The `replacePool()` function lacks input validation to check if `oldToken` exists and is curated. Using a non-existing `oldToken` (even the zero address) bypasses the check on line 236, as `Pools.getBaseAmount()` returns 0 for non-existing tokens. This allows `newToken` to be curated without enforcing the `curatedPoolLimit` set in the `curatePool()` function. This oversight can be exploited to bypass the curated pool limit, potentially leading to an excessive number of curated pools.

**Match in Response List**:  
Partially matches with **""Lack of Input Validation""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of lack of input validation, which aligns with the vulnerability in `replacePool()`. However, it misses the specific risk of bypassing the curated pool limit, which is critical to understanding the full impact of this issue.

---

### **[M-11] Allowing duplicated anchors could cause bias on anchor price.**

**Report Description**:  
The `Router.listAnchor` function lacks access control and allows duplicate anchors to be added. If the same anchor is added multiple times, it biases the result of `getAnchorPrice`. This can be exploited to manipulate the anchor price, leading to incorrect price calculations and potential financial losses. Recommendations include restricting `listAnchor` to the deployer and adding a check to prevent duplicate anchors.

**Match in Response List**:  
Partially matches with **""Unrestricted Access to Critical Functions""** and **""Potential Denial of Service (DoS)""**.

**Validation**:  
**Partially Correct**. The response identifies the issue of unrestricted access to critical functions, which aligns with the vulnerability in `listAnchor`. However, it misses the specific risk of duplicate anchors biasing the anchor price, which is critical to understanding the full impact of this issue.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:  
The `init` function in most Solidity contracts can be called by anyone, leading to a race condition during contract deployment. An attacker could call the `init` function immediately after deployment, rendering the contracts useless and forcing a redeployment, which would incur significant gas costs. This vulnerability highlights the need for proper access control on initialization functions.

**Match in Response List**:  
No match found.

**Validation**:  
**Incorrect**. The response list does not address the issue of unrestricted access to the `init` function. This is a significant oversight as it could lead to a race condition during contract deployment, rendering the contracts unusable.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- *None*

**Partially Correct Matches**:  
- **[H-10] Anyone can list anchors / curate tokens**  
- **[H-23] Anyone can curate pools and steal rewards**  
- **[M-03] Lack of input validation in `replacePool()` allows curated pool limit bypass in Router.sol**  
- **[M-11] Allowing duplicated anchors could cause bias on anchor price.**

**Missed Issues from Issue Report**:  
- **[H-09] Incorrect initialization gives IL protection of only 1 second instead of 100 days in Router.sol**  
- **[H-15] Wrong slippage protection on Token -> Token trades**  
- **[M-13] Init function can be called by everyone**",0,4,3,30,"```
None.
```",0.0
Vault.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.3;

import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

contract Vault {

    bool private inited;
    uint public erasToEarn;
    uint public minGrantTime;
    uint public lastGranted;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    uint public minimumDepositTime;
    uint public totalWeight;

    mapping(address => uint) private mapMember_weight;
    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;
    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;

    // Events
    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);

    // Only DAO can execute
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    constructor(){}

    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
        POOLS = _pool;
        erasToEarn = 100;
        minimumDepositTime = 1;
        minGrantTime = 2592000;     // 30 days
    }

    //=========================================DAO=========================================//
    // Can set params
    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {
        erasToEarn = newEra;
        minimumDepositTime = newDepositTime;
        minGrantTime = newGrantTime;
    }

    // Can issue grants
    function grant(address recipient, uint amount) public onlyDAO {
        require((block.timestamp - lastGranted) >= minGrantTime, ""not too fast"");
        lastGranted = block.timestamp;
        iERC20(USDV).transfer(recipient, amount); 
    }

    //======================================DEPOSITS========================================//

    // Deposit USDV or SYNTHS
    function deposit(address synth, uint amount) external {
        depositForMember(synth, msg.sender, amount);
    }
    // Wrapper for contracts
    function depositForMember(address synth, address member, uint amount) public {
        require((iFACTORY(FACTORY).isSynth(synth)), ""Not Synth""); // Only Synths
        getFunds(synth, amount);
        _deposit(synth, member, amount);
    }
    function _deposit(address _synth, address _member, uint _amount) internal {
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         // Time of deposit
        mapMemberSynth_deposit[_member][_synth] += _amount;                 // Record deposit
        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);
        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){
            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               // Price in USDV
        }
        mapMember_weight[_member] += _weight;                               // Total member weight 
        totalWeight += _weight;                                             // Total weight 
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    //====================================== HARVEST ========================================//

    // Harvest, get payment, allocate, increase weight
    function harvest(address synth) external returns(uint reward) {
        address _member = msg.sender;
        uint _weight;
        address _token = iSYNTH(synth).TOKEN();
        reward = calcCurrentReward(synth, _member);                     // In USDV
        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      // Reset time
        if(iPOOLS(POOLS).isAsset(_token)){
            iERC20(USDV).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));
            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);
        } else {
            iERC20(VADER).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));
            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));
        }
        mapMemberSynth_deposit[_member][synth] += reward; 
        mapMember_weight[_member] += _weight;
        totalWeight += _weight;
        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);
    }

    // Get the payment owed for a member
    function calcCurrentReward(address synth, address member) public view returns(uint reward) {
        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        // Get time since last claim
        uint _share = calcReward(synth, member);                                               // Get share of rewards for member
        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         // Get owed amount, based on per-day rates
        uint _reserve;
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            _reserve = reserveUSDV();
        } else {
            _reserve = reserveVADER();
        }
        if(reward >= _reserve) {
            reward = _reserve;                                                          // Send full reserve if the last
        }
    }

    function calcReward(address synth, address member) public view returns(uint reward) {
        uint _weight = mapMember_weight[member];  
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      // Aggregrate reserves
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   // Get member's share of that
        } else{
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          
        }
    }

    //====================================== WITHDRAW ========================================//

    // Members to withdraw
    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          // Get amount to withdraw
        sendFunds(synth, msg.sender, redeemedAmount);
    }
    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {
        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, ""DepositTime"");    // stops attacks
        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); // Share of deposits
        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  // Reduce for member                             
        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   // Find recorded weight to reduce
        mapMember_weight[_member] -= _weight;                                   // Reduce for member 
        totalWeight -= _weight;                                                 // Reduce for total
        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   // Event
    }

    //============================== ASSETS ================================//

    function getFunds(address synth, uint amount) internal {
        if(tx.origin==msg.sender){
            require(iERC20(synth).transferTo(address(this), amount));
        }else{
            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));
        }
    }
    function sendFunds(address synth, address member, uint amount) internal {
        require(iERC20(synth).transfer(member, amount));
    }

    //============================== HELPERS ================================//

    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this)); // Balance
    }
    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this)); // Balance
    }

    function getMemberDeposit(address synth, address member) external view returns(uint){
        return mapMemberSynth_deposit[member][synth];
    }
    function getMemberWeight(address member) external view returns(uint){
        return mapMember_weight[member];
    }
    function getMemberLastTime(address synth, address member) external view returns(uint){
        return mapMemberSynth_lastTime[member][synth];
    }

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }

}",2105.0,206.0,"[H-18] Vault rewards can be gamed
The `_deposit` function increases the member's weight by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);` which is the swap output amount when trading the deposited underlying synth amount.
Notice that anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`.
Call `harvest(realSynth)` with a synth with actual value. This will increase the synth balance and it can be withdrawn later.
  [H-19] Vault rewards last claim time not always initialized
The `harvest` calls `calcCurrentReward` which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. As one can claim different synths than the synths that they deposited, `mapMemberSynth_lastTime[member][synth]` might still be uninitialized and the _secondsSinceClaim becomes the current block timestamp.
The larger the `_secondsSinceClaim` the larger the rewards. This bug allows claiming a huge chunk of the rewards.

 [H-20] Vault Weight accounting is wrong for withdrawals
When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth with `_processWithdraw(synth, member, basisPoints=10000` the full weight is decreased.
The second deposited synth is now essentially weightless.
Users that deposited more than one synth can not claim their fair share of rewards after a withdrawal.

 [M-13] Init function can be called by everyone
Most of the solidity contracts have an `init` function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment a hacker could call the init function and make the deployed contracts useless. Then it would have to be redeployed, costing a lot of gas. function init()",4.0,"pragma solidity ^0.8.3;

import ""./interfaces/iERC20.sol"";
import ""./interfaces/iUTILS.sol"";
import ""./interfaces/iVADER.sol"";
import ""./interfaces/iROUTER.sol"";
import ""./interfaces/iPOOLS.sol"";
import ""./interfaces/iFACTORY.sol"";
import ""./interfaces/iSYNTH.sol"";

contract Vault {

    bool private inited;
    uint public erasToEarn;
    uint public minGrantTime;
    uint public lastGranted;

    address public VADER;
    address public USDV;
    address public ROUTER;
    address public POOLS;
    address public FACTORY;

    uint public minimumDepositTime;
    uint public totalWeight;

    mapping(address => uint) private mapMember_weight;
    mapping(address => mapping(address => uint)) private mapMemberSynth_deposit;
    mapping(address => mapping(address => uint)) private mapMemberSynth_lastTime;

    
    event MemberDeposits(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberWithdraws(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);
    event MemberHarvests(address indexed synth, address indexed member, uint amount, uint weight, uint totalWeight);

    
    modifier onlyDAO() {
        require(msg.sender == DAO(), ""Not DAO"");
        _;
    }

    constructor(){}

    function init(address _vader, address _usdv, address _router, address _factory, address _pool) public {
        require(inited == false);
        inited = true;
        POOLS = _pool;
        VADER = _vader;
        USDV = _usdv;
        ROUTER = _router;
        FACTORY = _factory;
        POOLS = _pool;
        erasToEarn = 100;
        minimumDepositTime = 1;
        minGrantTime = 2592000;     
    }

    
    
    function setParams(uint newEra, uint newDepositTime, uint newGrantTime) external onlyDAO {
        erasToEarn = newEra;
        minimumDepositTime = newDepositTime;
        minGrantTime = newGrantTime;
    }

    
    function grant(address recipient, uint amount) public onlyDAO {
        require((block.timestamp - lastGranted) >= minGrantTime, ""not too fast"");
        lastGranted = block.timestamp;
        iERC20(USDV).transfer(recipient, amount); 
    }

    

    
    function deposit(address synth, uint amount) external {
        depositForMember(synth, msg.sender, amount);
    }
    
    function depositForMember(address synth, address member, uint amount) public {
        require((iFACTORY(FACTORY).isSynth(synth)), ""Not Synth""); 
        getFunds(synth, amount);
        _deposit(synth, member, amount);
    }
    function _deposit(address _synth, address _member, uint _amount) internal {
        mapMemberSynth_lastTime[_member][_synth] = block.timestamp;         
        mapMemberSynth_deposit[_member][_synth] += _amount;                 
        uint _weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);
        if(iPOOLS(POOLS).isAnchor(iSYNTH(_synth).TOKEN())){
            _weight = iROUTER(ROUTER).getUSDVAmount(_weight);               
        }
        mapMember_weight[_member] += _weight;                               
        totalWeight += _weight;                                             
        emit MemberDeposits(_synth, _member, _amount, _weight, totalWeight);
    }

    

    
    function harvest(address synth) external returns(uint reward) {
        address _member = msg.sender;
        uint _weight;
        address _token = iSYNTH(synth).TOKEN();
        reward = calcCurrentReward(synth, _member);                     
        mapMemberSynth_lastTime[_member][synth] = block.timestamp;      
        if(iPOOLS(POOLS).isAsset(_token)){
            iERC20(USDV).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(USDV, _token, address(this));
            _weight = iUTILS(UTILS()).calcValueInBase(_token, reward);
        } else {
            iERC20(VADER).transfer(POOLS, reward); 
            reward = iPOOLS(POOLS).mintSynth(VADER, _token, address(this));
            _weight = iROUTER(ROUTER).getUSDVAmount(iUTILS(UTILS()).calcValueInBase(_token, reward));
        }
        mapMemberSynth_deposit[_member][synth] += reward; 
        mapMember_weight[_member] += _weight;
        totalWeight += _weight;
        emit MemberHarvests(synth, _member, reward, _weight, totalWeight);
    }

    
    function calcCurrentReward(address synth, address member) public view returns(uint reward) {
        uint _secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];        
        uint _share = calcReward(synth, member);                                               
        reward = (_share * _secondsSinceClaim) / iVADER(VADER).secondsPerEra();         
        uint _reserve;
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            _reserve = reserveUSDV();
        } else {
            _reserve = reserveVADER();
        }
        if(reward >= _reserve) {
            reward = _reserve;                                                          
        }
    }

    function calcReward(address synth, address member) public view returns(uint reward) {
        uint _weight = mapMember_weight[member];  
        if(iPOOLS(POOLS).isAsset(iSYNTH(synth).TOKEN())){
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();      
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);                   
        } else{
            uint _adjustedReserve = iROUTER(ROUTER).getUSDVAmount(reserveVADER()) + reserveUSDV();
            return iUTILS(UTILS()).calcShare(_weight, totalWeight, _adjustedReserve / erasToEarn);          
        }
    }

    

    
    function withdraw(address synth, uint basisPoints) external returns(uint redeemedAmount) {
        redeemedAmount = _processWithdraw(synth, msg.sender, basisPoints);          
        sendFunds(synth, msg.sender, redeemedAmount);
    }
    function _processWithdraw(address _synth, address _member, uint _basisPoints) internal returns(uint redeemedAmount) {
        require((block.timestamp - mapMemberSynth_lastTime[_member][_synth]) >= minimumDepositTime, ""DepositTime"");    
        redeemedAmount = iUTILS(UTILS()).calcPart(_basisPoints, mapMemberSynth_deposit[_member][_synth]); 
        mapMemberSynth_deposit[_member][_synth] -= redeemedAmount;                  
        uint _weight = iUTILS(UTILS()).calcPart(_basisPoints, mapMember_weight[_member]);   
        mapMember_weight[_member] -= _weight;                                   
        totalWeight -= _weight;                                                 
        emit MemberWithdraws(_synth, _member, redeemedAmount, _weight, totalWeight);   
    }

    

    function getFunds(address synth, uint amount) internal {
        if(tx.origin==msg.sender){
            require(iERC20(synth).transferTo(address(this), amount));
        }else{
            require(iERC20(synth).transferFrom(msg.sender, address(this), amount));
        }
    }
    function sendFunds(address synth, address member, uint amount) internal {
        require(iERC20(synth).transfer(member, amount));
    }

    

    function reserveUSDV() public view returns(uint) {
        return iERC20(USDV).balanceOf(address(this)); 
    }
    function reserveVADER() public view returns(uint) {
        return iERC20(VADER).balanceOf(address(this)); 
    }

    function getMemberDeposit(address synth, address member) external view returns(uint){
        return mapMemberSynth_deposit[member][synth];
    }
    function getMemberWeight(address member) external view returns(uint){
        return mapMember_weight[member];
    }
    function getMemberLastTime(address synth, address member) external view returns(uint){
        return mapMemberSynth_lastTime[member][synth];
    }

    function DAO() public view returns(address){
        return iVADER(VADER).DAO();
    }
    function UTILS() public view returns(address){
        return iVADER(VADER).UTILS();
    }

}",1860.0,3,1,"The provided smart contract has several potential vulnerabilities and issues. Below is a list of the identified vulnerabilities:

---

### 1. **Reentrancy Risk**
   - **Location**: `depositForMember`, `withdraw`, `harvest`, and other functions that transfer tokens.
   - **Description**: The contract uses `transfer` and `transferFrom` for token transfers, which is generally safe against reentrancy. However, if the token contract is malicious or implements custom logic (e.g., ERC777 tokens with callbacks), reentrancy attacks could occur. The contract does not use the **Checks-Effects-Interactions** pattern consistently, which increases the risk.

---

### 2. **Lack of Input Validation**
   - **Location**: `init`, `setParams`, `grant`, `depositForMember`, `withdraw`, and other functions.
   - **Description**: The contract does not validate critical inputs, such as:
     - `address` parameters (e.g., `_vader`, `_usdv`, `_router`, `_factory`, `_pool` in `init`).
     - `amount` values in `depositForMember`, `grant`, and `withdraw`.
     - `basisPoints` in `withdraw` (could exceed 100%).
   - This could lead to unexpected behavior or exploitation.

---

### 3. **Incorrect Token Transfer Logic**
   - **Location**: `getFunds` function.
   - **Description**: The `getFunds` function uses `transferTo` and `transferFrom` without ensuring the token contract supports these methods. This could result in failed transactions or unexpected behavior if the token contract does not implement these functions.

---

### 4. **Division Precision Loss**
   - **Location**: `calcCurrentReward` and `calcReward` functions.
   - **Description**: The contract performs division operations (e.g., `_adjustedReserve / erasToEarn`) without considering precision loss. Solidity rounds down in integer division, which could lead to inaccuracies in reward calculations.

---

### 5. **Uninitialized State Variables**
   - **Location**: `UTILS` and `DAO` functions.
   - **Description**: The contract relies on external contracts (`iVADER`) to return addresses for `UTILS` and `DAO`. If these external contracts are not properly initialized or return invalid addresses, the contract could behave unexpectedly or fail.

---

### 6. **Unbounded Loops or Gas Limits**
   - **Location**: `calcCurrentReward` and `calcReward` functions.
   - **Description**: These functions perform calculations based on external contract calls (e.g., `iROUTER(ROUTER).getUSDVAmount`). If these external calls consume excessive gas or fail, the functions could revert, leading to denial of service.

---

### 7. **Front-Running Vulnerability**
   - **Location**: `depositForMember` and `withdraw` functions.
   - **Description**: The contract does not protect against front-running attacks. For example, an attacker could observe a pending deposit or withdrawal transaction and manipulate the state (e.g., by depositing or withdrawing before the victim's transaction is mined).

---

### 8. **Inconsistent State Updates**
   - **Location**: `_deposit` and `_processWithdraw` functions.
   - **Description**: The contract updates state variables (e.g., `mapMemberSynth_deposit`, `mapMember_weight`, `totalWeight`) after external calls or transfers. This violates the **Checks-Effects-Interactions** pattern and could lead to inconsistent states if an external call fails or is exploited.

---

### 9. **Lack of Access Control**
   - **Location**: `init` function.
   - **Description**: The `init` function can be called by anyone, allowing an attacker to initialize the contract with malicious parameters. This could compromise the entire contract.

---

### 10. **Unhandled Edge Cases**
   - **Location**: `calcCurrentReward` function.
   - **Description**: The function does not handle edge cases, such as:
     - `_secondsSinceClaim` being zero.
     - `_reserve` being zero.
     - `reward` exceeding the reserve balance.
   - This could lead to incorrect reward calculations or failed transactions.

---

### 11. **Dependence on External Contracts**
   - **Location**: Throughout the contract.
   - **Description**: The contract relies heavily on external contracts (e.g., `iVADER`, `iROUTER`, `iPOOLS`, `iUTILS`). If any of these contracts are compromised, behave maliciously, or are upgraded with incompatible changes, the `Vault` contract could fail or be exploited.

---

### 12. **Unsafe Arithmetic Operations**
   - **Location**: `calcCurrentReward`, `calcReward`, and `_processWithdraw` functions.
   - **Description**: The contract does not use SafeMath or Solidity 0.8.x's built-in overflow checks for arithmetic operations. While Solidity 0.8.x prevents overflows by default, the contract should still ensure that arithmetic operations are safe and do not lead to unexpected behavior.

---

### 13. **Incorrect Event Emission**
   - **Location**: `_deposit`, `_processWithdraw`, and `harvest` functions.
   - **Description**: The contract emits events (`MemberDeposits`, `MemberWithdraws`, `MemberHarvests`) before state changes are finalized. If an external call fails or the transaction reverts, the events could misrepresent the actual state of the contract.

---

### 14. **Unrestricted Grant Function**
   - **Location**: `grant` function.
   - **Description**: The `grant` function allows the DAO to transfer any amount of `USDV` tokens to any recipient. If the DAO is compromised or acts maliciously, this could lead to loss of funds.

---

### 15. **Missing Zero-Address Checks**
   - **Location**: `init` and other functions.
   - **Description**: The contract does not check if critical addresses (e.g., `VADER`, `USDV`, `ROUTER`, `FACTORY`, `POOLS`) are set to the zero address. This could lead to failed transactions or loss of funds.

---

### 16. **Incorrect Token Handling**
   - **Location**: `harvest` function.
   - **Description**: The `harvest` function transfers tokens to the `POOLS` contract and mints new tokens. If the `POOLS` contract is compromised or behaves unexpectedly, this could lead to loss of funds or incorrect state updates.

---

### 17. **Unclear Reward Calculation Logic**
   - **Location**: `calcCurrentReward` and `calcReward` functions.
   - **Description**: The reward calculation logic is complex and relies on multiple external calls. This makes it difficult to audit and increases the risk of errors or exploitation.

---

### 18. **Lack of Emergency Stop Mechanism**
   - **Description**: The contract does not include an emergency stop mechanism (e.g., `pause` function) to halt operations in case of a vulnerability or attack. This could make it difficult to respond to incidents.

---

### 19. **Uninitialized `UTILS` and `DAO` Addresses**
   - **Location**: `UTILS` and `DAO` functions.
   - **Description**: The contract assumes that `iVADER(VADER).UTILS()` and `iVADER(VADER).DAO()` return valid addresses. If these addresses are not initialized or are set to invalid values, the contract could fail.

---

### 20. **Potential Denial of Service**
   - **Location**: `depositForMember` and `withdraw` functions.
   - **Description**: If the `FACTORY` or `POOLS` contracts revert or consume excessive gas, the `depositForMember` and `withdraw` functions could fail, leading to denial of service.","### **[H-18] Vault rewards can be gamed**

**Report Description**:
The `_deposit` function increases the member's weight by `_weight = iUTILS(UTILS()).calcValueInBase(iSYNTH(_synth).TOKEN(), _amount);`, which is the swap output amount when trading the deposited underlying synth amount. Anyone can create synths of custom tokens by calling `Pools.deploySynth(customToken)`. By calling `harvest(realSynth)` with a synth with actual value, the synth balance increases and can be withdrawn later, allowing users to game the rewards system.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the specific issue of reward gaming through the creation of custom synths and manipulation of the `harvest` function. This is a critical oversight, as it directly impacts the fairness and security of the reward distribution mechanism.

---

### **[H-19] Vault rewards last claim time not always initialized**

**Report Description**:
The `harvest` function calls `calcCurrentReward`, which computes `_secondsSinceClaim = block.timestamp - mapMemberSynth_lastTime[member][synth];`. Since users can claim different synths than the ones they deposited, `mapMemberSynth_lastTime[member][synth]` might remain uninitialized, causing `_secondsSinceClaim` to equal the current block timestamp. This results in disproportionately large rewards, allowing users to claim a significant portion of the rewards unfairly.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of uninitialized `mapMemberSynth_lastTime` leading to inflated rewards. This is a critical vulnerability that could result in significant financial losses due to unfair reward distribution.

---

### **[H-20] Vault Weight accounting is wrong for withdrawals**

**Report Description**:
When depositing two different synths, their weight is added to the same `mapMember_weight[_member]` storage variable. When withdrawing the full amount of one synth using `_processWithdraw(synth, member, basisPoints=10000)`, the full weight is decreased. This leaves the second deposited synth effectively weightless, preventing users who deposited multiple synths from claiming their fair share of rewards after a withdrawal.

**Match in Response List**:
**No match found**.

**Validation**:
**Incorrect**. The response list does not address the issue of incorrect weight accounting during withdrawals, which leads to unfair reward distribution. This is a significant oversight, as it directly impacts the integrity of the reward system.

---

### **[M-13] Init function can be called by everyone**

**Report Description**:
Most of the Solidity contracts have an `init` function that everyone can call. This could lead to a race condition when the contract is deployed. At that moment, a hacker could call the `init` function and make the deployed contracts useless, requiring redeployment and incurring significant gas costs.

**Match in Response List**:
**9. Lack of Access Control**

**Validation**:
**Correct**. The response accurately identifies the issue with the `init` function being callable by anyone, which could lead to race conditions and contract initialization by malicious actors. This aligns with Solidity best practices for secure contract deployment.

---

### **Summary of Matches and Gaps**

**Correct Matches**:

- **[M-13] Init function can be called by everyone**

**Partially Correct Matches**:

- *None*

**Missed Issues from Issue Report**:

- **[H-18] Vault rewards can be gamed**
- **[H-19] Vault rewards last claim time not always initialized**
- **[H-20] Vault Weight accounting is wrong for withdrawals**

---

### **Conclusion**

The response list covers some general vulnerabilities but misses critical issues related to the Vault contract's reward system, such as reward gaming, uninitialized claim times, and incorrect weight accounting. These missed issues are high-severity vulnerabilities that could lead to significant financial losses and unfair reward distribution. The response list should be expanded to address these specific concerns to ensure comprehensive coverage of the contract's security risks.",1,0,3,20,"```
1. Lack of Access Control
```","To calculate the **Average Precision (AP)** for the given query, follow these steps:

1. **Identify the rank of the true positive**:
   - The true positive is ""Lack of Access Control"".
   - In the ranked list of predictions, ""Lack of Access Control"" appears at rank **9**.

2. **Calculate the precision at rank 9 (\( P@9 \))**:
   - Precision at rank \( k \) is calculated as the number of true positives up to rank \( k \) divided by \( k \).
   - Since there is only one true positive up to rank 9, \( P@9 = \frac{1}{9} \approx 0.1111 \).

3. **Compute the Average Precision (AP)**:
   - Since there is only one true positive, the AP is simply the precision at the rank where the true positive appears.
   - Therefore, \( AP = 0.1111 \).

**Output**:
```
0.1111
```"
Vether.sol,"// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.3;

// Interfaces
import ""./interfaces/iVETHER.sol"";

// Token Contract
contract Vether is iVETHER {

    // Coin Defaults
    string public override name;                                         // Name of Coin
    string public override symbol;                                       // Symbol of Coin
    uint public override decimals  = 18;                              // Decimals
    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   // 1,000,000 Total

    uint public totalFees;
    mapping(address=>bool) public mapAddress_Excluded;  

    // ERC-20 Mappings
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    
    // Minting event
    constructor() {
        name = ""Vether"";
        symbol  = ""VETH"";
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    // iERC20 Transfer function
    function transfer(address recipient, uint amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    // iERC20 Approve, change allowance functions
    function approve(address spender, uint amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""iERC20: approve from the zero address"");
        require(spender != address(0), ""iERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    // iERC20 TransferFrom function
    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

       // Internal transfer function which includes the Fee
    function _transfer(address _from, address _to, uint _value) private {
        require(_balances[_from] >= _value, 'Must not send more than balance');
        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');
        _balances[_from] -= _value;
        uint _fee = _getFee(_from, _to, _value);                                            // Get fee amount
        _balances[_to] += (_value - _fee);                                               // Add to receiver
        _balances[address(this)] += _fee;                                                   // Add fee to self
        totalFees += _fee;                                                                  // Track fees collected
        emit Transfer(_from, _to, (_value - _fee));                                      // Transfer event
        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {
            emit Transfer(_from, address(this), _fee);                                      // Fee Transfer event
        }
    }
    
    // Calculate Fee amount
    function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        // No fee if excluded
        } else {
            return (_value / 1000);                                                         // Fee amount = 0.1%
        }
    }

    function addExcluded(address excluded) public {
        mapAddress_Excluded[excluded] = true;
    }
}",921.0,96.0,"[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List.
Vether.sol implements a fee on every token transfer, unless either the sender or the recipient exists on a list of excluded addresses (mapAddress_Excluded). However, the addExcluded() function in Vether.sol has no restrictions on who can call it. So any user can call addExcluded with their own address as the argument, and bypass all transfer fees Alice calls:
(1) Vether.addExcluded(aliceAddress), which adds Alice's address to mapAddress_Excluded. (2) Alice can now freely transfer Vether with no fees.
Recommend adding restrictions to who can call addExcluded, perhaps by restricting it to a caller set by DAO.sol",1.0,"pragma solidity 0.8.3;


import ""./interfaces/iVETHER.sol"";


contract Vether is iVETHER {

    
    string public override name;                                         
    string public override symbol;                                       
    uint public override decimals  = 18;                              
    uint public override totalSupply  = 1*10**6 * (10 ** decimals);   

    uint public totalFees;
    mapping(address=>bool) public mapAddress_Excluded;  

    
    mapping(address => uint) private _balances;
    mapping(address => mapping(address => uint)) private _allowances;
    
    
    constructor() {
        name = ""Vether"";
        symbol  = ""VETH"";
        _balances[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function balanceOf(address account) public view override returns (uint) {
        return _balances[account];
    }
    function allowance(address owner, address spender) public view virtual override returns (uint) {
        return _allowances[owner][spender];
    }
    
    function transfer(address recipient, uint amount) public virtual override returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }
    
    function approve(address spender, uint amount) public virtual override returns (bool) {
        _approve(msg.sender, spender, amount);
        return true;
    }
    function increaseAllowance(address spender, uint addedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);
        return true;
    }
    function decreaseAllowance(address spender, uint subtractedValue) public virtual returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);
        return true;
    }
    function _approve(address owner, address spender, uint amount) internal virtual {
        require(owner != address(0), ""iERC20: approve from the zero address"");
        require(spender != address(0), ""iERC20: approve to the zero address"");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    
    
    function transferFrom(address sender, address recipient, uint amount) public virtual override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
        return true;
    }

       
    function _transfer(address _from, address _to, uint _value) private {
        require(_balances[_from] >= _value, 'Must not send more than balance');
        require(_balances[_to] + _value >= _balances[_to], 'Balance overflow');
        _balances[_from] -= _value;
        uint _fee = _getFee(_from, _to, _value);                                            
        _balances[_to] += (_value - _fee);                                               
        _balances[address(this)] += _fee;                                                   
        totalFees += _fee;                                                                  
        emit Transfer(_from, _to, (_value - _fee));                                      
        if (!mapAddress_Excluded[_from] && !mapAddress_Excluded[_to]) {
            emit Transfer(_from, address(this), _fee);                                      
        }
    }
    
    
    function _getFee(address _from, address _to, uint _value) private view returns (uint) {
        if (mapAddress_Excluded[_from] || mapAddress_Excluded[_to]) {
           return 0;                                                                        
        } else {
            return (_value / 1000);                                                         
        }
    }

    function addExcluded(address excluded) public {
        mapAddress_Excluded[excluded] = true;
    }
}",787.0,1,0,"Here is a list of vulnerabilities and issues in the provided smart contract:

---

### 1. **Lack of Access Control for `addExcluded` Function**
   - The `addExcluded` function allows any user to add addresses to the `mapAddress_Excluded` mapping, which exempts them from fees.
   - This can be exploited by malicious actors to exempt themselves or others from fees, undermining the fee mechanism.

---

### 2. **Potential Integer Overflow/Underflow**
   - The contract uses Solidity 0.8.3, which has built-in overflow/underflow checks. However, the logic in `decreaseAllowance` and `transferFrom` assumes that subtraction will not underflow, which could lead to unexpected reverts if not handled properly.
   - Example: If `_allowances[sender][msg.sender]` is less than `amount` in `transferFrom`, the subtraction will revert.

---

### 3. **Fee Calculation Precision Loss**
   - The fee calculation in `_getFee` divides `_value` by 1000, which could lead to precision loss for small values of `_value`.
   - Example: If `_value` is less than 1000, the fee will be 0, which might not be the intended behavior.

---

### 4. **Lack of Event Emission for `addExcluded`**
   - The `addExcluded` function modifies the state by adding an address to the `mapAddress_Excluded` mapping but does not emit an event.
   - This makes it difficult to track changes to the excluded list off-chain.

---

### 5. **No Validation for Zero Address in `addExcluded`**
   - The `addExcluded` function does not check if the `excluded` address is the zero address (`address(0)`).
   - Adding the zero address to the excluded list could lead to unintended behavior.

---

### 6. **Fee Accumulation in Contract**
   - Fees are accumulated in the contract's balance (`_balances[address(this)]`), but there is no mechanism to withdraw or use these fees.
   - This could lead to funds being locked in the contract indefinitely.

---

### 7. **Lack of Reentrancy Protection**
   - The `_transfer` function does not include reentrancy protection (e.g., using `nonReentrant` modifier or checks-effects-interactions pattern).
   - If this contract interacts with other contracts (e.g., via `transfer` or `call`), it could be vulnerable to reentrancy attacks.

---

### 8. **No Validation for `_value` in `_transfer`**
   - The `_transfer` function does not validate if `_value` is greater than 0.
   - Transferring 0 tokens is allowed, which could lead to unnecessary gas consumption and event emissions.

---

### 9. **Inconsistent Naming Conventions**
   - The contract uses inconsistent naming conventions for variables and functions. For example:
     - `mapAddress_Excluded` uses snake_case, while other variables like `_balances` and `_allowances` use underscore prefixes.
     - `_getFee` is private, but its naming suggests it could be internal or public.

---

### 10. **No Mechanism to Update Fees**
   - The fee calculation is hardcoded to `_value / 1000` in `_getFee`.
   - There is no mechanism to update the fee rate or fee logic, making the contract inflexible.

---

### 11. **Lack of Error Messages in Key Require Statements**
   - The `require` statements in `_transfer` do not include descriptive error messages.
   - Example: `require(_balances[_from] >= _value, 'Must not send more than balance')` could be more descriptive, such as ""Insufficient balance for transfer.""

---

### 12. **No Ownership Mechanism**
   - The contract does not implement an ownership mechanism (e.g., OpenZeppelin's `Ownable`).
   - This makes it impossible to restrict sensitive functions (e.g., `addExcluded`) to a specific owner or admin.

---

### 13. **Potential Front-Running in `approve`**
   - The `approve` function does not include protection against front-running attacks.
   - An attacker could front-run a user's `approve` transaction to set an allowance to a malicious value.

---

### 14. **Unused State Variables**
   - The `totalFees` variable is incremented but never used or exposed in any function.
   - This could lead to confusion about its purpose and waste gas.

---

### 15. **No Fallback or Receive Function**
   - The contract does not include a `fallback` or `receive` function.
   - If Ether is accidentally sent to the contract, it will be stuck permanently.

---

### 16. **Lack of Input Validation in `approve`**
   - The `approve` function does not validate if the `spender` address is the zero address.
   - Approving the zero address could lead to unintended behavior.

---

### 17. **No Mechanism to Pause Transfers**
   - The contract does not include a mechanism to pause transfers in case of emergencies (e.g., detected vulnerabilities or attacks).

---

### 18. **Potential Gas Limit Issues**
   - The `_transfer` function emits two `Transfer` events in certain cases, which could increase gas costs.
   - This could lead to gas limit issues in complex transactions or when interacting with other contracts.

---

### 19. **No Upgradeability Mechanism**
   - The contract is not upgradeable, meaning any vulnerabilities or bugs discovered after deployment cannot be fixed without deploying a new contract.

---

### 20. **Lack of Documentation**
   - The contract lacks inline comments or documentation explaining the purpose of functions, variables, and logic.
   - This makes it difficult for developers and auditors to understand the contract's behavior.","### **[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Report Description**:  
The `addExcluded()` function in `Vether.sol` allows any user to add their address to the `mapAddress_Excluded` mapping, which exempts them from transfer fees. This lack of access control enables malicious actors to bypass the fee mechanism entirely by calling `addExcluded()` with their own address. This undermines the intended fee structure and could lead to significant revenue loss for the protocol. The recommendation is to restrict access to the `addExcluded()` function, possibly by limiting it to a DAO or an admin role.

**Match in Response List**:  
Matches with the issue titled **""Lack of Access Control for `addExcluded` Function""**.

**Validation**:  
**Correct**. The response accurately identifies the issue with the `addExcluded` function, highlighting the lack of access control and the potential for malicious actors to exploit this to bypass fees. This aligns with the issue report's description and the recommended solution to restrict access to the function.

---

### **Summary of Matches and Gaps**

**Correct Matches**:  
- **[H-21] Anyone Can Avoid All Vether Transfer Fees By Adding Their Address to the Vether ExcludedAddresses List**

**Partially Correct Matches**:  
- *None*

**Missed Issues from Issue Report**:  
- *None*

---

### **Additional Observations**  
While the response list covers the issue in `addExcluded` correctly, it also includes several other vulnerabilities and issues that were not part of the provided `issue` report. These additional points, such as integer overflow/underflow, fee calculation precision loss, and lack of reentrancy protection, are valid concerns but are outside the scope of the specific issue being evaluated.",1,0,0,20,"```
1. Lack of Access Control for `addExcluded` Function
```",1.0
,,,,,,,,25,20,,,13,9,23,178,,
